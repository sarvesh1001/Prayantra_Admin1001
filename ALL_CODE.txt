
========================================
FILE: App.tsx
========================================

import 'react-native-gesture-handler';
import React, { useEffect, useState, useCallback } from 'react';
import { StatusBar } from 'expo-status-bar';
import { SafeAreaProvider, SafeAreaView } from 'react-native-safe-area-context';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { NavigationContainer } from '@react-navigation/native';
import { 
  View, 
  Text, 
  StyleSheet, 
  TouchableOpacity, 
  Platform,
  KeyboardAvoidingView,
  Keyboard,
  StatusBar as RNStatusBar
} from 'react-native';
import { QueryProvider } from './src/contexts/QueryProvider';
import { AuthProvider } from './src/contexts/AuthContext';
import { ToastProvider } from './src/components/Toast';
import AppNavigator, { navigationRef } from './src/navigation/AppNavigator';
import SplashScreen from './src/screens/SplashScreen';
import { initializeDeviceInfo } from './src/services/deviceInfo';
import * as SplashScreenModule from 'expo-splash-screen';

// Keep the splash screen visible while we fetch resources
SplashScreenModule.preventAutoHideAsync();

const App = () => {
  const [isReady, setIsReady] = useState(false);
  const [deviceInitialized, setDeviceInitialized] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [keyboardHeight, setKeyboardHeight] = useState(0);

  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      (e) => {
        setKeyboardHeight(e.endCoordinates.height);
      }
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setKeyboardHeight(0);
      }
    );

    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  const prepare = useCallback(async () => {
    try {
      await initializeDeviceInfo();
      setDeviceInitialized(true);

      // Simulate loading
      await new Promise(resolve => setTimeout(resolve, 1500));
    } catch (e: any) {
      console.error('App initialization failed:', e);
      setError(e.message || 'Unknown error');
    } finally {
      setIsReady(true);
      try {
        await SplashScreenModule.hideAsync();
      } catch (e) {
        console.error('Failed to hide splash screen:', e);
      }
    }
  }, []);

  useEffect(() => {
    prepare();
  }, [prepare]);

  // Show error screen
  if (error) {
    return (
      <SafeAreaProvider>
        <GestureHandlerRootView style={{ flex: 1 }}>
          <SafeAreaView style={[
            styles.errorContainer,
            { paddingTop: Platform.OS === 'android' ? RNStatusBar.currentHeight : 0 }
          ]}>
            <Text style={styles.errorTitle}>Initialization Error</Text>
            <Text style={styles.errorText}>{error}</Text>
            <TouchableOpacity
              style={styles.retryButton}
              onPress={() => {
                setError(null);
                setIsReady(false);
                setDeviceInitialized(false);
                prepare();
              }}
            >
              <Text style={styles.retryButtonText}>Retry</Text>
            </TouchableOpacity>
          </SafeAreaView>
        </GestureHandlerRootView>
      </SafeAreaProvider>
    );
  }

  // Show splash screen while loading
  if (!isReady || !deviceInitialized) {
    return <SplashScreen />;
  }

  // Main app with KeyboardAvoidingView for Android
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <QueryProvider>
          <AuthProvider>
            <ToastProvider>
              <NavigationContainer ref={navigationRef}>
                <KeyboardAvoidingView 
                  style={{ flex: 1 }}
                  behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
                  keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 0}
                >
                  <AppNavigator />
                </KeyboardAvoidingView>
              </NavigationContainer>
            </ToastProvider>
          </AuthProvider>
        </QueryProvider>
        <StatusBar style="auto" />
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
};

const styles = StyleSheet.create({
  errorContainer: {
    flex: 1,
    backgroundColor: '#FEF2F2',
    padding: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorTitle: {
    fontSize: 24,
    color: '#DC2626',
    fontWeight: 'bold',
    marginBottom: 20,
  },
  errorText: {
    fontSize: 16,
    color: '#7F1D1D',
    marginBottom: 30,
    textAlign: 'center',
    lineHeight: 24,
  },
  retryButton: {
    backgroundColor: '#DC2626',
    paddingHorizontal: 30,
    paddingVertical: 12,
    borderRadius: 8,
  },
  retryButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default App;
========================================
FILE: src/components/CustomDrawerContent.tsx
========================================

import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  StatusBar,
  Platform,
  Dimensions,
} from 'react-native';
import {
  DrawerContentScrollView,
  DrawerItemList,
} from '@react-navigation/drawer';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';
import { useNavigation } from '@react-navigation/native';
import { DrawerNavigationProp } from '@react-navigation/drawer';

const { width, height } = Dimensions.get('window');

/* ================= TYPES ================= */

type DrawerParamList = {
  MainDashboard: undefined;
  Profile: undefined;
  ChangeMPIN: undefined;
  Department: { department: string };
};

type StackParamList = {
  LoginInitiate: undefined;
  SendOTP: { phoneNumber: string; adminId?: string };
  VerifyOTP: { phoneNumber: string; adminId?: string };
  SetupMPIN: { phoneNumber: string; adminId: string };
  VerifyMPIN: { phoneNumber?: string; adminId?: string };
  ForgotMPIN: { phoneNumber?: string };
  MainDrawer: undefined;
};

type IconName = React.ComponentProps<typeof Icon>['name'];

interface CustomDrawerContentProps {
  props: any;
}

/* ================= COMPONENT ================= */

const CustomDrawerContent: React.FC<CustomDrawerContentProps> = ({ props }) => {
  const { adminInfo, logout } = useAuth();
  const { showToast } = useToast();
  const drawerNavigation =
    useNavigation<DrawerNavigationProp<DrawerParamList>>();

  /* ✅ TS-SAFE GUARDS (NO BEHAVIOR CHANGE) */
  const departments = adminInfo?.departments ?? [];
  const permissionsCount = adminInfo?.permissions?.length ?? 0;

  const handleLogout = async () => {
    await logout();
    showToast('success', 'Logged out successfully');
  };

  const getRoleBadgeColor = (role: string) => {
    switch (role) {
      case 'super_admin':
        return '#C084FC';
      case 'admin':
        return '#8B5CF6';
      case 'manager':
        return '#7C3AED';
      case 'employee':
        return '#6D28D9';
      default:
        return '#9333EA';
    }
  };

  const getRoleName = (role: string) => {
    switch (role) {
      case 'super_admin':
        return 'Super Admin';
      case 'admin':
        return 'Administrator';
      case 'manager':
        return 'Manager';
      case 'employee':
        return 'Employee';
      default:
        return role;
    }
  };

  const getDepartmentIcon = (department: string): IconName => {
    const icons: Record<string, IconName> = {
      HR: 'account-group',
      Finance: 'cash',
      Accounting: 'calculator',
      Procurement: 'cart',
      Inventory: 'warehouse',
      Logistics: 'truck',
      Sales: 'chart-line',
      Marketing: 'bullhorn',
      'Customer Support': 'headset',
      Operations: 'cog',
      IT: 'desktop-classic',
      Production: 'factory',
      'Quality Control': 'check-circle',
      'Quality Assurance': 'shield-check',
      'R&D': 'flask',
      Administration: 'office-building',
      'Employee Management': 'account-multiple',
      'Manager Management': 'account-tie',
      'Company Management': 'domain',
      'Super Admin Management': 'security',
    };
    return icons[department] || 'folder';
  };

  const departmentColors = [
    '#C084FC',
    '#A855F7',
    '#9333EA',
    '#7C3AED',
    '#6D28D9',
    '#5B21B6',
    '#4C1D95',
    '#3B0764',
    '#7E22CE',
    '#6B21A8',
  ];

  const getDepartmentColor = (index: number) =>
    departmentColors[index % departmentColors.length];

  /* ================= RENDER ================= */

  return (
    <View style={styles.container}>
      <StatusBar backgroundColor="#C084FC" barStyle="light-content" />

      {/* ===== HEADER ===== */}
      <View style={styles.header}>
        <View style={styles.profileSection}>
          <View style={styles.avatarContainer}>
            <Icon
              name="account-circle"
              size={height * 0.08}
              color="#FFFFFF"
            />
          </View>

          <View style={styles.userInfo}>
            <Text style={styles.userName} numberOfLines={1}>
              {adminInfo?.full_name || 'Admin User'}
            </Text>
            <Text style={styles.userEmail} numberOfLines={1}>
              {adminInfo?.username || 'admin@company.com'}
            </Text>

            <View
              style={[
                styles.roleBadge,
                {
                  backgroundColor: getRoleBadgeColor(
                    adminInfo?.role_string || 'admin'
                  ),
                },
              ]}
            >
              <Text style={styles.roleBadgeText}>
                {getRoleName(adminInfo?.role_string || 'admin')}
              </Text>
            </View>
          </View>
        </View>

        <View style={styles.statsContainer}>
          <View style={styles.statItem}>
            <Icon name="shield-check" size={width * 0.04} color="#FFFFFF" />
            <Text style={styles.statText}>
              {permissionsCount} Permissions
            </Text>
          </View>
          <View style={styles.statItem}>
            <Icon
              name="office-building"
              size={width * 0.04}
              color="#FFFFFF"
            />
            <Text style={styles.statText}>
              {departments.length} Departments
            </Text>
          </View>
        </View>
      </View>

      {/* ===== DRAWER CONTENT ===== */}
      <DrawerContentScrollView
        {...props}
        contentContainerStyle={styles.drawerContent}
        showsVerticalScrollIndicator={false}
      >
        <DrawerItemList {...props} />

        {/* ===== DEPARTMENTS ===== */}
        {departments.length > 0 && (
          <View style={styles.departmentsSection}>
            <Text style={styles.sectionTitle}>Departments</Text>

            {departments.map((department, index) => (
              <TouchableOpacity
                key={department}
                style={styles.departmentItem}
                onPress={() => {
                  drawerNavigation.navigate('Department', { department });
                  props.navigation.closeDrawer();
                }}
              >
                <View
                  style={[
                    styles.departmentIcon,
                    { backgroundColor: getDepartmentColor(index) },
                  ]}
                >
                  <Icon
                    name={getDepartmentIcon(department)}
                    size={width * 0.055}
                    color="#FFFFFF"
                  />
                </View>

                <Text style={styles.departmentName} numberOfLines={2}>
                  {department}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        )}
      </DrawerContentScrollView>

      {/* ===== FOOTER ===== */}
      <View style={styles.footer}>
        <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
          <Icon name="logout" size={width * 0.055} color="#EF4444" />
          <Text style={styles.logoutText}>Logout</Text>
        </TouchableOpacity>

        <View style={styles.versionContainer}>
          <Text style={styles.versionText}>Prayantra v1.0.0</Text>
          <Text style={styles.copyrightText}>
            © 2024 All rights reserved
          </Text>
        </View>
      </View>
    </View>
  );
};

/* ================= STYLES (UNCHANGED) ================= */

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#FFFFFF' },
  header: {
    backgroundColor: '#C084FC',
    paddingTop: Platform.OS === 'ios' ? height * 0.08 : height * 0.06,
    paddingHorizontal: width * 0.06,
    paddingBottom: height * 0.025,
    borderBottomLeftRadius: 20,
    borderBottomRightRadius: 20,
  },
  profileSection: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: height * 0.025,
  },
  avatarContainer: { marginRight: width * 0.04 },
  userInfo: { flex: 1 },
  userName: {
    fontSize: width * 0.048,
    fontWeight: '700',
    color: '#FFFFFF',
  },
  userEmail: {
    fontSize: width * 0.035,
    color: 'rgba(255,255,255,0.9)',
    marginBottom: height * 0.01,
  },
  roleBadge: {
    paddingHorizontal: width * 0.03,
    paddingVertical: height * 0.005,
    borderRadius: 12,
  },
  roleBadgeText: {
    fontSize: width * 0.03,
    fontWeight: '600',
    color: '#FFFFFF',
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    backgroundColor: 'rgba(255,255,255,0.15)',
    borderRadius: 12,
    padding: width * 0.03,
  },
  statItem: { flexDirection: 'row', alignItems: 'center' },
  statText: {
    fontSize: width * 0.03,
    color: '#FFFFFF',
    marginLeft: width * 0.015,
  },
  drawerContent: { paddingTop: height * 0.02 },
  departmentsSection: {
    paddingHorizontal: width * 0.05,
    marginVertical: height * 0.02,
  },
  sectionTitle: {
    fontSize: width * 0.035,
    fontWeight: '600',
    color: '#64748B',
    marginBottom: height * 0.015,
  },
  departmentItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: height * 0.015,
    paddingHorizontal: width * 0.025,
    borderRadius: 10,
    marginBottom: height * 0.01,
    backgroundColor: '#F8FAFC',
  },
  departmentIcon: {
    width: width * 0.1,
    height: width * 0.1,
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: width * 0.035,
  },
  departmentName: {
    fontSize: width * 0.038,
    color: '#1E293B',
    fontWeight: '500',
    flex: 1,
  },
  footer: {
    padding: width * 0.06,
    borderTopWidth: 1,
    borderTopColor: '#E2E8F0',
    backgroundColor: '#F8FAFC',
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#FEF2F2',
    paddingVertical: height * 0.015,
    borderRadius: 10,
    marginBottom: height * 0.02,
  },
  logoutText: {
    color: '#EF4444',
    fontSize: width * 0.038,
    fontWeight: '600',
    marginLeft: width * 0.02,
  },
  versionContainer: { alignItems: 'center' },
  versionText: {
    fontSize: width * 0.032,
    color: '#64748B',
  },
  copyrightText: {
    fontSize: width * 0.028,
    color: '#94A3B8',
  },
});

export default CustomDrawerContent;

========================================
FILE: src/components/DepartmentCard.tsx
========================================

import React from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
} from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface DepartmentCardProps {
  department: string;
  index: number;
  onPress: () => void;
}

const departmentIcons: Record<string, string> = {
  HR: 'account-group',
  Finance: 'cash',
  Accounting: 'calculator',
  Procurement: 'cart',
  Inventory: 'warehouse',
  Logistics: 'truck',
  Sales: 'chart-line',
  Marketing: 'bullhorn',
  'Customer Support': 'headset',
  Operations: 'cog',
  IT: 'desktop-classic',
  Production: 'factory',
  'Quality Control': 'check-circle',
  'Quality Assurance': 'shield-check',
  'R&D': 'flask',
  Administration: 'office-building',
  'Employee Management': 'account-multiple',
  'Manager Management': 'account-tie',
  'Company Management': 'domain',
  'Super Admin Management': 'security',
};

const departmentColors = [
  '#C084FC', // Purple
  '#A855F7',
  '#9333EA',
  '#7C3AED',
  '#6D28D9',
  '#5B21B6',
  '#4C1D95',
  '#3B0764',
  '#7E22CE',
  '#6B21A8',
];

const DepartmentCard: React.FC<DepartmentCardProps> = ({
  department,
  index,
  onPress,
}) => {
  const icon = departmentIcons[department] || 'folder';
  const color = departmentColors[index % departmentColors.length];

  return (
    <TouchableOpacity style={styles.card} onPress={onPress} activeOpacity={0.7}>
      <View style={[styles.iconContainer, { backgroundColor: `${color}15` }]}>
        <MaterialCommunityIcons name={icon as any} size={28} color={color} />
      </View>

      <Text style={styles.departmentName} numberOfLines={2}>
        {department}
      </Text>

      <View style={styles.arrowContainer}>
        <MaterialCommunityIcons name="chevron-right" size={20} color="#CBD5E1" />
      </View>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  card: {
    width: '48%',
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginHorizontal: '1%',
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#E2E8F0',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 2,
  },
  iconContainer: {
    width: 56,
    height: 56,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 12,
  },
  departmentName: {
    fontSize: 15,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 8,
    minHeight: 40,
  },
  arrowContainer: {
    alignItems: 'flex-end',
  },
});

export default React.memo(DepartmentCard);
========================================
FILE: src/components/MPINInput.tsx
========================================

import React, { useRef, useState, useEffect, forwardRef, useImperativeHandle } from 'react';
import {
  View,
  TextInput,
  StyleSheet,
  TouchableWithoutFeedback,
  Keyboard,
  Text,
  Dimensions,
  TouchableOpacity,
} from 'react-native';

const { width } = Dimensions.get('window');

interface MPINInputProps {
  length?: number;
  onComplete?: (mpin: string) => void;
  onSubmit?: (mpin: string) => void;
  error?: boolean;
  disabled?: boolean;
  autoFocus?: boolean;
  showSubmitButton?: boolean;
  secureTextEntry?: boolean;
}

export interface MPINInputRef {
  clearAll: () => void;
  focus: () => void;
}

const MPINInput = forwardRef<MPINInputRef, MPINInputProps>(({
  length = 6,
  onComplete,
  onSubmit,
  error = false,
  disabled = false,
  autoFocus = true,
  showSubmitButton = true,
  secureTextEntry = true,
}, ref) => {
  const [mpin, setMpin] = useState<string[]>(Array(length).fill(''));
  const inputsRef = useRef<TextInput[]>([]);

  useEffect(() => {
    if (autoFocus) {
      setTimeout(() => {
        inputsRef.current[0]?.focus();
      }, 300);
    }
  }, [autoFocus]);

  const handleChangeText = (text: string, index: number) => {
    if (disabled) return;

    const newMpin = [...mpin];
    
    // Handle paste
    if (text.length > 1) {
      const pastedDigits = text.split('').slice(0, length);
      pastedDigits.forEach((digit, idx) => {
        if (idx < length) {
          newMpin[idx] = digit;
        }
      });
      setMpin(newMpin);
      
      // Focus last input
      const lastIndex = Math.min(pastedDigits.length, length - 1);
      inputsRef.current[lastIndex]?.focus();
      
      // Check if complete
      const currentMpin = newMpin.join('');
      if (currentMpin.length === length) {
        onComplete?.(currentMpin);
        if (!showSubmitButton) {
          Keyboard.dismiss();
        }
      }
      return;
    }

    // Single digit input
    newMpin[index] = text;
    setMpin(newMpin);

    // Auto-focus next input
    if (text && index < length - 1) {
      inputsRef.current[index + 1]?.focus();
    }

    // Check if all digits are entered
    const currentMpin = newMpin.join('');
    if (currentMpin.length === length) {
      onComplete?.(currentMpin);
      if (!showSubmitButton) {
        Keyboard.dismiss();
      }
    }
  };

  const handleKeyPress = (e: any, index: number) => {
    // Handle backspace
    if (e.nativeEvent.key === 'Backspace' && !mpin[index] && index > 0) {
      inputsRef.current[index - 1]?.focus();
      const newMpin = [...mpin];
      newMpin[index - 1] = '';
      setMpin(newMpin);
    }
  };

  const handleInputFocus = (index: number) => {
    // Clear all inputs if user taps on any input
    const firstEmptyIndex = mpin.findIndex(digit => digit === '');
    if (firstEmptyIndex === -1 || index < firstEmptyIndex) {
      // User is trying to edit previous digits, clear from that point
      const newMpin = [...mpin];
      for (let i = index; i < length; i++) {
        newMpin[i] = '';
      }
      setMpin(newMpin);
    }
  };

  const clearAll = () => {
    const newMpin = Array(length).fill('');
    setMpin(newMpin);
    inputsRef.current[0]?.focus();
  };

  const focus = () => {
    inputsRef.current[0]?.focus();
  };

  const getCurrentMpin = () => {
    return mpin.join('');
  };

  useImperativeHandle(ref, () => ({
    clearAll,
    focus,
    getCurrentMpin: () => mpin.join(''),
  }));

  const handleSubmit = () => {
    const currentMpin = mpin.join('');
    if (currentMpin.length === length) {
      onSubmit?.(currentMpin);
      Keyboard.dismiss();
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.inputsContainer}>
        {Array.from({ length }).map((_, index) => (
          <View key={index} style={styles.inputWrapper}>
            <TextInput
              ref={ref => {
                if (ref) inputsRef.current[index] = ref;
              }}
              style={[
                styles.input,
                error && styles.inputError,
                mpin[index] && styles.inputFilled,
              ]}
              value={mpin[index]}
              onChangeText={text => handleChangeText(text, index)}
              onKeyPress={e => handleKeyPress(e, index)}
              onFocus={() => handleInputFocus(index)}
              keyboardType="number-pad"
              maxLength={index === 0 ? length : 1}
              secureTextEntry={secureTextEntry}
              editable={!disabled}
              selectTextOnFocus
              autoFocus={index === 0 && autoFocus}
              contextMenuHidden
            />
            {index < length - 1 && <View style={styles.separator} />}
          </View>
        ))}
      </View>
      
      {error && (
        <Text style={styles.errorText}>Invalid MPIN. Please try again.</Text>
      )}
      
      {showSubmitButton && (
        <TouchableOpacity
          style={[
            styles.submitButton,
            (disabled || mpin.join('').length !== length) && styles.submitButtonDisabled,
          ]}
          onPress={handleSubmit}
          disabled={disabled || mpin.join('').length !== length}
        >
          <Text style={styles.submitButtonText}>Submit</Text>
        </TouchableOpacity>
      )}
      
      <TouchableOpacity
        style={styles.clearButton}
        onPress={clearAll}
        disabled={disabled}
      >
        <Text style={styles.clearButtonText}>Clear All</Text>
      </TouchableOpacity>
    </View>
  );
});

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    paddingVertical: 20,
  },
  inputsContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 30,
  },
  inputWrapper: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  input: {
    width: 50,
    height: 60,
    borderWidth: 2,
    borderColor: '#E5E7EB',
    borderRadius: 12,
    fontSize: 24,
    fontWeight: '600',
    textAlign: 'center',
    color: '#1F2937',
    backgroundColor: '#FFFFFF',
  },
  inputFilled: {
    borderColor: '#8B5CF6',
    backgroundColor: '#F5F3FF',
  },
  inputError: {
    borderColor: '#EF4444',
    backgroundColor: '#FEF2F2',
  },
  separator: {
    width: 10,
  },
  errorText: {
    color: '#EF4444',
    fontSize: 14,
    marginTop: 12,
    textAlign: 'center',
    marginBottom: 20,
  },
  submitButton: {
    backgroundColor: '#8B5CF6',
    borderRadius: 12,
    paddingVertical: 16,
    paddingHorizontal: 40,
    marginBottom: 16,
    width: '80%',
  },
  submitButtonDisabled: {
    backgroundColor: '#D1D5DB',
  },
  submitButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
    textAlign: 'center',
  },
  clearButton: {
    paddingVertical: 12,
    paddingHorizontal: 24,
  },
  clearButtonText: {
    color: '#8B5CF6',
    fontSize: 14,
    fontWeight: '500',
  },
});

export default React.memo(MPINInput);
========================================
FILE: src/components/OTPInput.tsx
========================================

import React, { useRef, useState, useEffect, forwardRef, useImperativeHandle } from 'react';
import {
  View,
  TextInput,
  StyleSheet,
  Keyboard,
  Text,
  Dimensions,
  TouchableOpacity,
} from 'react-native';

const { width } = Dimensions.get('window');

interface OTPInputProps {
  length?: number;
  onComplete?: (otp: string) => void;
  onSubmit?: (otp: string) => void;
  error?: boolean;
  disabled?: boolean;
  autoFocus?: boolean;
  showSubmitButton?: boolean;
}

export interface OTPInputRef {
  clearAll: () => void;
  focus: () => void;
  getCurrentOtp: () => string;
}

const OTPInput = forwardRef<OTPInputRef, OTPInputProps>(({
  length = 6,
  onComplete,
  onSubmit,
  error = false,
  disabled = false,
  autoFocus = true,
  showSubmitButton = true,
}, ref) => {
  const [otp, setOtp] = useState<string[]>(Array(length).fill(''));
  const inputsRef = useRef<TextInput[]>([]);

  useEffect(() => {
    if (autoFocus) {
      setTimeout(() => {
        inputsRef.current[0]?.focus();
      }, 300);
    }
  }, [autoFocus]);

  const handleChangeText = (text: string, index: number) => {
    if (disabled) return;

    const newOtp = [...otp];
    
    // Handle paste
    if (text.length > 1) {
      const pastedDigits = text.split('').slice(0, length);
      pastedDigits.forEach((digit, idx) => {
        if (idx < length) {
          newOtp[idx] = digit;
        }
      });
      setOtp(newOtp);
      
      // Focus last input
      const lastIndex = Math.min(pastedDigits.length, length - 1);
      inputsRef.current[lastIndex]?.focus();
      
      // Check if complete
      const currentOtp = newOtp.join('');
      if (currentOtp.length === length) {
        onComplete?.(currentOtp);
        if (!showSubmitButton) {
          Keyboard.dismiss();
        }
      }
      return;
    }

    // Single digit input
    // Only update if text is empty or a single digit
    if (text === '' || /^\d$/.test(text)) {
      newOtp[index] = text;
      setOtp(newOtp);

      // Auto-focus next input
      if (text && index < length - 1) {
        setTimeout(() => {
          inputsRef.current[index + 1]?.focus();
        }, 10);
      }

      // Check if all digits are entered
      const currentOtp = newOtp.join('');
      if (currentOtp.length === length) {
        onComplete?.(currentOtp);
        if (!showSubmitButton) {
          Keyboard.dismiss();
        }
      }
    }
  };

  const handleKeyPress = (e: any, index: number) => {
    // Handle backspace
    if (e.nativeEvent.key === 'Backspace' && !otp[index] && index > 0) {
      inputsRef.current[index - 1]?.focus();
      const newOtp = [...otp];
      newOtp[index - 1] = '';
      setOtp(newOtp);
    }
  };

  const handleInputFocus = (index: number) => {
    // Only clear if user taps on an input and there are empty digits before this index
    const firstEmptyIndex = otp.findIndex(digit => digit === '');
    
    if (firstEmptyIndex === -1) {
      // All digits filled, just move cursor to tapped index
      return;
    }
    
    if (index < firstEmptyIndex) {
      // User is trying to edit previous digits, clear from that point
      const newOtp = [...otp];
      for (let i = index; i < length; i++) {
        newOtp[i] = '';
      }
      setOtp(newOtp);
    }
  };

  const clearAll = () => {
    const newOtp = Array(length).fill('');
    setOtp(newOtp);
    setTimeout(() => {
      inputsRef.current[0]?.focus();
    }, 10);
  };

  const focus = () => {
    inputsRef.current[0]?.focus();
  };

  const getCurrentOtp = () => {
    return otp.join('');
  };

  useImperativeHandle(ref, () => ({
    clearAll,
    focus,
    getCurrentOtp: () => otp.join(''),
  }));

  const handleSubmit = () => {
    const currentOtp = otp.join('');
    if (currentOtp.length === length) {
      onSubmit?.(currentOtp);
      Keyboard.dismiss();
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.inputsContainer}>
        {Array.from({ length }).map((_, index) => (
          <View key={index} style={styles.inputWrapper}>
            <TextInput
              ref={ref => {
                if (ref) inputsRef.current[index] = ref;
              }}
              style={[
                styles.input,
                error && styles.inputError,
                otp[index] && styles.inputFilled,
              ]}
              value={otp[index]}
              onChangeText={text => handleChangeText(text, index)}
              onKeyPress={e => handleKeyPress(e, index)}
              onFocus={() => handleInputFocus(index)}
              keyboardType="number-pad"
              maxLength={1}
              editable={!disabled}
              selectTextOnFocus
              autoFocus={index === 0 && autoFocus}
              contextMenuHidden
            />
            {index < length - 1 && <View style={styles.separator} />}
          </View>
        ))}
      </View>
      
      {error && (
        <Text style={styles.errorText}>Invalid OTP. Please try again.</Text>
      )}
      
      {showSubmitButton && (
        <TouchableOpacity
          style={[
            styles.submitButton,
            (disabled || otp.join('').length !== length) && styles.submitButtonDisabled,
          ]}
          onPress={handleSubmit}
          disabled={disabled || otp.join('').length !== length}
        >
          <Text style={styles.submitButtonText}>Submit</Text>
        </TouchableOpacity>
      )}
      
      <TouchableOpacity
        style={styles.clearButton}
        onPress={clearAll}
        disabled={disabled}
      >
        <Text style={styles.clearButtonText}>Clear All</Text>
      </TouchableOpacity>
    </View>
  );
});

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    paddingVertical: 20,
  },
  inputsContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 30,
  },
  inputWrapper: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  input: {
    width: 50,
    height: 60,
    borderWidth: 2,
    borderColor: '#E5E7EB',
    borderRadius: 12,
    fontSize: 24,
    fontWeight: '600',
    textAlign: 'center',
    color: '#1F2937',
    backgroundColor: '#FFFFFF',
  },
  inputFilled: {
    borderColor: '#8B5CF6',
    backgroundColor: '#F5F3FF',
  },
  inputError: {
    borderColor: '#EF4444',
    backgroundColor: '#FEF2F2',
  },
  separator: {
    width: 10,
  },
  errorText: {
    color: '#EF4444',
    fontSize: 14,
    marginTop: 12,
    textAlign: 'center',
    marginBottom: 20,
  },
  submitButton: {
    backgroundColor: '#8B5CF6',
    borderRadius: 12,
    paddingVertical: 16,
    paddingHorizontal: 40,
    marginBottom: 16,
    width: '80%',
  },
  submitButtonDisabled: {
    backgroundColor: '#D1D5DB',
  },
  submitButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
    textAlign: 'center',
  },
  clearButton: {
    paddingVertical: 12,
    paddingHorizontal: 24,
  },
  clearButtonText: {
    color: '#8B5CF6',
    fontSize: 14,
    fontWeight: '500',
  },
});

export default React.memo(OTPInput);
========================================
FILE: src/components/PrayantraLogo.tsx
========================================

import React, { useEffect, useRef } from 'react';
import { View, StyleSheet, ViewStyle, Animated, Easing } from 'react-native';
import Svg, {
  Path,
  Defs,
  LinearGradient,
  RadialGradient,
  Stop,
  Circle,
  G,
  Text as SvgText,
} from 'react-native-svg';

interface PrayantraLogoProps {
  size?: number;
  animated?: boolean;
  style?: ViewStyle;
  showText?: boolean;
}

export const PrayantraLogo: React.FC<PrayantraLogoProps> = ({
  size = 100,
  animated = false,
  style,
  showText = true,
}) => {
  // Animation refs for logo elements
  const ring1Anim = useRef(new Animated.Value(0)).current;
  const ring2Anim = useRef(new Animated.Value(0)).current;
  const dashAnim = useRef(new Animated.Value(0)).current;
  const particleAnims = useRef([...Array(6)].map(() => new Animated.Value(0))).current;
  const cubeAnim = useRef(new Animated.Value(0)).current;
  const glowAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (animated) {
      // Start all animations
      Animated.parallel([
        // Ring 1 animation
        Animated.loop(
          Animated.sequence([
            Animated.timing(ring1Anim, {
              toValue: 1,
              duration: 2000,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
            Animated.timing(ring1Anim, {
              toValue: 0,
              duration: 2000,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
          ])
        ),
        
        // Ring 2 animation
        Animated.loop(
          Animated.sequence([
            Animated.timing(ring2Anim, {
              toValue: 1,
              duration: 1500,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
            Animated.timing(ring2Anim, {
              toValue: 0,
              duration: 1500,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
          ])
        ),
        
        // Dash animation
        Animated.loop(
          Animated.timing(dashAnim, {
            toValue: 1,
            duration: 1500,
            easing: Easing.linear,
            useNativeDriver: false,
          })
        ),
        
        // Cube rotation
        Animated.loop(
          Animated.timing(cubeAnim, {
            toValue: 1,
            duration: 10000,
            easing: Easing.linear,
            useNativeDriver: false,
          })
        ),
        
        // Glow animation
        Animated.loop(
          Animated.sequence([
            Animated.timing(glowAnim, {
              toValue: 1,
              duration: 2000,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
            Animated.timing(glowAnim, {
              toValue: 0.5,
              duration: 2000,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
          ])
        ),
        
        // Particle animations
        ...particleAnims.map((anim, index) => 
          Animated.loop(
            Animated.sequence([
              Animated.timing(anim, {
                toValue: 1,
                duration: 1000 + index * 200,
                easing: Easing.inOut(Easing.sin),
                useNativeDriver: false,
              }),
              Animated.timing(anim, {
                toValue: 0,
                duration: 1000 + index * 200,
                easing: Easing.inOut(Easing.sin),
                useNativeDriver: false,
              }),
            ])
          )
        ),
      ]).start();
    }
  }, [animated]);

  const ring1Radius = ring1Anim.interpolate({
    inputRange: [0, 1],
    outputRange: [85, 95],
  });

  const ring2Radius = ring2Anim.interpolate({
    inputRange: [0, 1],
    outputRange: [70, 75],
  });

  const dashOffset = dashAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 20],
  });

  const dashOffset2 = dashAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [20, 0],
  });

  const cubeRotate = cubeAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0 100 100', '45 100 100'],
  });

  const glowOpacity = glowAnim.interpolate({
    inputRange: [0, 0.5, 1],
    outputRange: [0.7, 1, 0.7],
  });

  return (
    <View style={[styles.container, style]}>
      <Svg width={size} height={size} viewBox="0 0 200 200">
        <Defs>
          <LinearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
            <Stop offset="0%" stopColor="#4A00E0" stopOpacity="1" />
            <Stop offset="50%" stopColor="#8E2DE2" stopOpacity="1" />
            <Stop offset="100%" stopColor="#00B4DB" stopOpacity="1" />
          </LinearGradient>
          
          <LinearGradient id="grad2" x1="0%" y1="0%" x2="0%" y2="100%">
            <Stop offset="0%" stopColor="#00B4DB" stopOpacity="0.9" />
            <Stop offset="100%" stopColor="#0083B0" stopOpacity="0.9" />
          </LinearGradient>
          
          <RadialGradient id="centerGlow" cx="50%" cy="50%" r="50%">
            <Stop offset="0%" stopColor="#FFFFFF" stopOpacity="0.3" />
            <Stop offset="100%" stopColor="#FFFFFF" stopOpacity="0" />
          </RadialGradient>
        </Defs>
        
        {/* Outer rings */}
        <G>
          {/* Animated outer ring 1 */}
          {animated ? (
            <AnimatedCircle 
              cx="100"
              cy="100"
              r={ring1Radius}
              fill="none"
              stroke="url(#grad1)"
              strokeWidth="2"
            />
          ) : (
            <Circle cx="100" cy="100" r="85" fill="none" stroke="url(#grad1)" strokeWidth="2" />
          )}
          
          {/* Animated outer ring 2 */}
          {animated ? (
            <AnimatedCircle 
              cx="100"
              cy="100"
              r={ring2Radius}
              fill="none"
              stroke="rgba(142, 45, 226, 0.4)"
              strokeWidth="1.5"
            />
          ) : (
            <Circle cx="100" cy="100" r="70" fill="none" stroke="rgba(142, 45, 226, 0.4)" strokeWidth="1.5" />
          )}
        </G>
        
        {/* Central core */}
        <G>
          {/* Center circle */}
          <Circle cx="100" cy="100" r="30" fill="url(#grad2)" />
          
          {/* Neural network paths */}
          {animated ? (
            <>
              <AnimatedPath
                d="M70,100 Q100,70 130,100 Q100,130 70,100"
                fill="none"
                stroke="rgba(255,255,255,0.5)"
                strokeWidth="1.5"
                strokeDasharray="5,5"
                strokeDashoffset={dashOffset}
              />
              <AnimatedPath
                d="M100,70 Q130,100 100,130 Q70,100 100,70"
                fill="none"
                stroke="rgba(255,255,255,0.5)"
                strokeWidth="1.5"
                strokeDasharray="5,5"
                strokeDashoffset={dashOffset2}
              />
            </>
          ) : (
            <>
              <Path
                d="M70,100 Q100,70 130,100 Q100,130 70,100"
                fill="none"
                stroke="rgba(255,255,255,0.5)"
                strokeWidth="1.5"
                strokeDasharray="5,5"
              />
              <Path
                d="M100,70 Q130,100 100,130 Q70,100 100,70"
                fill="none"
                stroke="rgba(255,255,255,0.5)"
                strokeWidth="1.5"
                strokeDasharray="5,5"
              />
            </>
          )}
          
          {/* Animated particles around center */}
          {[...Array(6)].map((_, i) => {
            const angle = (i * 60) * Math.PI / 180;
            const radius = 50;
            const x = 100 + radius * Math.cos(angle);
            const y = 100 + radius * Math.sin(angle);
            
            if (animated) {
              return (
                <AnimatedCircle
                  key={i}
                  cx={x}
                  cy={y}
                  r={particleAnims[i].interpolate({
                    inputRange: [0, 1],
                    outputRange: [4, 6],
                  })}
                  fill="#00B4DB"
                  opacity={particleAnims[i].interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.7, 1],
                  })}
                />
              );
            } else {
              return (
                <Circle key={i} cx={x} cy={y} r="4" fill="#00B4DB" opacity="0.8" />
              );
            }
          })}
          
          {/* Center cube/tech element */}
          {animated ? (
            <AnimatedPath
              d="M90,90 L110,90 L110,110 L90,110 Z"
              fill="none"
              stroke="white"
              strokeWidth="2"
              strokeLinecap="round"
              rotation={cubeRotate}
            />
          ) : (
            <Path
              d="M90,90 L110,90 L110,110 L90,110 Z"
              fill="none"
              stroke="white"
              strokeWidth="2"
              strokeLinecap="round"
            />
          )}
          
          {/* Center glow with animation */}
          {animated ? (
            <AnimatedCircle 
              cx="100"
              cy="100"
              r="35"
              fill="url(#centerGlow)"
              opacity={glowOpacity}
            />
          ) : (
            <Circle cx="100" cy="100" r="35" fill="url(#centerGlow)" opacity="0.8" />
          )}
        </G>
        
        {/* App Name and Tagline */}
        {showText && (
          <G>
            <SvgText
              x="100"
              y="170"
              textAnchor="middle"
              fill="white"
              fontSize="14"
              fontWeight="bold"
              fontFamily="sans-serif"
            >
              PRAYANTRA
            </SvgText>
            <SvgText
              x="100"
              y="185"
              textAnchor="middle"
              fill="rgba(255,255,255,0.8)"
              fontSize="8"
              fontFamily="sans-serif"
            >
              Powering Enterprise
            </SvgText>
          </G>
        )}
      </Svg>
    </View>
  );
};

// Helper components for animated SVG elements
const AnimatedCircle = ({ cx, cy, r, fill, stroke, strokeWidth, opacity, ...props }: any) => {
  const getValue = (value: any) => {
    if (value && typeof value === 'object' && 'interpolate' in value) {
      return value.__getValue ? value.__getValue() : value;
    }
    return value;
  };

  return (
    <Circle
      cx={getValue(cx)}
      cy={getValue(cy)}
      r={getValue(r)}
      fill={fill}
      stroke={stroke}
      strokeWidth={strokeWidth}
      opacity={getValue(opacity)}
      {...props}
    />
  );
};

const AnimatedPath = ({ d, fill, stroke, strokeWidth, strokeDasharray, strokeDashoffset, rotation, ...props }: any) => {
  const getValue = (value: any) => {
    if (value && typeof value === 'object' && 'interpolate' in value) {
      return value.__getValue ? value.__getValue() : value;
    }
    return value;
  };

  const transform = rotation ? `rotate(${getValue(rotation)})` : undefined;
  
  return (
    <Path
      d={d}
      fill={fill}
      stroke={stroke}
      strokeWidth={strokeWidth}
      strokeDasharray={strokeDasharray}
      strokeDashoffset={getValue(strokeDashoffset)}
      transform={transform}
      {...props}
    />
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
  },
});

export default PrayantraLogo;
========================================
FILE: src/components/QuickActions.tsx
========================================

import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface QuickActionsProps {
  navigation: any;
}

const QuickActions: React.FC<QuickActionsProps> = ({ navigation }) => {
  const actions = [
    { icon: 'account-plus', label: 'Add Employee', screen: 'AddEmployee' },
    { icon: 'file-document', label: 'Create Report', screen: 'CreateReport' },
    { icon: 'calendar-clock', label: 'Attendance', screen: 'Attendance' },
    { icon: 'chart-bar', label: 'Analytics', screen: 'Analytics' },
  ];

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Quick Actions</Text>

      <View style={styles.actionsGrid}>
        {actions.map((action, index) => (
          <TouchableOpacity
            key={index}
            style={styles.actionButton}
            onPress={() => navigation.navigate(action.screen)}
          >
            <View style={styles.iconContainer}>
              <MaterialCommunityIcons
                name={action.icon as any}
                size={24}
                color="#C084FC" // Purple
              />
            </View>

            <Text style={styles.actionLabel}>{action.label}</Text>
          </TouchableOpacity>
        ))}
      </View>
    </View>
  );
};

export default QuickActions;

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginTop: 16,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 16,
  },
  actionsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  actionButton: {
    width: '48%',
    alignItems: 'center',
    marginBottom: 16,
  },
  iconContainer: {
    width: 56,
    height: 56,
    borderRadius: 12,
    backgroundColor: '#FAF5FF', // Light purple background
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 8,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  actionLabel: {
    fontSize: 13,
    color: '#475569',
    textAlign: 'center',
  },
});
========================================
FILE: src/components/StatsOverview.tsx
========================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface StatsOverviewProps {
  dailyQuota: {
    limit: number;
    remaining: number;
    used: number;
  };
  permissions: number;
  departments: number;
  isLoading: boolean;
}

const StatsOverview: React.FC<StatsOverviewProps> = ({
  dailyQuota,
  permissions,
  departments,
  isLoading,
}) => {
  const stats = [
    {
      icon: 'shield-check',
      label: 'Permissions',
      value: permissions.toString(),
      color: '#C084FC', // Purple
      bgColor: '#FAF5FF',
    },
    {
      icon: 'office-building',
      label: 'Departments',
      value: departments.toString(),
      color: '#A855F7', // Purple
      bgColor: '#F3E8FF',
    },
    {
      icon: 'chart-bar',
      label: 'Quota Used',
      value: dailyQuota.used.toString(),
      color: '#9333EA', // Purple
      bgColor: '#E9D5FF',
    },
    {
      icon: 'clock-outline',
      label: 'Quota Left',
      value: dailyQuota.remaining.toString(),
      color: '#7C3AED', // Purple
      bgColor: '#DDD6FE',
    },
  ];

  if (isLoading) {
    return (
      <View style={styles.container}>
        <Text>Loading stats...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Overview</Text>

      <View style={styles.statsGrid}>
        {stats.map((stat, index) => (
          <View key={index} style={styles.statCard}>
            <View
              style={[
                styles.iconContainer,
                { backgroundColor: stat.bgColor },
              ]}
            >
              <MaterialCommunityIcons
                name={stat.icon as any}
                size={20}
                color={stat.color}
              />
            </View>

            <Text style={styles.statValue}>{stat.value}</Text>
            <Text style={styles.statLabel}>{stat.label}</Text>
          </View>
        ))}
      </View>
    </View>
  );
};

export default StatsOverview;

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginTop: 16,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 16,
  },
  statsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  statCard: {
    width: '48%',
    alignItems: 'center',
    paddingVertical: 12,
    marginBottom: 12,
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 10,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 8,
  },
  statValue: {
    fontSize: 20,
    fontWeight: '700',
    color: '#1E293B',
    marginBottom: 2,
  },
  statLabel: {
    fontSize: 12,
    color: '#64748B',
  },
});
========================================
FILE: src/components/Toast.tsx
========================================

import React, { createContext, useContext, useState, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Animated,
  TouchableOpacity,
  Dimensions,
} from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

const { width } = Dimensions.get('window');

interface ToastContextType {
  showToast: (
    type: 'success' | 'error' | 'info',
    message: string,
    duration?: number
  ) => void;
  hideToast: () => void;
}

const ToastContext = createContext<ToastContextType | undefined>(undefined);

export const useToast = () => {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within ToastProvider');
  }
  return context;
};

interface ToastProps {
  type: 'success' | 'error' | 'info';
  message: string;
  visible: boolean;
  onHide: () => void;
}

const Toast: React.FC<ToastProps> = ({ type, message, visible, onHide }) => {
  const [animation] = useState(new Animated.Value(0));

  React.useEffect(() => {
    if (visible) {
      Animated.spring(animation, {
        toValue: 1,
        useNativeDriver: true,
        tension: 50,
        friction: 7,
      }).start();

      const timer = setTimeout(() => {
        hide();
      }, 3000);

      return () => clearTimeout(timer);
    } else {
      hide();
    }
  }, [visible]);

  const hide = () => {
    Animated.spring(animation, {
      toValue: 0,
      useNativeDriver: true,
      tension: 50,
      friction: 7,
    }).start(() => {
      onHide();
    });
  };

  const getConfig = () => {
    switch (type) {
      case 'success':
        return {
          icon: 'check-circle' as const,
          color: '#10B981',
          bgColor: '#D1FAE5',
          borderColor: '#A7F3D0',
        };
      case 'error':
        return {
          icon: 'alert-circle' as const,
          color: '#EF4444',
          bgColor: '#FEE2E2',
          borderColor: '#FECACA',
        };
      case 'info':
      default:
        return {
          icon: 'information' as const,
          color: '#C084FC',
          bgColor: '#FAF5FF',
          borderColor: '#E9D5FF',
        };
    }
  };

  const config = getConfig();

  const translateY = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [-100, 10],
  });

  if (!visible) return null;

  return (
    <Animated.View
      style={[
        styles.container,
        {
          backgroundColor: config.bgColor,
          borderColor: config.borderColor,
          transform: [{ translateY }],
        },
      ]}
    >
      <View style={styles.content}>
        <MaterialCommunityIcons
          name={config.icon}
          size={20}
          color={config.color}
        />

        <Text style={[styles.message, { color: config.color }]}>
          {message}
        </Text>

        <TouchableOpacity onPress={hide} style={styles.closeButton}>
          <MaterialCommunityIcons
            name="close"
            size={16}
            color={config.color}
          />
        </TouchableOpacity>
      </View>
    </Animated.View>
  );
};

export const ToastProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [toast, setToast] = useState<{
    type: 'success' | 'error' | 'info';
    message: string;
    visible: boolean;
  }>({
    type: 'success',
    message: '',
    visible: false,
  });

  const showToast = useCallback(
    (type: 'success' | 'error' | 'info', message: string, duration = 3000) => {
      setToast({ type, message, visible: true });
    },
    []
  );

  const hideToast = useCallback(() => {
    setToast(prev => ({ ...prev, visible: false }));
  }, []);

  return (
    <ToastContext.Provider value={{ showToast, hideToast }}>
      {children}
      <Toast
        type={toast.type}
        message={toast.message}
        visible={toast.visible}
        onHide={hideToast}
      />
    </ToastContext.Provider>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    top: 0,
    left: 20,
    right: 20,
    borderRadius: 8,
    borderWidth: 1,
    padding: 16,
    zIndex: 9999,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 8,
  },
  content: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  message: {
    flex: 1,
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 12,
    marginRight: 8,
  },
  closeButton: {
    padding: 4,
  },
});
========================================
FILE: src/contexts/AuthContext.tsx
========================================

import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { AdminInfo, AuthTokens, LoginFlowState, ApiError } from '@/types';
import { api } from '@/services/api';
import { 
  getItem, 
  setItem, 
  removeItem, 
  STORAGE_KEYS,
  hasStoredPhoneNumber,
  getFormattedPhoneNumber,
  storePhoneNumberPermanently,
  removePhoneNumberPermanently,
  clearSessionData
} from '@/services/storage';
import { getStoredDeviceInfo } from '@/services/deviceInfo';
import { useQueryClient } from '@tanstack/react-query';

interface AuthContextType {
  isAuthenticated: boolean;
  isLoading: boolean;
  isInitializing: boolean;
  adminInfo: AdminInfo | null;
  tokens: AuthTokens | null;
  phoneNumber: string | null;
  adminId: string | null;
  loginFlow: LoginFlowState | null;
  login: (phone: string, tokens: AuthTokens, adminInfo: AdminInfo) => Promise<void>;
  logout: () => Promise<void>;
  refreshAuth: () => Promise<boolean>;
  updateAdminInfo: (info: Partial<AdminInfo>) => void;
  checkExistingSession: () => Promise<void>;
  storePhoneNumber: (phone: string, adminId?: string) => Promise<void>;
  clearPhoneNumber: () => Promise<void>;
  validateSession: () => Promise<boolean>;
  clearTokensAndNavigate: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [isInitializing, setIsInitializing] = useState(true);
  const [adminInfo, setAdminInfo] = useState<AdminInfo | null>(null);
  const [tokens, setTokens] = useState<AuthTokens | null>(null);
  const [phoneNumber, setPhoneNumber] = useState<string | null>(null);
  const [adminId, setAdminId] = useState<string | null>(null);
  const [loginFlow, setLoginFlow] = useState<LoginFlowState | null>(null);
  const queryClient = useQueryClient();

  const validateSession = useCallback(async (): Promise<boolean> => {
    try {
      console.log('🔍 [AUTH] Validating session...');
      
      // First check if we have an access token
      const accessToken = await getItem(STORAGE_KEYS.ACCESS_TOKEN);
      console.log('🔐 [AUTH] Access token check:', {
        hasToken: !!accessToken,
        tokenLength: accessToken?.length || 0,
        tokenPreview: accessToken ? `${accessToken.substring(0, 30)}...` : 'NONE'
      });
      
      if (!accessToken) {
        console.log('❌ [AUTH] No access token found for validation');
        return false;
      }

      // Decode JWT to check expiration
      try {
        const payload = JSON.parse(atob(accessToken.split('.')[1]));
        const exp = payload.exp * 1000; // Convert to milliseconds
        const now = Date.now();
        console.log('⏰ [AUTH] Token expiry check:', {
          expiryTime: new Date(exp).toISOString(),
          currentTime: new Date(now).toISOString(),
          expiresIn: Math.floor((exp - now) / 1000) + ' seconds',
          isExpired: now >= exp
        });
        
        if (now >= exp) {
          console.log('❌ [AUTH] Token has expired');
          return false;
        }
      } catch (decodeError) {
        console.warn('⚠️ [AUTH] Could not decode token:', decodeError);
      }

      console.log('📡 [AUTH] Calling validateSession API...');
      const response = await api.validateSession();
      console.log('✅ [AUTH] Session validation response:', response.data);
      
      const { valid } = response.data.data;
      console.log('✅ [AUTH] Session validation result:', valid);
      return valid;
    } catch (error: any) {
      console.error('❌ [AUTH] Session validation error:', {
        status: error.response?.status,
        data: error.response?.data,
        message: error.message,
        url: error.config?.url,
        headers: error.config?.headers
      });
      return false;
    }
  }, []);

  const storePhoneNumber = useCallback(async (phone: string, adminId?: string) => {
    try {
      console.log('🔐 [AUTH] Storing phone number:', phone, 'adminId:', adminId);
      
      // Store full phone number without spaces in format +919876543210
      const formattedPhone = phone.replace(/\s/g, '');
      
      if (adminId) {
        // Store phone number PERMANENTLY for auto-login feature
        await storePhoneNumberPermanently(formattedPhone, adminId);
        setAdminId(adminId);
      } else {
        // Just store phone number temporarily
        await setItem(STORAGE_KEYS.PHONE_NUMBER, formattedPhone);
      }
      
      setPhoneNumber(formattedPhone);
      console.log('✅ [AUTH] Phone number stored successfully:', formattedPhone);
    } catch (error) {
      console.error('❌ [AUTH] Error storing phone number:', error);
    }
  }, []);

  const clearPhoneNumber = useCallback(async () => {
    try {
      await removePhoneNumberPermanently();
      setPhoneNumber(null);
      setAdminId(null);
      console.log('✅ [AUTH] Phone number cleared permanently');
    } catch (error) {
      console.error('❌ [AUTH] Error clearing phone number:', error);
    }
  }, []);

  const clearTokensAndNavigate = useCallback(async () => {
    console.log('🔐 [AUTH] Clearing tokens for session validation failure...');
    
    try {
      // Clear only tokens, keep phone number and admin ID for VerifyMPIN
      await clearSessionData();
      
      queryClient.clear();
      
      // Reset auth state but keep phone number for VerifyMPIN
      setIsAuthenticated(false);
      setAdminInfo(null);
      setTokens(null);
      setLoginFlow(null);
      
      console.log('✅ [AUTH] Tokens cleared, phone number preserved for VerifyMPIN');
    } catch (error) {
      console.error('❌ [AUTH] Error clearing tokens:', error);
    }
  }, [queryClient]);

  const initializeAuth = useCallback(async () => {
    try {
      console.log('🔄 [AUTH] Initializing authentication...');
      setIsInitializing(true);
      setIsLoading(true);
      
      // Clear ALL tokens on app start - don't validate old sessions
      console.log('🧹 [AUTH] Clearing all tokens on app start...');
      await clearSessionData();
      
      // Check if we have stored phone number PERMANENTLY
      const hasPhone = await hasStoredPhoneNumber();
      const formattedPhone = await getFormattedPhoneNumber();
      
      console.log('📱 [AUTH] Stored phone check:', { 
        hasPhone, 
        formattedPhone,
        phoneNumber: await getItem(STORAGE_KEYS.PHONE_NUMBER),
        adminId: await getItem(STORAGE_KEYS.ADMIN_ID)
      });
      
      if (hasPhone && formattedPhone) {
        setPhoneNumber(formattedPhone);
        
        const storedAdminId = await getItem(STORAGE_KEYS.ADMIN_ID);
        if (storedAdminId) {
          setAdminId(storedAdminId);
        }
        
        console.log('✅ [AUTH] Phone number found, NOT authenticated - will go to VerifyMPIN');
        setIsAuthenticated(false);
      } else {
        // No phone number stored
        console.log('❌ [AUTH] No phone number stored in permanent storage');
        setIsAuthenticated(false);
      }
    } catch (error) {
      console.error('❌ [AUTH] Auth initialization error:', error);
      setIsAuthenticated(false);
    } finally {
      console.log('✅ [AUTH] Auth initialization complete');
      setIsLoading(false);
      setIsInitializing(false);
    }
  }, []);

  useEffect(() => {
    console.log('🚀 [AUTH] AuthProvider mounted, initializing auth...');
    initializeAuth();
  }, [initializeAuth]);

  const startTokenRefresh = useCallback(() => {
    console.log('🔄 [AUTH] Starting token refresh interval');
    const refreshInterval = setInterval(async () => {
      try {
        console.log('🔄 [AUTH] Refreshing token...');
        const refreshToken = await getItem(STORAGE_KEYS.REFRESH_TOKEN);
        if (refreshToken) {
          const response = await api.refreshToken(refreshToken);
          const newTokens = response.data;
          
          if (newTokens?.access_token) {
            await setItem(STORAGE_KEYS.ACCESS_TOKEN, newTokens.access_token);
          }
          if (newTokens?.refresh_token) {
            await setItem(STORAGE_KEYS.REFRESH_TOKEN, newTokens.refresh_token);
          }
          
          setTokens(newTokens);
          console.log('✅ [AUTH] Token refreshed successfully');
        }
      } catch (error) {
        console.error('❌ [AUTH] Token refresh failed:', error);
      }
    }, 4.5 * 60 * 1000); // Refresh every 4.5 minutes

    return () => clearInterval(refreshInterval);
  }, []);

  const login = useCallback(async (
    phone: string, 
    tokensData: AuthTokens, 
    adminInfoData: AdminInfo
  ) => {
    try {
      console.log('🔐 [AUTH] Login attempt for phone:', phone);
      
      // Validate tokens before storing
      if (!tokensData?.access_token || !tokensData?.refresh_token) {
        console.error('❌ [AUTH] Invalid tokens received:', tokensData);
        throw new Error('Invalid tokens received');
      }

      console.log('📝 [AUTH] Storing tokens and admin info...');
      console.log('🔐 [AUTH] Access Token (first 50 chars):', tokensData.access_token.substring(0, 50));
      console.log('🔐 [AUTH] Refresh Token (first 20 chars):', tokensData.refresh_token.substring(0, 20));
      console.log('👤 [AUTH] Admin ID:', adminInfoData.admin_id);
      
      // Store tokens and admin info (temporary - for current session only)
      await setItem(STORAGE_KEYS.ACCESS_TOKEN, tokensData.access_token);
      await setItem(STORAGE_KEYS.REFRESH_TOKEN, tokensData.refresh_token);
      await setItem(STORAGE_KEYS.ADMIN_INFO, JSON.stringify(adminInfoData));
      
      // Store phone number PERMANENTLY for auto-login (only phone number, not tokens)
      await storePhoneNumberPermanently(phone, adminInfoData.admin_id);

      // Verify storage
      const storedAccessToken = await getItem(STORAGE_KEYS.ACCESS_TOKEN);
      const storedRefreshToken = await getItem(STORAGE_KEYS.REFRESH_TOKEN);
      const storedAdminInfo = await getItem(STORAGE_KEYS.ADMIN_INFO);
      
      console.log('✅ [AUTH] Storage verification:', {
        accessTokenStored: !!storedAccessToken,
        refreshTokenStored: !!storedRefreshToken,
        adminInfoStored: !!storedAdminInfo,
        accessTokenLength: storedAccessToken?.length || 0,
        refreshTokenLength: storedRefreshToken?.length || 0,
        accessTokenMatch: storedAccessToken?.substring(0, 50) === tokensData.access_token.substring(0, 50)
      });

      // Set state
      setPhoneNumber(phone.replace(/\s/g, ''));
      setTokens(tokensData);
      setAdminInfo(adminInfoData);
      setAdminId(adminInfoData.admin_id);
      setIsAuthenticated(true);

      startTokenRefresh();
      console.log('✅ [AUTH] Login successful');
      
    } catch (error) {
      console.error('❌ [AUTH] Login error:', error);
      throw error;
    }
  }, [startTokenRefresh]);

  const logout = useCallback(async () => {
    console.log('🚪 [AUTH] Logging out...');
    try {
      const refreshToken = await getItem(STORAGE_KEYS.REFRESH_TOKEN);
      if (refreshToken) {
        console.log('📡 [AUTH] Calling logout API...');
        await api.logout(refreshToken);
      }
    } catch (error) {
      console.error('❌ [AUTH] Logout API error:', error);
    } finally {
      console.log('🧹 [AUTH] Clearing all auth data but keeping phone number...');
      
      // Clear ONLY tokens and admin info, KEEP phone number and admin ID
      await clearSessionData();
      
      queryClient.clear();
      
      // Reset auth state but keep phone number for VerifyMPIN
      setIsAuthenticated(false);
      setAdminInfo(null);
      setTokens(null);
      setLoginFlow(null);
      
      console.log('✅ [AUTH] Logout complete - Phone number preserved for auto-login');
    }
  }, [queryClient]);

  const refreshAuth = useCallback(async (): Promise<boolean> => {
    try {
      console.log('🔄 [AUTH] Refreshing authentication...');
      const refreshToken = await getItem(STORAGE_KEYS.REFRESH_TOKEN);
      if (!refreshToken) {
        console.log('❌ [AUTH] No refresh token found');
        return false;
      }

      const response = await api.refreshToken(refreshToken);
      const newTokens = response.data;
      
      // Validate new tokens
      if (!newTokens?.access_token || !newTokens?.refresh_token) {
        console.error('❌ [AUTH] Invalid tokens received from refresh');
        return false;
      }
      
      console.log('📝 [AUTH] Storing refreshed tokens...');
      await setItem(STORAGE_KEYS.ACCESS_TOKEN, newTokens.access_token);
      await setItem(STORAGE_KEYS.REFRESH_TOKEN, newTokens.refresh_token);
      
      setTokens(newTokens);
      console.log('✅ [AUTH] Auth refresh successful');
      return true;
    } catch (error) {
      console.error('❌ [AUTH] Auth refresh failed:', error);
      return false;
    }
  }, []);

  const updateAdminInfo = useCallback((info: Partial<AdminInfo>) => {
    setAdminInfo((prev: AdminInfo | null) => prev ? { ...prev, ...info } : null);
    
    if (adminInfo) {
      const updatedInfo = { ...adminInfo, ...info };
      setItem(STORAGE_KEYS.ADMIN_INFO, JSON.stringify(updatedInfo)).catch(console.error);
    }
  }, [adminInfo]);

  const checkExistingSession = useCallback(async () => {
    try {
      console.log('🔍 [AUTH] Checking existing session...');
      const formattedPhone = await getFormattedPhoneNumber();
      if (!formattedPhone) {
        console.log('❌ [AUTH] No phone number to check session');
        return;
      }

      const response = await api.loginInitiate(formattedPhone);
      console.log('📱 [AUTH] Login initiate response:', response.data);
      
      if (response.data.success) {
        const { user_exists, has_mpin, mpin_locked, device_trusted } = response.data.data;
        
        if (user_exists && !mpin_locked) {
          if (device_trusted && has_mpin) {
            setLoginFlow('existing_user_mpin');
          } else if (!device_trusted) {
            setLoginFlow('device_not_trusted');
          } else if (!has_mpin) {
            setLoginFlow('new_user_no_mpin');
          }
        }
      }
    } catch (error) {
      console.error('❌ [AUTH] Session check error:', error);
    }
  }, []);

  const value: AuthContextType = {
    isAuthenticated,
    isLoading,
    isInitializing,
    adminInfo,
    tokens,
    phoneNumber,
    adminId,
    loginFlow,
    login,
    logout,
    refreshAuth,
    updateAdminInfo,
    checkExistingSession,
    storePhoneNumber,
    clearPhoneNumber,
    validateSession,
    clearTokensAndNavigate,
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};
========================================
FILE: src/contexts/QueryProvider.tsx
========================================

import React from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager } from '@tanstack/react-query';

// Set up network status for React Query
onlineManager.setEventListener(setOnline => {
  return NetInfo.addEventListener(state => {
    setOnline(!!state.isConnected);
  });
});

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
      staleTime: 5 * 60 * 1000, // 5 minutes
      gcTime: 10 * 60 * 1000, // 10 minutes (cacheTime is now gcTime in v5)
      networkMode: 'offlineFirst',
      refetchOnWindowFocus: false,
      refetchOnReconnect: true,
    },
    mutations: {
      retry: 1,
    },
  },
});

export const QueryProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};
========================================
FILE: src/navigation/AppNavigator.tsx
========================================

import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { createDrawerNavigator } from '@react-navigation/drawer';
import { useAuth } from '@/contexts/AuthContext';
import { View, ActivityIndicator } from 'react-native';
import { NavigationContainerRef } from '@react-navigation/native';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';

// Screens
import LoginInitiateScreen from '@/screens/auth/LoginInitiateScreen';
import SendOTPScreen from '@/screens/auth/SendOTPScreen';
import VerifyOTPScreen from '@/screens/auth/VerifyOTPScreen';
import SetupMPINScreen from '@/screens/auth/SetupMPINScreen';
import VerifyMPINScreen from '@/screens/auth/VerifyMPINScreen';
import ForgotMPINScreen from '@/screens/auth/ForgotMPINScreen';
import MainDashboardScreen from '@/screens/dashboard/MainDashboardScreen';
import ProfileScreen from '@/screens/profile/ProfileScreen';
import ChangeMPINScreen from '@/screens/profile/ChangeMPINScreen';
import DepartmentScreen from '@/screens/dashboard/DepartmentScreen';
import CustomDrawerContent from '@/components/CustomDrawerContent';

const Stack = createNativeStackNavigator();
const Drawer = createDrawerNavigator();

// Create a navigation ref
export const navigationRef = React.createRef<NavigationContainerRef<any>>();

// Define all screen names as constants to avoid typos
const SCREENS = {
  LOGIN_INITIATE: 'LoginInitiate',
  SEND_OTP: 'SendOTP',
  VERIFY_OTP: 'VerifyOTP',
  SETUP_MPIN: 'SetupMPIN',
  VERIFY_MPIN: 'VerifyMPIN',
  FORGOT_MPIN: 'ForgotMPIN',
  MAIN_DASHBOARD: 'MainDashboard',
  PROFILE: 'Profile',
  CHANGE_MPIN: 'ChangeMPIN',
  DEPARTMENT: 'Department',
  MAIN_DRAWER: 'MainDrawer',
};

// Drawer Navigator Component
const MainDrawer = () => {
  return (
    <Drawer.Navigator
      drawerContent={(props) => <CustomDrawerContent props={props} />}
      screenOptions={{
        headerShown: false,
        drawerType: 'slide',
        overlayColor: 'transparent',

        drawerStyle: {
          width: 300,
          backgroundColor: 'transparent',
        },

        drawerActiveTintColor: '#C084FC',
        drawerInactiveTintColor: '#64748B',

        // ✅ NO negative margins
        drawerLabelStyle: {
          fontSize: 14,
          fontWeight: '500',
          marginLeft: 8,
        },

        drawerItemStyle: {
          borderRadius: 8,
          marginHorizontal: 8,
          marginVertical: 4,
          paddingHorizontal: 12,
        },
      }}
    >
      {/* ✅ REQUIRED CHILDREN */}

      <Drawer.Screen
        name={SCREENS.MAIN_DASHBOARD}
        component={MainDashboardScreen}
        options={{
          drawerLabel: 'Dashboard',
          drawerIcon: ({ color, size }) => (
            <Icon name="view-dashboard" size={size} color={color} />
          ),
        }}
      />

      <Drawer.Screen
        name={SCREENS.PROFILE}
        component={ProfileScreen}
        options={{
          drawerLabel: 'Profile',
          drawerIcon: ({ color, size }) => (
            <Icon name="account" size={size} color={color} />
          ),
        }}
      />

      <Drawer.Screen
        name={SCREENS.CHANGE_MPIN}
        component={ChangeMPINScreen}
        options={{
          drawerLabel: 'Change MPIN',
          drawerIcon: ({ color, size }) => (
            <Icon name="key-change" size={size} color={color} />
          ),
        }}
      />

      <Drawer.Screen
        name={SCREENS.DEPARTMENT}
        component={DepartmentScreen}
        options={{
          drawerLabel: 'Department Details',
          drawerIcon: ({ color, size }) => (
            <Icon name="office-building" size={size} color={color} />
          ),
        }}
      />
    </Drawer.Navigator>
  );
};


// Main App Navigator
const AppNavigator = () => {
  const { isAuthenticated, isLoading, isInitializing, phoneNumber } = useAuth();

  console.log('🔄 AppNavigator State:', {
    isAuthenticated,
    isLoading,
    isInitializing,
    phoneNumber,
    hasPhone: !!phoneNumber
  });

  // Show loading screen with proper component
  if (isLoading || isInitializing) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#FFFFFF' }}>
        <ActivityIndicator size="large" color="#C084FC" />
      </View>
    );
  }

  // Determine initial route based on authentication state
  let initialRouteName = SCREENS.LOGIN_INITIATE;
  
  if (isAuthenticated) {
    initialRouteName = SCREENS.MAIN_DRAWER;
  } else if (phoneNumber) {
    // If we have phone number but not authenticated, go to MPIN verification
    initialRouteName = SCREENS.VERIFY_MPIN;
  }

  console.log('📍 Initial Route:', initialRouteName);

  return (
    <Stack.Navigator 
      screenOptions={{ 
        headerShown: false,
        animation: 'slide_from_right',
      }}
      initialRouteName={initialRouteName}
    >
      {/* Auth Screens */}
      <Stack.Screen 
        name={SCREENS.LOGIN_INITIATE} 
        component={LoginInitiateScreen}
        options={{
          gestureEnabled: false,
        }}
      />
      <Stack.Screen 
        name={SCREENS.SEND_OTP} 
        component={SendOTPScreen}
        options={{
          gestureEnabled: false,
        }}
      />
      <Stack.Screen 
        name={SCREENS.VERIFY_OTP} 
        component={VerifyOTPScreen}
        options={{
          gestureEnabled: false,
        }}
      />
      <Stack.Screen 
        name={SCREENS.SETUP_MPIN} 
        component={SetupMPINScreen}
        options={{
          gestureEnabled: false,
        }}
      />
      <Stack.Screen 
        name={SCREENS.VERIFY_MPIN} 
        component={VerifyMPINScreen}
        options={{
          gestureEnabled: false,
        }}
      />
      <Stack.Screen 
        name={SCREENS.FORGOT_MPIN} 
        component={ForgotMPINScreen}
        options={{
          gestureEnabled: false,
        }}
      />
      
      {/* Main App Screens */}
      <Stack.Screen 
        name={SCREENS.MAIN_DRAWER} 
        component={MainDrawer}
        options={{
          gestureEnabled: false,
        }}
      />
    </Stack.Navigator>
  );
};

export default AppNavigator;
========================================
FILE: src/screens/AnimatedPrayantraLogo.tsx
========================================

import React, { useEffect, useRef } from 'react';
import { Animated, Easing, View } from 'react-native';
import Svg, {
  Path,
  Circle,
  Defs,
  LinearGradient,
  RadialGradient,
  Stop,
} from 'react-native-svg';

interface Props {
  size?: number;
}

const AnimatedPrayantraLogo: React.FC<Props> = ({ size = 180 }) => {
  const blinkAnim = useRef(new Animated.Value(1)).current;

  useEffect(() => {
    Animated.sequence([
      Animated.delay(800),
      Animated.timing(blinkAnim, {
        toValue: 0.08,
        duration: 120,
        easing: Easing.linear,
        useNativeDriver: true,
      }),
      Animated.timing(blinkAnim, {
        toValue: 1,
        duration: 140,
        easing: Easing.linear,
        useNativeDriver: true,
      }),
    ]).start();
  }, []);

  return (
    <View style={{ width: size, height: size }}>
      <Svg width="100%" height="100%" viewBox="0 0 200 200">

        <Defs>
          <LinearGradient id="mainGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <Stop offset="0%" stopColor="#4F7CFF" />
            <Stop offset="100%" stopColor="#5FE0C7" />
          </LinearGradient>

          <RadialGradient id="eyeGlow" cx="50%" cy="50%" r="50%">
            <Stop offset="0%" stopColor="#FFFFFF" />
            <Stop offset="100%" stopColor="#EAF0FF" />
          </RadialGradient>
        </Defs>

        {/* Outer Ring */}
        <Circle
          cx="100"
          cy="100"
          r="88"
          stroke="url(#mainGradient)"
          strokeWidth="10"
        />

        {/* Animated Eye Container */}
        <Animated.View
          style={{
            position: 'absolute',
            width: size,
            height: size,
            transform: [{ scaleY: blinkAnim }],
          }}
        >
          <Svg width="100%" height="100%" viewBox="0 0 200 200">
            <Path
              d="M70 100 C82 82, 118 82, 130 100
                 C118 118, 82 118, 70 100Z"
              fill="url(#eyeGlow)"
              stroke="url(#mainGradient)"
              strokeWidth={3}
            />

            {/* Pupil */}
            <Circle cx="100" cy="100" r="10" fill="url(#mainGradient)" />

            {/* Reflection */}
            <Circle cx="96" cy="96" r="3" fill="#FFFFFF" />
          </Svg>
        </Animated.View>

      </Svg>
    </View>
  );
};

export default AnimatedPrayantraLogo;

========================================
FILE: src/screens/SplashScreen.tsx
========================================

import React, { useEffect, useRef } from 'react';
import { 
  View, 
  StyleSheet, 
  Animated, 
  Easing, 
  Dimensions,
  Text 
} from 'react-native';
import Svg, {
  Path,
  Defs,
  LinearGradient,
  RadialGradient,
  Stop,
  Circle,
  G,
} from 'react-native-svg';

const { width, height } = Dimensions.get('window');

// Main color from your Expo config - ONLY FOR BACKGROUND
const SPLASH_BACKGROUND_COLOR = '#C084FC';
// Original logo colors (keeping these from your original design)
const LOGO_GRADIENT_START = '#4A00E0';
const LOGO_GRADIENT_MID = '#8E2DE2';
const LOGO_GRADIENT_END = '#00B4DB';
const LIGHT_BLUE = '#00B4DB';
const WHITE_GLOW = '#FFFFFF';

const SplashScreen: React.FC = () => {
  const rotateAnim = useRef(new Animated.Value(0)).current;
  const scaleAnim = useRef(new Animated.Value(0.8)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const floatAnim = useRef(new Animated.Value(0)).current;
  const ring1Anim = useRef(new Animated.Value(0)).current;
  const ring2Anim = useRef(new Animated.Value(0)).current;
  const dashAnim = useRef(new Animated.Value(0)).current;
  const particleAnims = useRef([...Array(6)].map(() => new Animated.Value(0))).current;
  const cubeAnim = useRef(new Animated.Value(0)).current;
  const textFadeAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    // Start all animations
    Animated.parallel([
      // Rotating animation
      Animated.loop(
        Animated.timing(rotateAnim, {
          toValue: 1,
          duration: 20000,
          easing: Easing.linear,
          useNativeDriver: true,
        })
      ),
      
      // Pulsing scale animation
      Animated.loop(
        Animated.sequence([
          Animated.timing(scaleAnim, {
            toValue: 1.1,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(scaleAnim, {
            toValue: 0.9,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ])
      ),
      
      // Fade in animation
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 1000,
        useNativeDriver: true,
      }),
      
      // Floating animation
      Animated.loop(
        Animated.sequence([
          Animated.timing(floatAnim, {
            toValue: 1,
            duration: 3000,
            easing: Easing.inOut(Easing.sin),
            useNativeDriver: true,
          }),
          Animated.timing(floatAnim, {
            toValue: 0,
            duration: 3000,
            easing: Easing.inOut(Easing.sin),
            useNativeDriver: true,
          }),
        ])
      ),
      
      // Text fade in animation (delayed)
      Animated.sequence([
        Animated.delay(500),
        Animated.timing(textFadeAnim, {
          toValue: 1,
          duration: 1000,
          useNativeDriver: true,
        }),
      ]),
      
      // Ring animations
      Animated.loop(
        Animated.sequence([
          Animated.timing(ring1Anim, {
            toValue: 1,
            duration: 2000,
            easing: Easing.inOut(Easing.sin),
            useNativeDriver: false,
          }),
          Animated.timing(ring1Anim, {
            toValue: 0,
            duration: 2000,
            easing: Easing.inOut(Easing.sin),
            useNativeDriver: false,
          }),
        ])
      ),
      
      Animated.loop(
        Animated.sequence([
          Animated.timing(ring2Anim, {
            toValue: 1,
            duration: 1500,
            easing: Easing.inOut(Easing.sin),
            useNativeDriver: false,
          }),
          Animated.timing(ring2Anim, {
            toValue: 0,
            duration: 1500,
            easing: Easing.inOut(Easing.sin),
            useNativeDriver: false,
          }),
        ])
      ),
      
      // Dash animation
      Animated.loop(
        Animated.timing(dashAnim, {
          toValue: 1,
          duration: 1500,
          easing: Easing.linear,
          useNativeDriver: false,
        })
      ),
      
      // Cube rotation
      Animated.loop(
        Animated.timing(cubeAnim, {
          toValue: 1,
          duration: 10000,
          easing: Easing.linear,
          useNativeDriver: false,
        })
      ),
      
      // Particle animations (around logo center only)
      ...particleAnims.map((anim, index) => 
        Animated.loop(
          Animated.sequence([
            Animated.timing(anim, {
              toValue: 1,
              duration: 1000 + index * 200,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
            Animated.timing(anim, {
              toValue: 0,
              duration: 1000 + index * 200,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
          ])
        )
      ),
    ]).start();
  }, []);

  const rotate = rotateAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });

  const floatY = floatAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -20],
  });

  const opacity = fadeAnim;
  const textOpacity = textFadeAnim;

  const ring1Radius = ring1Anim.interpolate({
    inputRange: [0, 1],
    outputRange: [85, 95],
  });

  const ring2Radius = ring2Anim.interpolate({
    inputRange: [0, 1],
    outputRange: [70, 75],
  });

  const dashOffset = dashAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 20],
  });

  const dashOffset2 = dashAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [20, 0],
  });

  const cubeRotate = cubeAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0 100 100', '45 100 100'],
  });

  return (
    <View style={[styles.container, { backgroundColor: SPLASH_BACKGROUND_COLOR }]}>
      {/* Animated background gradient - using your purple color */}
      <Animated.View style={[styles.background, { opacity }]}>
        <Svg width={width} height={height} style={styles.backgroundSvg}>
          <Defs>
            <LinearGradient id="bgGrad" x1="0%" y1="0%" x2="100%" y2="100%">
              <Stop offset="0%" stopColor="#9D4EDD" />
              <Stop offset="50%" stopColor={SPLASH_BACKGROUND_COLOR} />
              <Stop offset="100%" stopColor="#E0AAFF" />
            </LinearGradient>
          </Defs>
          <Path d={`M0,0 H${width} V${height} H0 Z`} fill="url(#bgGrad)" />
        </Svg>
      </Animated.View>

      {/* Main animated logo - KEEPING ORIGINAL BLUE COLORS */}
      <Animated.View
        style={[
          styles.logoContainer,
          {
            transform: [
              { rotate },
              { scale: scaleAnim },
              { translateY: floatY },
            ],
            opacity,
          },
        ]}
      >
        <Svg width={200} height={200} viewBox="0 0 200 200">
          <Defs>
            {/* ORIGINAL LOGO GRADIENTS */}
            <LinearGradient id="splashGrad1" x1="0%" y1="0%" x2="100%" y2="100%">
              <Stop offset="0%" stopColor={LOGO_GRADIENT_START} stopOpacity="1" />
              <Stop offset="50%" stopColor={LOGO_GRADIENT_MID} stopOpacity="1" />
              <Stop offset="100%" stopColor={LOGO_GRADIENT_END} stopOpacity="1" />
            </LinearGradient>
            
            <LinearGradient id="splashGrad2" x1="0%" y1="0%" x2="0%" y2="100%">
              <Stop offset="0%" stopColor={LOGO_GRADIENT_END} stopOpacity="0.9" />
              <Stop offset="100%" stopColor="#0083B0" stopOpacity="0.9" />
            </LinearGradient>
            
            <RadialGradient id="centerGlow" cx="50%" cy="50%" r="50%">
              <Stop offset="0%" stopColor="#FFFFFF" stopOpacity="0.3" />
              <Stop offset="100%" stopColor="#FFFFFF" stopOpacity="0" />
            </RadialGradient>
          </Defs>
          
          {/* Animated outer rings */}
          <G>
            <AnimatedCircle 
              cx="100"
              cy="100"
              r={ring1Radius}
              fill="none"
              stroke="url(#splashGrad1)"
              strokeWidth="2"
            />
            
            <AnimatedCircle 
              cx="100"
              cy="100"
              r={ring2Radius}
              fill="none"
              stroke="rgba(142, 45, 226, 0.4)"
              strokeWidth="1.5"
            />
          </G>
          
          {/* Central core with animations */}
          <G>
            <Circle cx="100" cy="100" r="30" fill="url(#splashGrad2)" />
            
            {/* Neural network paths */}
            <AnimatedPath
              d="M70,100 Q100,70 130,100 Q100,130 70,100"
              fill="none"
              stroke="rgba(255,255,255,0.5)"
              strokeWidth="1.5"
              strokeDasharray="5,5"
              strokeDashoffset={dashOffset}
            />
            
            <AnimatedPath
              d="M100,70 Q130,100 100,130 Q70,100 100,70"
              fill="none"
              stroke="rgba(255,255,255,0.5)"
              strokeWidth="1.5"
              strokeDasharray="5,5"
              strokeDashoffset={dashOffset2}
            />
            
            {/* Animated particles around center - ORIGINAL BLUE COLOR */}
            {[...Array(6)].map((_, i) => {
              const angle = (i * 60) * Math.PI / 180;
              const radius = 50;
              const x = 100 + radius * Math.cos(angle);
              const y = 100 + radius * Math.sin(angle);
              
              return (
                <AnimatedCircle
                  key={i}
                  cx={x}
                  cy={y}
                  r={particleAnims[i].interpolate({
                    inputRange: [0, 1],
                    outputRange: [4, 6],
                  })}
                  fill={LOGO_GRADIENT_END}
                  opacity={particleAnims[i].interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.7, 1],
                  })}
                />
              );
            })}
            
            {/* Center tech element with rotation */}
            <AnimatedPath
              d="M90,90 L110,90 L110,110 L90,110 Z"
              fill="none"
              stroke="white"
              strokeWidth="2"
              strokeLinecap="round"
              rotation={cubeRotate}
            />
            
            {/* Center glow */}
            <Circle cx="100" cy="100" r="35" fill="url(#centerGlow)" />
          </G>
        </Svg>
      </Animated.View>

      {/* App name with fade-in animation and box styling */}
      <Animated.View style={[styles.textContainer, { opacity: textOpacity }]}>
        <Text style={styles.appName}>PRAYANTRA</Text>
        <Text style={styles.tagline}>Powering Enterprises</Text>
        <Text style={styles.subtitle}>Integrated · Efficient · Future-ready</Text>
      </Animated.View>

      {/* Loading dots - ORIGINAL BLUE COLOR */}
      <Animated.View style={[styles.loadingContainer, { opacity }]}>
        {[...Array(3)].map((_, i) => (
          <Animated.View
            key={i}
            style={[
              styles.loadingDot,
              {
                backgroundColor: LIGHT_BLUE,
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 1],
                }),
              },
            ]}
          >
            <Animated.View
              style={[
                styles.dotInner,
                {
                  transform: [
                    {
                      scale: fadeAnim.interpolate({
                        inputRange: [0, 0.5, 1],
                        outputRange: [0, 1, 0],
                      }),
                    },
                  ],
                },
              ]}
            />
          </Animated.View>
        ))}
      </Animated.View>
    </View>
  );
};

// Helper components for animated SVG elements
const AnimatedCircle = ({ cx, cy, r, fill, stroke, strokeWidth, opacity, ...props }: any) => {
  return (
    <Circle
      cx={typeof cx === 'string' ? cx : cx?.__getValue?.() ?? cx}
      cy={typeof cy === 'string' ? cy : cy?.__getValue?.() ?? cy}
      r={typeof r === 'string' ? r : r?.__getValue?.() ?? r}
      fill={fill}
      stroke={stroke}
      strokeWidth={strokeWidth}
      opacity={typeof opacity === 'string' ? opacity : opacity?.__getValue?.() ?? opacity}
      {...props}
    />
  );
};

const AnimatedPath = ({ d, fill, stroke, strokeWidth, strokeDasharray, strokeDashoffset, rotation, ...props }: any) => {
  const transform = rotation ? `rotate(${typeof rotation === 'string' ? rotation : rotation?.__getValue?.() ?? rotation})` : undefined;
  
  return (
    <Path
      d={d}
      fill={fill}
      stroke={stroke}
      strokeWidth={strokeWidth}
      strokeDasharray={strokeDasharray}
      strokeDashoffset={typeof strokeDashoffset === 'string' ? strokeDashoffset : strokeDashoffset?.__getValue?.() ?? strokeDashoffset}
      transform={transform}
      {...props}
    />
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: SPLASH_BACKGROUND_COLOR, // Your Expo color
    alignItems: 'center',
    justifyContent: 'center',
  },
  background: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  },
  backgroundSvg: {
    position: 'absolute',
  },
  logoContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 40,
  },
  textContainer: {
    alignItems: 'center',
    marginTop: 30,
    paddingHorizontal: 30,
    paddingVertical: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.15)', // Semi-transparent white
    borderRadius: 20,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.3)',
  },
  appName: {
    fontSize: 42,
    fontWeight: 'bold',
    color: 'white',
    letterSpacing: 3,
    marginBottom: 10,
    textShadowColor: 'rgba(74, 0, 224, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 15,
  },
  tagline: {
    fontSize: 22,
    color: LIGHT_BLUE, // Original blue color
    fontWeight: '600',
    marginBottom: 6,
    letterSpacing: 1,
    textShadowColor: 'rgba(0, 180, 219, 0.3)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 10,
  },
  subtitle: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.95)',
    fontWeight: '500',
    letterSpacing: 0.5,
    textAlign: 'center',
    lineHeight: 20,
  },
  loadingContainer: {
    flexDirection: 'row',
    marginTop: 50,
    alignItems: 'center',
  },
  loadingDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
    marginHorizontal: 6,
    backgroundColor: LIGHT_BLUE, // Original blue color
    shadowColor: LIGHT_BLUE,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.8,
    shadowRadius: 5,
    elevation: 5,
    overflow: 'hidden',
  },
  dotInner: {
    width: '100%',
    height: '100%',
    backgroundColor: 'white',
    borderRadius: 6,
  },
});

export default SplashScreen;
========================================
FILE: src/screens/auth/ForgotMPINScreen.tsx
========================================

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { useNavigation, NavigationProp, RouteProp, useRoute } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { api } from '@/services/api';
import { useToast } from '@/components/Toast';
import PrayantraLogo from '@/components/PrayantraLogo';
import OTPInput from '@/components/OTPInput';
import MPINInput from '@/components/MPINInput';
import { getFormattedPhoneNumber } from '@/services/storage';

// Define navigation types
type RootStackParamList = {
  LoginInitiate: undefined;
  SendOTP: { phoneNumber: string; adminId?: string };
  VerifyOTP: { phoneNumber: string; adminId?: string };
  SetupMPIN: { phoneNumber: string; adminId: string };
  VerifyMPIN: { phoneNumber?: string; adminId?: string };
  ForgotMPIN: { phoneNumber?: string };
  MainDrawer: undefined;
};

type ForgotMPINScreenRouteProp = RouteProp<RootStackParamList, 'ForgotMPIN'>;

const ForgotMPINScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const route = useRoute<ForgotMPINScreenRouteProp>();
  const params = route.params;
  
  const { showToast } = useToast();

  const [phoneNumber, setPhoneNumber] = useState('');
  const [step, setStep] = useState(1); // 1: Request OTP, 2: Verify OTP, 3: Setup new MPIN
  const [otp, setOtp] = useState('');
  const [mpin, setMpin] = useState('');
  const [confirmMpin, setConfirmMpin] = useState('');
  const [timer, setTimer] = useState(60);
  const [canResend, setCanResend] = useState(false);
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    const loadPhoneNumber = async () => {
      if (params?.phoneNumber) {
        setPhoneNumber(params.phoneNumber);
      } else {
        const storedPhone = await getFormattedPhoneNumber();
        if (storedPhone) {
          setPhoneNumber(storedPhone);
        }
      }
    };
    loadPhoneNumber();
  }, [params?.phoneNumber]);

  useEffect(() => {
    if (step === 1) {
      startTimer();
    }
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, [step]);

  const startTimer = () => {
    setCanResend(false);
    setTimer(60);
    
    if (timerRef.current) {
      clearInterval(timerRef.current);
    }

    timerRef.current = setInterval(() => {
      setTimer((prev) => {
        if (prev <= 1) {
          setCanResend(true);
          if (timerRef.current) {
            clearInterval(timerRef.current);
          }
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
  };

  const forgotMPINMutation = useMutation({
    mutationFn: () => api.forgotMPIN(phoneNumber),
    onSuccess: () => {
      showToast('success', 'OTP sent successfully for MPIN reset');
      setStep(2);
      startTimer();
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.message || 'Failed to send OTP';
      showToast('error', errorMessage);
    },
    onSettled: () => {
      setIsLoading(false);
    },
  });

  const verifyForgotMPINMutation = useMutation({
    mutationFn: (data: { otpCode: string; newMpin: string }) => 
      api.verifyForgotMPIN(phoneNumber, data.otpCode, data.newMpin),
    onSuccess: () => {
      showToast('success', 'MPIN reset successful. Please login with your new MPIN.');
      navigation.navigate('VerifyMPIN', { phoneNumber });
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.message || 'Failed to reset MPIN';
      setError(errorMessage);
      showToast('error', errorMessage);
    },
    onSettled: () => {
      setIsLoading(false);
    },
  });

  const handleRequestOTP = () => {
    if (!phoneNumber) {
      showToast('error', 'Please enter your phone number');
      return;
    }

    setIsLoading(true);
    forgotMPINMutation.mutate();
  };

  const handleVerifyOTP = () => {
    if (otp.length !== 6) {
      showToast('error', 'Please enter 6-digit OTP');
      return;
    }
    setStep(3);
  };

  const handleMPINComplete = (enteredMpin: string) => {
    if (mpin === '') {
      // First MPIN entry
      if (isWeakMpin(enteredMpin)) {
        setError('MPIN is too weak. Please choose a stronger MPIN.');
        return;
      }
      setMpin(enteredMpin);
      setError('');
    } else {
      // Confirm MPIN
      if (enteredMpin === mpin) {
        setIsLoading(true);
        verifyForgotMPINMutation.mutate({
          otpCode: otp,
          newMpin: enteredMpin
        });
      } else {
        setError('MPIN does not match. Please try again.');
        setMpin('');
      }
    }
  };

  const handleResendOTP = () => {
    if (!canResend && timer > 0) {
      showToast('info', `Please wait ${timer} seconds before resending`);
      return;
    }
    setIsLoading(true);
    forgotMPINMutation.mutate();
  };

  const isWeakMpin = (mpin: string) => {
    const weakPatterns = [
      '111111', '222222', '333333', '444444', '555555',
      '666666', '777777', '888888', '999999', '000000',
      '123456', '654321', '121212', '123123', '112233'
    ];
    return weakPatterns.includes(mpin) || 
           mpin.split('').every((digit, i, arr) => digit === arr[0]);
  };

  const renderStep = () => {
    switch (step) {
      case 1:
        return (
          <>
            <Text style={styles.title}>Forgot MPIN</Text>
            <Text style={styles.subtitle}>
              Enter your registered phone number to reset MPIN
            </Text>

            <View style={styles.phoneContainer}>
              <Text style={styles.phoneLabel}>Phone Number</Text>
              <Text style={styles.phoneNumber}>{phoneNumber || 'Not set'}</Text>
            </View>

            <Text style={styles.instruction}>
              We'll send an OTP to verify your identity and reset your MPIN.
            </Text>

            <TouchableOpacity
              style={[styles.button, isLoading && styles.buttonDisabled]}
              onPress={handleRequestOTP}
              disabled={isLoading || !phoneNumber}
            >
              <Text style={styles.buttonText}>
                {isLoading ? 'Sending OTP...' : 'Send OTP'}
              </Text>
            </TouchableOpacity>
          </>
        );

      case 2:
        return (
          <>
            <Text style={styles.title}>Verify OTP</Text>
            <Text style={styles.subtitle}>
              Enter the 6-digit OTP sent to {phoneNumber}
            </Text>

            <View style={styles.timerContainer}>
              <Text style={styles.timerText}>
                OTP expires in: {timer}s
              </Text>
            </View>

            <OTPInput
              length={6}
              onComplete={setOtp}
              error={!!error}
              disabled={isLoading}
              autoFocus={true}
            />

            <TouchableOpacity
              style={[styles.button, (isLoading || otp.length !== 6) && styles.buttonDisabled]}
              onPress={handleVerifyOTP}
              disabled={isLoading || otp.length !== 6}
            >
              <Text style={styles.buttonText}>
                {isLoading ? 'Verifying...' : 'Verify OTP'}
              </Text>
            </TouchableOpacity>

            <View style={styles.resendContainer}>
              <Text style={styles.resendText}>Didn't receive OTP?</Text>
              <TouchableOpacity
                onPress={handleResendOTP}
                disabled={!canResend || isLoading}
              >
                <Text style={[
                  styles.resendButton,
                  (!canResend || isLoading) && styles.resendButtonDisabled
                ]}>
                  {canResend ? 'Resend OTP' : `Resend in ${timer}s`}
                </Text>
              </TouchableOpacity>
            </View>
          </>
        );

      case 3:
        return (
          <>
            <Text style={styles.title}>Set New MPIN</Text>
            <Text style={styles.subtitle}>
              {mpin ? 'Confirm your new MPIN' : 'Create a new 6-digit MPIN'}
            </Text>

            <MPINInput
              onComplete={handleMPINComplete}
              error={!!error}
              disabled={isLoading}
              autoFocus={true}
            />

            {error && (
              <View style={styles.errorContainer}>
                <Text style={styles.errorText}>{error}</Text>
              </View>
            )}

            {isLoading && (
              <View style={styles.loadingContainer}>
                <Text style={styles.loadingText}>Setting up new MPIN...</Text>
              </View>
            )}

            <View style={styles.guidelines}>
              <Text style={styles.guidelinesTitle}>MPIN Guidelines:</Text>
              <Text style={styles.guideline}>• Must be 6 digits</Text>
              <Text style={styles.guideline}>• Avoid simple patterns</Text>
              <Text style={styles.guideline}>• Don't use repeated digits</Text>
              <Text style={styles.guideline}>• Choose something memorable</Text>
            </View>
          </>
        );
    }
  };

  const handleBack = () => {
    if (step === 1) {
      navigation.goBack();
    } else if (step === 2) {
      setStep(1);
      setOtp('');
      setError('');
    } else if (step === 3) {
      setStep(2);
      setMpin('');
      setConfirmMpin('');
      setError('');
    }
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.logoContainer}>
          <PrayantraLogo size={100} />
          <Text style={styles.appName}>Prayantra</Text>
        </View>

        <View style={styles.formContainer}>
          <View style={styles.stepIndicator}>
            <View style={[styles.step, step >= 1 && styles.activeStep]}>
              <Text style={[styles.stepText, step >= 1 && styles.activeStepText]}>1</Text>
            </View>
            <View style={styles.stepLine} />
            <View style={[styles.step, step >= 2 && styles.activeStep]}>
              <Text style={[styles.stepText, step >= 2 && styles.activeStepText]}>2</Text>
            </View>
            <View style={styles.stepLine} />
            <View style={[styles.step, step >= 3 && styles.activeStep]}>
              <Text style={[styles.stepText, step >= 3 && styles.activeStepText]}>3</Text>
            </View>
          </View>

          {renderStep()}

          <TouchableOpacity
            style={styles.backButton}
            onPress={handleBack}
            disabled={isLoading}
          >
            <Text style={styles.backButtonText}>
              ← {step === 1 ? 'Back to Login' : 'Back'}
            </Text>
          </TouchableOpacity>
        </View>

        <View style={styles.securityInfo}>
          <Text style={styles.securityTitle}>Security Information:</Text>
          <Text style={styles.securityText}>
            • MPIN reset requires OTP verification
            {'\n'}• OTP is valid for 10 minutes only
            {'\n'}• Your old MPIN will be permanently deleted
            {'\n'}• Contact admin if you face issues
          </Text>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 40,
    paddingBottom: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  appName: {
    fontSize: 24,
    fontWeight: '700',
    color: '#C084FC', // Purple
    marginTop: 12,
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  stepIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 32,
  },
  step: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#E2E8F0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  activeStep: {
    backgroundColor: '#C084FC', // Purple
  },
  stepText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#64748B',
  },
  activeStepText: {
    color: '#FFFFFF',
  },
  stepLine: {
    width: 30,
    height: 2,
    backgroundColor: '#E2E8F0',
    marginHorizontal: 4,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 24,
    textAlign: 'center',
    lineHeight: 20,
  },
  phoneContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 8,
    padding: 16,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#E2E8F0',
    alignItems: 'center',
  },
  phoneLabel: {
    fontSize: 12,
    color: '#64748B',
    marginBottom: 4,
  },
  phoneNumber: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1E293B',
  },
  instruction: {
    fontSize: 13,
    color: '#64748B',
    textAlign: 'center',
    marginBottom: 24,
    lineHeight: 18,
  },
  timerContainer: {
    backgroundColor: '#FEF3C7',
    padding: 12,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#FDE68A',
  },
  timerText: {
    color: '#D97706',
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
  },
  button: {
    backgroundColor: '#C084FC', // Purple
    borderRadius: 8,
    paddingVertical: 16,
    alignItems: 'center',
    marginTop: 24,
    marginBottom: 20,
  },
  buttonDisabled: {
    backgroundColor: '#D8B4FE', // Light purple
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  resendContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 8,
  },
  resendText: {
    fontSize: 14,
    color: '#64748B',
    marginRight: 4,
  },
  resendButton: {
    fontSize: 14,
    color: '#C084FC', // Purple
    fontWeight: '600',
  },
  resendButtonDisabled: {
    color: '#D8B4FE', // Light purple
  },
  errorContainer: {
    backgroundColor: '#FEF2F2',
    padding: 12,
    borderRadius: 8,
    marginTop: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#FECACA',
  },
  errorText: {
    color: '#DC2626',
    fontSize: 13,
    textAlign: 'center',
  },
  loadingContainer: {
    marginTop: 16,
    marginBottom: 16,
  },
  loadingText: {
    color: '#64748B',
    fontSize: 14,
    textAlign: 'center',
  },
  guidelines: {
    backgroundColor: '#FAF5FF', // Light purple
    padding: 16,
    borderRadius: 8,
    marginTop: 24,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  guidelinesTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#C084FC', // Purple
    marginBottom: 8,
  },
  guideline: {
    fontSize: 13,
    color: '#6B21A8',
    marginBottom: 4,
    lineHeight: 18,
  },
  backButton: {
    alignItems: 'center',
    paddingVertical: 12,
    marginTop: 16,
  },
  backButtonText: {
    color: '#C084FC', // Purple
    fontSize: 14,
    fontWeight: '500',
  },
  securityInfo: {
    marginTop: 32,
    backgroundColor: '#FAF5FF', // Light purple
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  securityTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#C084FC', // Purple
    marginBottom: 8,
  },
  securityText: {
    fontSize: 12,
    color: '#6B21A8',
    lineHeight: 18,
  },
});

export default ForgotMPINScreen;
========================================
FILE: src/screens/auth/LoginInitiateScreen.tsx
========================================

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
  Modal,
  FlatList,
  Keyboard,
  TouchableWithoutFeedback,
} from 'react-native';
import { useNavigation, NavigationProp } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';
import { api } from '@/services/api';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';
import PrayantraLogo from '@/components/PrayantraLogo';

// Define navigation types
type RootStackParamList = {
  LoginInitiate: undefined;
  SendOTP: { phoneNumber: string; adminId?: string };
  VerifyOTP: { phoneNumber: string; adminId?: string };
  SetupMPIN: { phoneNumber: string; adminId: string };
  VerifyMPIN: { phoneNumber?: string; adminId?: string };
  ForgotMPIN: { phoneNumber?: string };
  MainDrawer: undefined;
};

// Define country code type
type CountryCode = {
  code: string;
  country: string;
  flag: string;
};

// Country code data
const COUNTRY_CODES: CountryCode[] = [
  { code: '+91', country: 'India', flag: '🇮🇳' },
  { code: '+1', country: 'USA', flag: '🇺🇸' },
  { code: '+44', country: 'UK', flag: '🇬🇧' },
  { code: '+971', country: 'UAE', flag: '🇦🇪' },
  { code: '+65', country: 'Singapore', flag: '🇸🇬' },
  { code: '+60', country: 'Malaysia', flag: '🇲🇾' },
  { code: '+966', country: 'Saudi Arabia', flag: '🇸🇦' },
  { code: '+92', country: 'Pakistan', flag: '🇵🇰' },
  { code: '+880', country: 'Bangladesh', flag: '🇧🇩' },
  { code: '+94', country: 'Sri Lanka', flag: '🇱🇰' },
  { code: '+977', country: 'Nepal', flag: '🇳🇵' },
  { code: '+95', country: 'Myanmar', flag: '🇲🇲' },
  { code: '+84', country: 'Vietnam', flag: '🇻🇳' },
  { code: '+62', country: 'Indonesia', flag: '🇮🇩' },
  { code: '+63', country: 'Philippines', flag: '🇵🇭' },
  { code: '+66', country: 'Thailand', flag: '🇹🇭' },
  { code: '+81', country: 'Japan', flag: '🇯🇵' },
  { code: '+82', country: 'South Korea', flag: '🇰🇷' },
  { code: '+86', country: 'China', flag: '🇨🇳' },
  { code: '+33', country: 'France', flag: '🇫🇷' },
  { code: '+49', country: 'Germany', flag: '🇩🇪' },
  { code: '+39', country: 'Italy', flag: '🇮🇹' },
  { code: '+34', country: 'Spain', flag: '🇪🇸' },
  { code: '+61', country: 'Australia', flag: '🇦🇺' },
  { code: '+64', country: 'New Zealand', flag: '🇳🇿' },
  { code: '+27', country: 'South Africa', flag: '🇿🇦' },
  { code: '+55', country: 'Brazil', flag: '🇧🇷' },
  { code: '+52', country: 'Mexico', flag: '🇲🇽' },
  { code: '+7', country: 'Russia', flag: '🇷🇺' },
];

const LoginInitiateScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const { login } = useAuth();
  const { showToast } = useToast();
  const [isLoading, setIsLoading] = useState(false);
  const [phoneNumber, setPhoneNumber] = useState('');
  const [selectedCountry, setSelectedCountry] = useState<CountryCode>(COUNTRY_CODES[0]); // Default to India
  const [showCountryModal, setShowCountryModal] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [keyboardVisible, setKeyboardVisible] = useState(false);

  // Filter countries based on search query
  const filteredCountries = COUNTRY_CODES.filter(country => 
    country.country.toLowerCase().includes(searchQuery.toLowerCase()) ||
    country.code.toLowerCase().includes(searchQuery.toLowerCase())
  );

  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      () => {
        setKeyboardVisible(true);
      }
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setKeyboardVisible(false);
      }
    );

    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  const dismissKeyboard = () => {
    Keyboard.dismiss();
  };

  const formatPhoneNumber = (input: string) => {
    // Remove all non-digit characters
    const cleaned = input.replace(/\D/g, '');
    
    // Format based on country code
    if (selectedCountry.code === '+1') {
      // US format: (XXX) XXX-XXXX
      const match = cleaned.match(/^(\d{0,3})(\d{0,3})(\d{0,4})$/);
      if (match) {
        const part1 = match[1];
        const part2 = match[2];
        const part3 = match[3];
        
        if (part2 && part3) {
          return `(${part1}) ${part2}-${part3}`;
        } else if (part2) {
          return `(${part1}) ${part2}`;
        } else if (part1) {
          return `(${part1}`;
        }
      }
    } else if (selectedCountry.code === '+44') {
      // UK format: XXXX XXX XXX
      const match = cleaned.match(/^(\d{0,4})(\d{0,3})(\d{0,3})$/);
      if (match) {
        const part1 = match[1];
        const part2 = match[2];
        const part3 = match[3];
        
        if (part2 && part3) {
          return `${part1} ${part2} ${part3}`;
        } else if (part2) {
          return `${part1} ${part2}`;
        } else if (part1) {
          return part1;
        }
      }
    } else {
      // Default format: XXX XXX XXXX for 10 digits
      const match = cleaned.match(/^(\d{0,3})(\d{0,3})(\d{0,4})$/);
      if (match) {
        const part1 = match[1];
        const part2 = match[2];
        const part3 = match[3];
        
        if (part2 && part3) {
          return `${part1} ${part2} ${part3}`;
        } else if (part2) {
          return `${part1} ${part2}`;
        } else if (part1) {
          return part1;
        }
      }
    }
    
    return cleaned;
  };

  const handlePhoneNumberChange = (text: string) => {
    const formatted = formatPhoneNumber(text);
    setPhoneNumber(formatted);
  };

  const getPhoneNumberForApi = () => {
    // Remove all non-digit characters and combine with country code
    const cleaned = phoneNumber.replace(/\D/g, '');
    return `${selectedCountry.code}${cleaned}`;
  };

  const handleLoginInitiate = async () => {
    const fullPhoneNumber = getPhoneNumberForApi();
    
    if (!phoneNumber.trim()) {
      showToast('error', 'Please enter your phone number');
      return;
    }
  
    const cleaned = phoneNumber.replace(/\D/g, '');
    const minLength = selectedCountry.code === '+91' ? 10 : 7;
    
    if (cleaned.length < minLength) {
      showToast('error', `Please enter a valid ${selectedCountry.country} phone number`);
      return;
    }
  
    setIsLoading(true);
    try {
      const response = await api.loginInitiate(fullPhoneNumber);
      const { 
        user_exists, 
        has_mpin, 
        mpin_locked, 
        device_trusted,
        user_id,
        flow_state
      } = response.data.data;
      
      console.log('✅ LoginInitiate response:', {
        user_exists,
        has_mpin,
        mpin_locked,
        device_trusted,
        user_id,
        flow_state
      });
  
      if (!user_exists) {
        showToast('error', 'Phone number not registered. Please contact your admin.');
        return;
      }
  
      if (mpin_locked) {
        Alert.alert(
          'MPIN Locked',
          'Your MPIN is locked. Please contact your administrator.',
          [{ text: 'OK' }]
        );
        return;
      }
  
      // ✅ Store phone number temporarily in state, NOT in permanent storage yet
      // We'll store it only after successful MPIN verification
      if (device_trusted && has_mpin) {
        console.log('➡️ Navigating to VerifyMPIN');
        navigation.navigate('VerifyMPIN', {
          phoneNumber: fullPhoneNumber,
          adminId: user_id
        });
      } else if (!device_trusted) {
        console.log('➡️ Navigating to SendOTP');
        navigation.navigate('SendOTP', {
          phoneNumber: fullPhoneNumber,
          adminId: user_id
        });
      } else if (!has_mpin) {
        console.log('➡️ Navigating to SetupMPIN');
        navigation.navigate('SetupMPIN', {
          phoneNumber: fullPhoneNumber,
          adminId: user_id
        });
      }
    } catch (error: any) {
      console.error('❌ LoginInitiate error:', error);
      const errorMessage = error.response?.data?.message || 'Login failed. Please try again.';
      showToast('error', errorMessage);
    } finally {
      setIsLoading(false);
    }
  };
  const renderCountryItem = ({ item }: { item: CountryCode }) => (
    <TouchableOpacity
      style={[
        styles.countryItem,
        selectedCountry.code === item.code && styles.selectedCountryItem
      ]}
      onPress={() => {
        setSelectedCountry(item);
        setShowCountryModal(false);
        setSearchQuery(''); // Clear search when selecting
      }}
    >
      <Text style={styles.countryFlag}>{item.flag}</Text>
      <View style={styles.countryInfo}>
        <Text style={[
          styles.countryName,
          selectedCountry.code === item.code && styles.selectedCountryText
        ]}>
          {item.country}
        </Text>
        <Text style={[
          styles.countryCode,
          selectedCountry.code === item.code && styles.selectedCountryText
        ]}>
          {item.code}
        </Text>
      </View>
      {selectedCountry.code === item.code && (
        <Icon name="check" size={20} color="#C084FC" />
      )}
    </TouchableOpacity>
  );

  return (
    <TouchableWithoutFeedback onPress={dismissKeyboard}>
      <View style={styles.container}>
        <KeyboardAvoidingView 
          style={styles.keyboardAvoidingView}
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          keyboardVerticalOffset={Platform.OS === 'ios' ? 60 : 0}
        >
          <ScrollView 
            contentContainerStyle={[
              styles.scrollContent,
              keyboardVisible && styles.scrollContentWithKeyboard
            ]}
            keyboardShouldPersistTaps="handled"
            showsVerticalScrollIndicator={false}
          >
            <View style={styles.logoContainer}>
              <PrayantraLogo size={keyboardVisible ? 120 : 200} />
              <Text style={styles.appName}>Prayantra</Text>
              {!keyboardVisible && (
                <Text style={styles.tagline}>Empowering Enterprises</Text>
              )}
            </View>

            <View style={styles.formContainer}>
              <Text style={styles.title}>Admin Login</Text>
              <Text style={styles.subtitle}>Enter your phone number to continue</Text>

              <View style={styles.inputContainer}>
                <Text style={styles.label}>Phone Number</Text>
                <View style={styles.phoneInputContainer}>
                  <TouchableOpacity
                    style={styles.countryCodeButton}
                    onPress={() => {
                      dismissKeyboard();
                      setShowCountryModal(true);
                    }}
                  >
                    <Text style={styles.countryCodeText}>{selectedCountry.flag} {selectedCountry.code}</Text>
                    <Icon name="chevron-down" size={16} color="#64748B" />
                  </TouchableOpacity>
                  
                  <TextInput
                    style={styles.phoneInput}
                    placeholder={
                      selectedCountry.code === '+1' ? '(123) 456-7890' :
                      selectedCountry.code === '+44' ? '1234 567 890' :
                      '98765 43210'
                    }
                    value={phoneNumber}
                    onChangeText={handlePhoneNumberChange}
                    keyboardType="phone-pad"
                    autoCapitalize="none"
                    autoCorrect={false}
                    editable={!isLoading}
                    onFocus={() => setKeyboardVisible(true)}
                    onBlur={() => setKeyboardVisible(false)}
                  />
                </View>
                
                <Text style={styles.phonePreview}>
                  Number will be sent as: {getPhoneNumberForApi() || '...'}
                </Text>
              </View>

              <TouchableOpacity
                style={[styles.button, isLoading && styles.buttonDisabled]}
                onPress={handleLoginInitiate}
                disabled={isLoading}
                activeOpacity={0.8}
              >
                <Text style={styles.buttonText}>
                  {isLoading ? 'Checking...' : 'Continue'}
                </Text>
              </TouchableOpacity>
            </View>

            {!keyboardVisible && (
              <>
                <View style={styles.infoContainer}>
                  <Text style={styles.infoTitle}>Need help?</Text>
                  <Text style={styles.infoText}>
                    • Make sure to enter your registered phone number
                    {'\n'}• Include your country code if you're logging in from abroad
                    {'\n'}• Contact your system administrator for assistance
                  </Text>
                </View>

                <View style={styles.footer}>
                  <Text style={styles.footerText}>© 2024 Prayantra. All rights reserved.</Text>
                  <Text style={styles.versionText}>Version 1.0.0</Text>
                </View>
              </>
            )}
          </ScrollView>
        </KeyboardAvoidingView>

        {/* Country Code Selection Modal */}
        <Modal
          visible={showCountryModal}
          animationType="slide"
          transparent={true}
          statusBarTranslucent={true}
          onRequestClose={() => {
            setShowCountryModal(false);
            setSearchQuery(''); // Clear search when closing
          }}
        >
          <TouchableWithoutFeedback onPress={() => setShowCountryModal(false)}>
            <View style={styles.modalOverlay}>
              <TouchableWithoutFeedback>
                <View style={styles.modalContent}>
                  <View style={styles.modalHeader}>
                    <Text style={styles.modalTitle}>Select Country Code</Text>
                    <TouchableOpacity
                      onPress={() => {
                        setShowCountryModal(false);
                        setSearchQuery('');
                      }}
                      style={styles.closeButton}
                    >
                      <Icon name="close" size={24} color="#64748B" />
                    </TouchableOpacity>
                  </View>

                  <View style={styles.searchContainer}>
                    <Icon name="magnify" size={20} color="#64748B" style={styles.searchIcon} />
                    <TextInput
                      style={styles.searchInput}
                      placeholder="Search country..."
                      placeholderTextColor="#94A3B8"
                      value={searchQuery}
                      onChangeText={setSearchQuery}
                      autoCapitalize="none"
                      autoCorrect={false}
                    />
                  </View>

                  <FlatList
                    data={filteredCountries}
                    renderItem={renderCountryItem}
                    keyExtractor={(item: CountryCode) => item.code}
                    showsVerticalScrollIndicator={false}
                    style={styles.countryList}
                    keyboardShouldPersistTaps="handled"
                  />

                  <TouchableOpacity
                    style={styles.doneButton}
                    onPress={() => {
                      setShowCountryModal(false);
                      setSearchQuery('');
                    }}
                  >
                    <Text style={styles.doneButtonText}>Done</Text>
                  </TouchableOpacity>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
      </View>
    </TouchableWithoutFeedback>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 40,
    paddingBottom: 40,
    justifyContent: 'center',
  },
  scrollContentWithKeyboard: {
    paddingTop: 20,
    justifyContent: 'flex-start',
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  appName: {
    fontSize: 32,
    fontWeight: '700',
    color: '#C084FC',
    marginTop: 16,
  },
  tagline: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
    letterSpacing: 1,
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 24,
    textAlign: 'center',
  },
  inputContainer: {
    marginBottom: 20,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
    marginBottom: 8,
  },
  phoneInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFFFFF',
    borderWidth: 1,
    borderColor: '#DDD',
    borderRadius: 8,
    overflow: 'hidden',
  },
  countryCodeButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 14,
    backgroundColor: '#F1F5F9',
    borderRightWidth: 1,
    borderRightColor: '#DDD',
    minWidth: 100,
  },
  countryCodeText: {
    fontSize: 16,
    color: '#333',
    marginRight: 8,
    fontWeight: '500',
  },
  phoneInput: {
    flex: 1,
    paddingHorizontal: 16,
    paddingVertical: 14,
    fontSize: 16,
    color: '#333',
  },
  phonePreview: {
    fontSize: 12,
    color: '#64748B',
    marginTop: 8,
    fontStyle: 'italic',
    textAlign: 'center',
  },
  button: {
    backgroundColor: '#C084FC',
    borderRadius: 8,
    paddingVertical: 16,
    alignItems: 'center',
    marginTop: 8,
  },
  buttonDisabled: {
    backgroundColor: '#D8B4FE',
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  infoContainer: {
    marginTop: 24,
    backgroundColor: '#FAF5FF',
    borderRadius: 12,
    padding: 16,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  infoTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#C084FC',
    marginBottom: 8,
  },
  infoText: {
    fontSize: 12,
    color: '#6B21A8',
    lineHeight: 18,
  },
  footer: {
    marginTop: 40,
    alignItems: 'center',
  },
  footerText: {
    fontSize: 12,
    color: '#666',
  },
  versionText: {
    fontSize: 11,
    color: '#999',
    marginTop: 4,
  },
  // Modal Styles
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#FFFFFF',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    maxHeight: '90%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1E293B',
  },
  closeButton: {
    padding: 4,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  searchIcon: {
    marginRight: 12,
  },
  searchInput: {
    flex: 1,
    fontSize: 16,
    color: '#1E293B',
    paddingVertical: 8,
  },
  countryList: {
    maxHeight: 400,
  },
  countryItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#F1F5F9',
  },
  selectedCountryItem: {
    backgroundColor: '#FAF5FF',
  },
  countryFlag: {
    fontSize: 24,
    marginRight: 12,
  },
  countryInfo: {
    flex: 1,
  },
  countryName: {
    fontSize: 16,
    color: '#1E293B',
    marginBottom: 2,
  },
  countryCode: {
    fontSize: 14,
    color: '#64748B',
  },
  selectedCountryText: {
    color: '#C084FC',
    fontWeight: '600',
  },
  doneButton: {
    backgroundColor: '#C084FC',
    margin: 20,
    paddingVertical: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  doneButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default LoginInitiateScreen;
========================================
FILE: src/screens/auth/SendOTPScreen.tsx
========================================

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
  Keyboard,
} from 'react-native';
import { useNavigation, NavigationProp, RouteProp, useRoute } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { api } from '@/services/api';
import { useToast } from '@/components/Toast';
import PrayantraLogo from '@/components/PrayantraLogo';

type RootStackParamList = {
  LoginInitiate: undefined;
  SendOTP: { phoneNumber: string; adminId?: string };
  VerifyOTP: { phoneNumber: string; adminId?: string };
  SetupMPIN: { phoneNumber: string; adminId: string };
  VerifyMPIN: { phoneNumber?: string; adminId?: string };
  ForgotMPIN: { phoneNumber?: string };
  MainDashboard: undefined;
};

type SendOTPScreenRouteProp = RouteProp<RootStackParamList, 'SendOTP'>;

const SendOTPScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const route = useRoute<SendOTPScreenRouteProp>();
  const { phoneNumber, adminId } = route.params;
  const { showToast } = useToast();

  const [resendCooldown, setResendCooldown] = useState(0); // Start at 0, will set after first send
  const [isLoading, setIsLoading] = useState(true); // Start loading to auto-send OTP
  const [hasSentInitialOTP, setHasSentInitialOTP] = useState(false);
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    console.log('📱 SendOTPScreen mounted, auto-sending OTP to:', phoneNumber);
    
    // Auto-send OTP when screen loads
    if (!hasSentInitialOTP) {
      handleSendOTP();
    }
    
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, []);

  const startTimer = (seconds: number = 60) => {
    setResendCooldown(seconds);
    
    if (timerRef.current) {
      clearInterval(timerRef.current);
    }

    timerRef.current = setInterval(() => {
      setResendCooldown((prev) => {
        if (prev <= 1) {
          if (timerRef.current) {
            clearInterval(timerRef.current);
          }
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
  };

  const sendOTPMutation = useMutation({
    mutationFn: () => api.sendOTP(phoneNumber, 'admin_login'),
    onSuccess: (response) => {
      console.log('✅ OTP sent successfully:', response.data);
      showToast('success', 'OTP sent successfully to your phone');
      startTimer(60);
      setHasSentInitialOTP(true);
      setIsLoading(false);
    },
    onError: (error: any) => {
      console.error('❌ OTP send error:', error.response?.data);
      const errorMessage = error.response?.data?.message || 'Failed to send OTP';
      
      if (error.response?.status === 429) {
        const retryAfter = error.response.data?.retry_after || 60;
        startTimer(retryAfter);
        showToast('error', `Too many requests. Please wait ${retryAfter} seconds`);
      } else if (error.response?.status === 500 && error.response.data?.error === 'phone number not registered') {
        Alert.alert(
          'Phone Not Registered',
          'This phone number is not registered. Please contact your administrator.',
          [{ text: 'OK', onPress: () => navigation.goBack() }]
        );
      } else {
        showToast('error', errorMessage);
      }
      setIsLoading(false);
    },
  });

  const handleSendOTP = () => {
    if (resendCooldown > 0 && !isLoading) {
      showToast('info', `Please wait ${resendCooldown} seconds before resending`);
      return;
    }
    setIsLoading(true);
    console.log('📡 Sending OTP to:', phoneNumber);
    sendOTPMutation.mutate();
  };

  const handleVerifyOTP = () => {
    console.log('➡️ Navigating to VerifyOTP with phone:', phoneNumber);
    navigation.navigate('VerifyOTP', { phoneNumber, adminId });
  };

  const handleGoBack = () => {
    navigation.goBack();
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 60 : 0}
    >
      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
      >
        <View style={styles.logoContainer}>
          <PrayantraLogo size={100} />
          <Text style={styles.appName}>Prayantra</Text>
        </View>

        <View style={styles.formContainer}>
          <Text style={styles.title}>Verify Device</Text>
          <Text style={styles.subtitle}>
            {isLoading ? 'Sending OTP...' : 'We\'ve sent a 6-digit OTP to your registered phone number'}
          </Text>

          <View style={styles.phoneContainer}>
            <Text style={styles.phoneLabel}>Phone Number</Text>
            <Text style={styles.phoneNumber}>{phoneNumber}</Text>
          </View>

          <Text style={styles.instruction}>
            For security reasons, we need to verify this device. Enter the OTP sent to your phone.
          </Text>

          <TouchableOpacity
            style={[styles.verifyButton, (!hasSentInitialOTP || isLoading) && styles.buttonDisabled]}
            onPress={handleVerifyOTP}
            disabled={!hasSentInitialOTP || isLoading}
          >
            <Text style={styles.verifyButtonText}>
              {!hasSentInitialOTP ? 'Sending OTP...' : 'Enter OTP'}
            </Text>
          </TouchableOpacity>

          <View style={styles.resendContainer}>
            <Text style={styles.resendText}>
              Didn't receive OTP? 
            </Text>
            <TouchableOpacity
              onPress={handleSendOTP}
              disabled={isLoading || resendCooldown > 0}
            >
              <Text style={[
                styles.resendButton,
                (isLoading || resendCooldown > 0) && styles.resendButtonDisabled
              ]}>
                {isLoading ? 'Sending...' : 
                 resendCooldown > 0 ? `Resend in ${resendCooldown}s` : 'Resend OTP'}
              </Text>
            </TouchableOpacity>
          </View>

          {sendOTPMutation.isError && (
            <View style={styles.errorContainer}>
              <Text style={styles.errorText}>
                {sendOTPMutation.error?.response?.data?.error || 'Failed to send OTP'}
              </Text>
            </View>
          )}
        </View>

        <View style={styles.footer}>
          <TouchableOpacity onPress={handleGoBack}>
            <Text style={styles.backButton}>← Back to Login</Text>
          </TouchableOpacity>
          
          <View style={styles.securityInfo}>
            <Text style={styles.securityTitle}>Security Notice:</Text>
            <Text style={styles.securityText}>
              • OTP is valid for 10 minutes
              {'\n'}• Never share OTP with anyone
              {'\n'}• This OTP is for device verification only
              {'\n'}• Rate limit applies for OTP resend
            </Text>
          </View>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 40,
    paddingBottom: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  appName: {
    fontSize: 24,
    fontWeight: '700',
    color: '#C084FC',
    marginTop: 12,
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 24,
    textAlign: 'center',
    lineHeight: 20,
  },
  phoneContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 8,
    padding: 16,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#E2E8F0',
    alignItems: 'center',
  },
  phoneLabel: {
    fontSize: 12,
    color: '#64748B',
    marginBottom: 4,
  },
  phoneNumber: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1E293B',
  },
  instruction: {
    fontSize: 13,
    color: '#64748B',
    textAlign: 'center',
    marginBottom: 24,
    lineHeight: 18,
  },
  verifyButton: {
    backgroundColor: '#C084FC',
    borderRadius: 8,
    paddingVertical: 16,
    alignItems: 'center',
    marginBottom: 20,
  },
  buttonDisabled: {
    backgroundColor: '#D8B4FE',
  },
  verifyButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  resendContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 8,
  },
  resendText: {
    fontSize: 14,
    color: '#64748B',
    marginRight: 4,
  },
  resendButton: {
    fontSize: 14,
    color: '#C084FC',
    fontWeight: '600',
  },
  resendButtonDisabled: {
    color: '#D8B4FE',
  },
  errorContainer: {
    backgroundColor: '#FEF2F2',
    padding: 12,
    borderRadius: 8,
    marginTop: 16,
    borderWidth: 1,
    borderColor: '#FECACA',
  },
  errorText: {
    color: '#DC2626',
    fontSize: 13,
    textAlign: 'center',
  },
  footer: {
    marginTop: 32,
  },
  backButton: {
    color: '#C084FC',
    fontSize: 14,
    fontWeight: '500',
    textAlign: 'center',
    marginBottom: 24,
  },
  securityInfo: {
    backgroundColor: '#FAF5FF',
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  securityTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#C084FC',
    marginBottom: 8,
  },
  securityText: {
    fontSize: 12,
    color: '#6B21A8',
    lineHeight: 18,
  },
});

export default SendOTPScreen;
========================================
FILE: src/screens/auth/SetupMPINScreen.tsx
========================================

import React, { useState, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
  Keyboard,
} from 'react-native';
import { useNavigation, NavigationProp, RouteProp, useRoute } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { api } from '@/services/api';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';
import PrayantraLogo from '@/components/PrayantraLogo';
import MPINInput, { MPINInputRef } from '@/components/MPINInput';

type RootStackParamList = {
  LoginInitiate: undefined;
  SendOTP: { phoneNumber: string; adminId?: string };
  VerifyOTP: { phoneNumber: string; adminId?: string };
  SetupMPIN: { phoneNumber: string; adminId: string };
  VerifyMPIN: { phoneNumber?: string; adminId?: string };
  ForgotMPIN: { phoneNumber?: string };
  MainDrawer: undefined;
};

type SetupMPINScreenRouteProp = RouteProp<RootStackParamList, 'SetupMPIN'>;

const SetupMPINScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const route = useRoute<SetupMPINScreenRouteProp>();
  const { phoneNumber, adminId } = route.params;
  
  const { login, storePhoneNumber } = useAuth();
  const { showToast } = useToast();

  const [mpin, setMpin] = useState('');
  const [confirmMpin, setConfirmMpin] = useState('');
  const [step, setStep] = useState(1);
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [keyboardHeight, setKeyboardHeight] = useState(0);
  const mpinInputRef = useRef<MPINInputRef>(null);

  React.useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      (e) => {
        setKeyboardHeight(e.endCoordinates.height);
      }
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setKeyboardHeight(0);
      }
    );

    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  const setupMPINMutation = useMutation({
    mutationFn: (mpin: string) => api.setupMPIN(adminId, mpin),
    onSuccess: (response: any) => {
      // After MPIN setup, verify it to get tokens
      api.verifyMPIN(phoneNumber, mpin)
        .then(verifyResponse => {
          const { admin, tokens, message } = verifyResponse.data.data;
          // Store phone number permanently
          storePhoneNumber(phoneNumber, admin.admin_id);
          login(phoneNumber, tokens, admin);
          showToast('success', message || 'MPIN setup successful');
          
          // Navigate to MainDrawer
          navigation.reset({
            index: 0,
            routes: [{ name: 'MainDrawer' }],
          });
        })
        .catch(error => {
          // If verification fails, still store phone number and redirect to verify MPIN
          showToast('success', 'MPIN setup successful. Please login with your MPIN.');
          storePhoneNumber(phoneNumber, adminId);
          navigation.navigate('VerifyMPIN', { phoneNumber });
        });
    },
    onError: (error: any) => {
      const errorType = error.response?.data?.error;
      const errorMessage = error.response?.data?.message || 'Failed to setup MPIN';

      if (errorType === 'admin MPIN already exists') {
        Alert.alert(
          'MPIN Already Exists',
          'MPIN is already setup for this account. Please login with your MPIN.',
          [{ text: 'OK', onPress: () => navigation.navigate('VerifyMPIN', { phoneNumber }) }]
        );
      } else if (errorType === 'admin MPIN is too weak') {
        setError('MPIN is too weak. Please use a stronger MPIN.');
        setStep(1);
        setMpin('');
        setConfirmMpin('');
        mpinInputRef.current?.clearAll();
      } else {
        showToast('error', errorMessage);
        setStep(1);
        setMpin('');
        setConfirmMpin('');
        mpinInputRef.current?.clearAll();
      }
    },
    onSettled: () => {
      setIsLoading(false);
    },
  });

  const handleMPINSubmit = (enteredMpin: string) => {
    if (step === 1) {
      // Validate MPIN strength
      if (isWeakMpin(enteredMpin)) {
        setError('MPIN is too common. Please choose a stronger MPIN.');
        return;
      }

      setMpin(enteredMpin);
      setError('');
      setStep(2);
      mpinInputRef.current?.clearAll();
    } else {
      setConfirmMpin(enteredMpin);
      
      if (enteredMpin === mpin) {
        setIsLoading(true);
        setupMPINMutation.mutate(enteredMpin);
      } else {
        setError('MPIN does not match. Please try again.');
        setConfirmMpin('');
        mpinInputRef.current?.clearAll();
      }
    }
  };

  const handleBack = () => {
    if (step === 2) {
      setStep(1);
      setConfirmMpin('');
      setError('');
      mpinInputRef.current?.clearAll();
    } else {
      navigation.goBack();
    }
  };

  const isWeakMpin = (mpin: string) => {
    const weakPatterns = [
      '111111', '222222', '333333', '444444', '555555',
      '666666', '777777', '888888', '999999', '000000',
      '123456', '654321', '121212', '123123', '112233'
    ];
    return weakPatterns.includes(mpin) || 
           mpin.split('').every((digit, i, arr) => digit === arr[0]);
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
    >
      <ScrollView 
        contentContainerStyle={[
          styles.scrollContent,
          { paddingBottom: keyboardHeight > 0 ? keyboardHeight + 20 : 40 }
        ]}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
      >
        <View style={styles.logoContainer}>
          <PrayantraLogo size={100} />
          <Text style={styles.appName}>Prayantra</Text>
        </View>

        <View style={styles.formContainer}>
          <Text style={styles.title}>
            {step === 1 ? 'Setup MPIN' : 'Confirm MPIN'}
          </Text>
          
          <Text style={styles.subtitle}>
            {step === 1 
              ? 'Create a 6-digit MPIN for secure login' 
              : 'Re-enter your MPIN to confirm'}
          </Text>

          <View style={styles.stepIndicator}>
            <View style={[styles.step, step === 1 && styles.activeStep]}>
              <Text style={[styles.stepText, step === 1 && styles.activeStepText]}>1</Text>
            </View>
            <View style={styles.stepLine} />
            <View style={[styles.step, step === 2 && styles.activeStep]}>
              <Text style={[styles.stepText, step === 2 && styles.activeStepText]}>2</Text>
            </View>
          </View>

          <View style={styles.mpinContainer}>
            <MPINInput
              ref={mpinInputRef}
              onSubmit={handleMPINSubmit}
              error={!!error}
              disabled={isLoading}
              autoFocus={true}
              showSubmitButton={true}
              secureTextEntry={true}
            />
          </View>

          {error ? (
            <View style={styles.errorContainer}>
              <Text style={styles.errorText}>{error}</Text>
            </View>
          ) : (
            <View style={styles.guidelinesContainer}>
              <Text style={styles.guidelinesTitle}>
                {step === 1 ? 'MPIN Guidelines:' : 'Almost there!'}
              </Text>
              {step === 1 ? (
                <>
                  <Text style={styles.guideline}>• Must be 6 digits</Text>
                  <Text style={styles.guideline}>• Avoid simple patterns (111111, 123456)</Text>
                  <Text style={styles.guideline}>• Don't use repeated digits</Text>
                  <Text style={styles.guideline}>• Choose something memorable but secure</Text>
                </>
              ) : (
                <>
                  <Text style={styles.guideline}>• Re-enter the same 6-digit MPIN</Text>
                  <Text style={styles.guideline}>• Make sure it matches exactly</Text>
                  <Text style={styles.guideline}>• This will be your login password</Text>
                </>
              )}
            </View>
          )}

          {isLoading ? (
            <View style={styles.loadingContainer}>
              <Text style={styles.loadingText}>
                {step === 2 ? 'Setting up MPIN...' : 'Processing...'}
              </Text>
            </View>
          ) : null}

          <TouchableOpacity
            style={styles.backButton}
            onPress={handleBack}
            disabled={isLoading}
          >
            <Text style={styles.backButtonText}>
              ← {step === 2 ? 'Back to enter MPIN' : 'Back'}
            </Text>
          </TouchableOpacity>
        </View>

        <View style={styles.securityInfo}>
          <Text style={styles.securityTitle}>Security First:</Text>
          <Text style={styles.securityText}>
            • Your MPIN is encrypted and stored securely
            {'\n'}• Never share your MPIN with anyone
            {'\n'}• You can change MPIN anytime from settings
            {'\n'}• Contact admin if you forget your MPIN
          </Text>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 60,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  appName: {
    fontSize: 24,
    fontWeight: '700',
    color: '#8B5CF6',
    marginTop: 12,
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: '#1F2937',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#6B7280',
    marginBottom: 24,
    textAlign: 'center',
  },
  stepIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 32,
  },
  step: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#E5E7EB',
    alignItems: 'center',
    justifyContent: 'center',
  },
  activeStep: {
    backgroundColor: '#8B5CF6',
  },
  stepText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#6B7280',
  },
  activeStepText: {
    color: '#FFFFFF',
  },
  stepLine: {
    width: 40,
    height: 2,
    backgroundColor: '#E5E7EB',
    marginHorizontal: 8,
  },
  mpinContainer: {
    marginBottom: 24,
  },
  errorContainer: {
    backgroundColor: '#FEF2F2',
    padding: 16,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#FECACA',
  },
  errorText: {
    color: '#EF4444',
    fontSize: 14,
    textAlign: 'center',
  },
  guidelinesContainer: {
    backgroundColor: '#F5F3FF',
    padding: 16,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#DDD6FE',
  },
  guidelinesTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#8B5CF6',
    marginBottom: 8,
  },
  guideline: {
    fontSize: 13,
    color: '#6D28D9',
    marginBottom: 4,
    lineHeight: 18,
  },
  loadingContainer: {
    marginBottom: 24,
  },
  loadingText: {
    color: '#6B7280',
    fontSize: 14,
    textAlign: 'center',
  },
  backButton: {
    alignItems: 'center',
    paddingVertical: 12,
  },
  backButtonText: {
    color: '#8B5CF6',
    fontSize: 14,
    fontWeight: '500',
  },
  securityInfo: {
    marginTop: 32,
    backgroundColor: '#F5F3FF',
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#DDD6FE',
  },
  securityTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#8B5CF6',
    marginBottom: 8,
  },
  securityText: {
    fontSize: 12,
    color: '#6D28D9',
    lineHeight: 18,
  },
});

export default SetupMPINScreen;
========================================
FILE: src/screens/auth/VerifyMPINScreen.tsx
========================================

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
  Keyboard,
  Dimensions,
  ActivityIndicator,
} from 'react-native';
import { useNavigation, NavigationProp, useRoute, RouteProp } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { api } from '@/services/api';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';
import PrayantraLogo from '@/components/PrayantraLogo';
import MPINInput, { MPINInputRef } from '@/components/MPINInput';
import {
  hasStoredPhoneNumber,
  getFormattedPhoneNumber,
  getDisplayPhoneNumber
} from '@/services/storage';

const { height } = Dimensions.get('window');

type RootStackParamList = {
  LoginInitiate: undefined;
  SendOTP: { phoneNumber: string; adminId?: string };
  VerifyOTP: { phoneNumber: string; adminId?: string };
  SetupMPIN: { phoneNumber: string; adminId: string };
  VerifyMPIN: { phoneNumber?: string; adminId?: string };
  ForgotMPIN: { phoneNumber?: string };
  MainDrawer: undefined;
};

type VerifyMPINScreenRouteProp = RouteProp<RootStackParamList, 'VerifyMPIN'>;

const VerifyMPINScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const route = useRoute<VerifyMPINScreenRouteProp>();
  const params = route.params;
  
  const { login, clearPhoneNumber } = useAuth();
  const { showToast } = useToast();
  
  const [mpin, setMpin] = useState('');
  const [error, setError] = useState('');
  const [attemptCount, setAttemptCount] = useState(0);
  const [isLocked, setIsLocked] = useState(false);
  const [lockTime, setLockTime] = useState(0);
  const [phoneNumber, setPhoneNumber] = useState('');
  const [displayPhoneNumber, setDisplayPhoneNumber] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isLoadingPhone, setIsLoadingPhone] = useState(true);
  const [keyboardHeight, setKeyboardHeight] = useState(0);
  const mpinInputRef = useRef<MPINInputRef>(null);
  const scrollViewRef = useRef<ScrollView>(null);

  useEffect(() => {
    const loadPhoneNumber = async () => {
      setIsLoadingPhone(true);
      try {
        console.log('📱 [VERIFY_MPIN] Loading phone number from params:', params);
        
        // FIRST: Check if we have phone number from params (coming from LoginInitiate)
        if (params?.phoneNumber) {
          setPhoneNumber(params.phoneNumber);
          setDisplayPhoneNumber(formatPhoneForDisplay(params.phoneNumber));
          console.log('✅ [VERIFY_MPIN] Using phone number from params:', params.phoneNumber);
          setIsLoadingPhone(false);
          return;
        }
        
        // SECOND: If no params, check if we have stored phone number
        console.log('🔍 [VERIFY_MPIN] No params, checking stored phone number...');
        const hasPhone = await hasStoredPhoneNumber();
        const formattedPhone = await getFormattedPhoneNumber();
        const displayPhone = await getDisplayPhoneNumber();
        
        console.log('📱 [VERIFY_MPIN] Storage check:', {
          hasPhone,
          formattedPhone,
          displayPhone
        });
        
        if (hasPhone && formattedPhone) {
          setPhoneNumber(formattedPhone);
          setDisplayPhoneNumber(displayPhone || formattedPhone);
          console.log('✅ [VERIFY_MPIN] Using stored phone number:', formattedPhone);
        } else {
          console.log('❌ [VERIFY_MPIN] No phone number found, redirecting to LoginInitiate');
          showToast('info', 'Please login with your phone number');
          navigation.reset({
            index: 0,
            routes: [{ name: 'LoginInitiate' }],
          });
        }
      } catch (error) {
        console.error('❌ [VERIFY_MPIN] Error loading phone number:', error);
        showToast('error', 'Error loading phone number');
        navigation.reset({
          index: 0,
          routes: [{ name: 'LoginInitiate' }],
        });
      } finally {
        setIsLoadingPhone(false);
      }
    };
    
    loadPhoneNumber();

    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      (e) => {
        setKeyboardHeight(e.endCoordinates.height);
        setTimeout(() => {
          scrollViewRef.current?.scrollTo({ y: 100, animated: true });
        }, 100);
      }
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setKeyboardHeight(0);
      }
    );

    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, [params?.phoneNumber]);

  useEffect(() => {
    if (isLocked && lockTime > 0) {
      const timer = setInterval(() => {
        setLockTime(prev => {
          if (prev <= 1) {
            setIsLocked(false);
            clearInterval(timer);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [isLocked, lockTime]);

  // Helper function to format phone number for display
  const formatPhoneForDisplay = (phone: string) => {
    if (!phone) return '';
    // If phone is in format +919876543210, format to +91 98765 43210
    const countryCode = phone.substring(0, 3);
    const remaining = phone.substring(3);
    if (remaining.length === 10) {
      return `${countryCode} ${remaining.substring(0, 5)} ${remaining.substring(5)}`;
    }
    return phone;
  };

  const mutation = useMutation({
    mutationFn: (mpin: string) => api.verifyMPIN(phoneNumber, mpin),
    onSuccess: (response: any) => {
      console.log('✅ MPIN verification response:', response.data);
      if (response.data.success) {
        const { admin, tokens, message } = response.data.data;
        console.log('🔐 Tokens received:', {
          accessTokenLength: tokens?.access_token?.length || 0,
          refreshTokenLength: tokens?.refresh_token?.length || 0,
          adminId: admin?.admin_id
        });
        
        if (!tokens?.access_token || !tokens?.refresh_token) {
          console.error('❌ Tokens missing in response:', response.data);
          setError('Invalid response from server. Please try again.');
          showToast('error', 'Invalid server response');
          return;
        }
        
        // ✅ Store phone number ONLY after successful MPIN verification
        // The login function in AuthContext will handle storage
        login(phoneNumber, tokens, admin);
        showToast('success', message || 'Login successful');
        
        navigation.reset({
          index: 0,
          routes: [{ name: 'MainDrawer' }],
        });
      } else {
        const errorMessage = response.data.message || 'MPIN verification failed';
        setError(errorMessage);
        showToast('error', errorMessage);
        setMpin('');
        mpinInputRef.current?.clearAll();
      }
    },
    onError: (error: any) => {
      console.error('❌ MPIN verification error:', {
        status: error.response?.status,
        data: error.response?.data,
        message: error.message
      });
      
      const errorType = error.response?.data?.error;
      const errorMessage = error.response?.data?.message || 'MPIN verification failed';
      
      if (errorType === 'MPIN rate limit exceeded') {
        setIsLocked(true);
        setLockTime(60);
        setError('Too many failed attempts. Please try again after 60 seconds.');
        Alert.alert(
          'MPIN Locked',
          'Too many failed attempts. Please try again after 60 seconds.',
          [{ text: 'OK' }]
        );
        return;
      }
      
      const newAttemptCount = attemptCount + 1;
      setAttemptCount(newAttemptCount);
      
      if (newAttemptCount >= 3) {
        setError(`Invalid MPIN. You have ${5 - newAttemptCount} attempts left.`);
      } else {
        setError('Invalid MPIN. Please try again.');
      }
      
      showToast('error', errorMessage);
      setMpin('');
      mpinInputRef.current?.clearAll();
    },
    onSettled: () => {
      setIsLoading(false);
    },
  });

  const handleMPINSubmit = (enteredMpin: string) => {
    if (isLocked) {
      setError(`Please wait ${lockTime} seconds before trying again`);
      showToast('error', `Please wait ${lockTime} seconds before trying again`);
      return;
    }
    
    if (enteredMpin.length !== 6) {
      setError('Please enter 6-digit MPIN');
      return;
    }
    
    setMpin(enteredMpin);
    setError('');
    setIsLoading(true);
    mutation.mutate(enteredMpin);
  };

  const handleForgotMPIN = () => {
    navigation.navigate('ForgotMPIN', { phoneNumber });
  };

  const handleRemovePhoneNumber = async () => {
    Alert.alert(
      'Remove Phone Number',
      'Are you sure you want to remove this phone number? You will need to enter it again next time.',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Remove', 
          style: 'destructive',
          onPress: async () => {
            await clearPhoneNumber();
            showToast('success', 'Phone number removed');
            navigation.reset({
              index: 0,
              routes: [{ name: 'LoginInitiate' }],
            });
          }
        }
      ]
    );
  };

  const handleUseDifferentAccount = () => {
    navigation.reset({
      index: 0,
      routes: [{ name: 'LoginInitiate' }],
    });
  };

  if (isLoadingPhone) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#8B5CF6" />
        <Text style={styles.loadingText}>Loading...</Text>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 20}
    >
      <ScrollView 
        ref={scrollViewRef}
        contentContainerStyle={[
          styles.scrollContent,
          { 
            minHeight: keyboardHeight > 0 ? height : undefined,
            paddingBottom: keyboardHeight > 0 ? keyboardHeight + 20 : 40 
          }
        ]}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
        keyboardDismissMode="interactive"
      >
        <View style={styles.logoContainer}>
          <PrayantraLogo size={100} />
          <Text style={styles.appName}>Prayantra</Text>
        </View>

        <View style={styles.formContainer}>
          <Text style={styles.title}>Enter MPIN</Text>
          <Text style={styles.subtitle}>
            {displayPhoneNumber ? `Enter MPIN for ${displayPhoneNumber}` : 'Enter your 6-digit MPIN'}
          </Text>

          <MPINInput
            ref={mpinInputRef}
            onComplete={setMpin}
            onSubmit={handleMPINSubmit}
            error={!!error}
            disabled={isLoading || isLocked}
            showSubmitButton={true}
          />

          {isLocked ? (
            <View style={styles.lockContainer}>
              <Text style={styles.lockText}>
                MPIN locked. Try again in {lockTime} seconds
              </Text>
            </View>
          ) : null}

          {error ? (
            <View style={styles.errorContainer}>
              <Text style={styles.errorText}>{error}</Text>
            </View>
          ) : null}

          {isLoading ? (
            <View style={styles.loadingContainer}>
              <Text style={styles.loadingText}>Verifying MPIN...</Text>
            </View>
          ) : null}

          <View style={styles.actionsContainer}>
            <TouchableOpacity
              style={styles.actionButton}
              onPress={handleForgotMPIN}
              disabled={isLoading}
            >
              <Text style={styles.actionText}>Forgot MPIN?</Text>
            </TouchableOpacity>

            {!params?.phoneNumber && ( // Only show remove button if using stored number
              <TouchableOpacity
                style={styles.actionButton}
                onPress={handleRemovePhoneNumber}
                disabled={isLoading}
              >
                <Text style={styles.actionText}>Remove Number</Text>
              </TouchableOpacity>
            )}

            <TouchableOpacity
              style={styles.actionButton}
              onPress={handleUseDifferentAccount}
              disabled={isLoading}
            >
              <Text style={styles.actionText}>Use different account</Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.securityInfo}>
          <Text style={styles.securityTitle}>Security Tips:</Text>
          <Text style={styles.securityTip}>• Never share your MPIN with anyone</Text>
          <Text style={styles.securityTip}>• Change your MPIN regularly</Text>
          <Text style={styles.securityTip}>• Use a unique MPIN not used elsewhere</Text>
          <Text style={styles.securityTip}>• Your phone number is stored for auto-login</Text>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#FFFFFF',
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: '#6B7280',
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 40,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  appName: {
    fontSize: 24,
    fontWeight: '700',
    color: '#8B5CF6',
    marginTop: 12,
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
    marginBottom: 24,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: '#1F2937',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#6B7280',
    marginBottom: 32,
    textAlign: 'center',
  },
  lockContainer: {
    backgroundColor: '#FEF2F2',
    padding: 12,
    borderRadius: 8,
    marginTop: 16,
    borderWidth: 1,
    borderColor: '#FECACA',
  },
  lockText: {
    color: '#EF4444',
    fontSize: 14,
    textAlign: 'center',
    fontWeight: '500',
  },
  errorContainer: {
    backgroundColor: '#FEF2F2',
    padding: 12,
    borderRadius: 8,
    marginTop: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#FECACA',
  },
  errorText: {
    color: '#EF4444',
    fontSize: 14,
    textAlign: 'center',
  },
  actionsContainer: {
    marginTop: 24,
    alignItems: 'center',
  },
  actionButton: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    marginBottom: 12,
    width: '100%',
    alignItems: 'center',
  },
  actionText: {
    color: '#8B5CF6',
    fontSize: 14,
    fontWeight: '500',
  },
  securityInfo: {
    marginTop: 32,
    backgroundColor: '#F5F3FF',
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#DDD6FE',
  },
  securityTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#8B5CF6',
    marginBottom: 8,
  },
  securityTip: {
    fontSize: 12,
    color: '#6D28D9',
    marginBottom: 4,
  },
});

export default VerifyMPINScreen;
========================================
FILE: src/screens/auth/VerifyOTPScreen.tsx
========================================

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
  Keyboard,
  Dimensions,
} from 'react-native';
import { useNavigation, NavigationProp, RouteProp, useRoute } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { api } from '@/services/api';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';
import PrayantraLogo from '@/components/PrayantraLogo';
import OTPInput, { OTPInputRef } from '@/components/OTPInput';

const { height } = Dimensions.get('window');

type RootStackParamList = {
  LoginInitiate: undefined;
  SendOTP: { phoneNumber: string; adminId?: string };
  VerifyOTP: { phoneNumber: string; adminId?: string };
  SetupMPIN: { phoneNumber: string; adminId: string };
  VerifyMPIN: { phoneNumber?: string; adminId?: string };
  ForgotMPIN: { phoneNumber?: string };
  MainDashboard: undefined;
  Profile: undefined;
  ChangeMPIN: undefined;
  Department: { department: string };
};

type VerifyOTPScreenRouteProp = RouteProp<RootStackParamList, 'VerifyOTP'>;

const VerifyOTPScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const route = useRoute<VerifyOTPScreenRouteProp>();
  const { phoneNumber, adminId } = route.params;
  
  const { login, storePhoneNumber } = useAuth();
  const { showToast } = useToast();

  const [otp, setOtp] = useState('');
  const [otpTimer, setOtpTimer] = useState(600);
  const [resendCooldown, setResendCooldown] = useState(60);
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isResendLoading, setIsResendLoading] = useState(false);
  const [keyboardHeight, setKeyboardHeight] = useState(0);
  const otpTimerRef = useRef<NodeJS.Timeout | null>(null);
  const resendTimerRef = useRef<NodeJS.Timeout | null>(null);
  const otpInputRef = useRef<OTPInputRef>(null);
  const scrollViewRef = useRef<ScrollView>(null);

  useEffect(() => {
    startOtpTimer();
    startResendCooldown();

    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      (e) => {
        setKeyboardHeight(e.endCoordinates.height);
        setTimeout(() => {
          scrollViewRef.current?.scrollTo({ y: 100, animated: true });
        }, 100);
      }
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setKeyboardHeight(0);
      }
    );

    return () => {
      if (otpTimerRef.current) {
        clearInterval(otpTimerRef.current);
      }
      if (resendTimerRef.current) {
        clearInterval(resendTimerRef.current);
      }
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  useEffect(() => {
    if (otp.length === 6 && !isLoading) {
      handleVerifyOTP();
    }
  }, [otp]);

  const startOtpTimer = () => {
    if (otpTimerRef.current) {
      clearInterval(otpTimerRef.current);
    }

    otpTimerRef.current = setInterval(() => {
      setOtpTimer((prev) => {
        if (prev <= 1) {
          if (otpTimerRef.current) {
            clearInterval(otpTimerRef.current);
          }
          setError('OTP has expired. Please request a new one.');
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
  };

  const startResendCooldown = (seconds: number = 60) => {
    setResendCooldown(seconds);
    
    if (resendTimerRef.current) {
      clearInterval(resendTimerRef.current);
    }

    resendTimerRef.current = setInterval(() => {
      setResendCooldown((prev) => {
        if (prev <= 1) {
          if (resendTimerRef.current) {
            clearInterval(resendTimerRef.current);
          }
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  const verifyOTPMutation = useMutation({
    mutationFn: (otpCode: string) => api.verifyOTP(phoneNumber, otpCode),
    onSuccess: (response: any) => {
      const { 
        has_mpin, 
        device_trusted, 
        admin_id, 
        message 
      } = response.data.data;
      
      console.log('✅ OTP verified:', { 
        has_mpin, 
        device_trusted, 
        admin_id,
        adminId 
      });
      
      // Store phone number and admin ID permanently
      const adminIdToStore = admin_id || adminId;
      if (adminIdToStore) {
        // Store phone number in format +919876543210 (without spaces)
        storePhoneNumber(phoneNumber, adminIdToStore);
      }

      if (has_mpin) {
        showToast('success', message || 'Device verified successfully');
        navigation.navigate('VerifyMPIN', { 
          phoneNumber,
          adminId: adminIdToStore 
        });
      } else {
        showToast('success', 'Device verified. Please setup your MPIN');
        navigation.navigate('SetupMPIN', { 
          phoneNumber,
          adminId: adminIdToStore 
        });
      }
    },
    onError: (error: any) => {
      console.error('❌ OTP verification error:', error.response?.data);
      
      const errorType = error.response?.data?.error;
      const errorMessage = error.response?.data?.message || 'OTP verification failed';
      
      if (errorType === 'phone number not registered') {
        setError('Phone number not registered. Please contact administrator.');
        Alert.alert(
          'Phone Not Registered',
          'This phone number is not registered. Please contact your administrator.',
          [{ text: 'OK', onPress: () => navigation.goBack() }]
        );
      } else {
        setError(errorMessage);
        setOtp('');
        otpInputRef.current?.clearAll();
        showToast('error', errorMessage);
      }
    },
    onSettled: () => {
      setIsLoading(false);
    },
  });

  const resendOTPMutation = useMutation({
    mutationFn: () => api.sendOTP(phoneNumber, 'admin_login'),
    onSuccess: () => {
      showToast('success', 'OTP resent successfully');
      setOtpTimer(600);
      setError('');
      setOtp('');
      otpInputRef.current?.clearAll();
      startOtpTimer();
      setIsResendLoading(false);
    },
    onError: (error: any) => {
      console.error('❌ Resend OTP error:', error.response?.data);
      
      const errorMessage = error.response?.data?.message || 'Failed to resend OTP';
      
      if (error.response?.status === 429) {
        const retryAfter = error.response.data?.retry_after || 60;
        startResendCooldown(retryAfter);
        showToast('error', `Too many requests. Please wait ${retryAfter} seconds`);
      } else if (error.response?.status === 500 && error.response.data?.error === 'phone number not registered') {
        Alert.alert(
          'Phone Not Registered',
          'This phone number is not registered. Please contact your administrator.',
          [{ text: 'OK', onPress: () => navigation.goBack() }]
        );
      } else {
        showToast('error', errorMessage);
      }
      setIsResendLoading(false);
    },
  });

  const handleVerifyOTP = () => {
    if (otp.length !== 6) {
      setError('Please enter 6-digit OTP');
      return;
    }

    if (otpTimer <= 0) {
      setError('OTP has expired. Please request a new one.');
      return;
    }

    setIsLoading(true);
    setError('');
    verifyOTPMutation.mutate(otp);
  };

  const handleResendOTP = () => {
    if (resendCooldown > 0) {
      showToast('info', `Please wait ${resendCooldown} seconds before resending`);
      return;
    }
    
    setIsResendLoading(true);
    resendOTPMutation.mutate();
  };

  const handleGoBack = () => {
    navigation.navigate('SendOTP', { phoneNumber, adminId });
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 20}
    >
      <ScrollView 
        ref={scrollViewRef}
        contentContainerStyle={[
          styles.scrollContent,
          { 
            minHeight: keyboardHeight > 0 ? height : undefined,
            paddingBottom: keyboardHeight > 0 ? keyboardHeight + 20 : 40 
          }
        ]}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
        keyboardDismissMode="interactive"
      >
        <View style={styles.logoContainer}>
          <PrayantraLogo size={100} />
          <Text style={styles.appName}>Prayantra</Text>
        </View>

        <View style={styles.formContainer}>
          <Text style={styles.title}>Enter OTP</Text>
          <Text style={styles.subtitle}>
            Enter the 6-digit OTP sent to your phone
          </Text>

          <View style={styles.phoneContainer}>
            <Text style={styles.phoneLabel}>Phone Number</Text>
            <Text style={styles.phoneNumber}>{phoneNumber}</Text>
          </View>

          <View style={styles.timerContainer}>
            <Text style={styles.timerText}>OTP expires in: {formatTime(otpTimer)}</Text>
          </View>

          <OTPInput
            ref={otpInputRef}
            length={6}
            onComplete={setOtp}
            error={!!error}
            disabled={isLoading}
            autoFocus={true}
            showSubmitButton={false}
          />

          {error ? (
            <View style={styles.errorContainer}>
              <Text style={styles.errorText}>{error}</Text>
            </View>
          ) : null}

          {isLoading ? (
            <View style={styles.loadingContainer}>
              <Text style={styles.loadingText}>Verifying OTP...</Text>
            </View>
          ) : null}

          <TouchableOpacity
            style={[
              styles.verifyButton, 
              (isLoading || otp.length !== 6) && styles.buttonDisabled
            ]}
            onPress={handleVerifyOTP}
            disabled={isLoading || otp.length !== 6}
          >
            <Text style={styles.verifyButtonText}>
              {isLoading ? 'Verifying...' : 'Verify OTP'}
            </Text>
          </TouchableOpacity>

          <View style={styles.resendContainer}>
            <Text style={styles.resendText}>Didn't receive OTP?</Text>
            <TouchableOpacity
              onPress={handleResendOTP}
              disabled={isResendLoading || resendCooldown > 0}
            >
              <Text style={[
                styles.resendButton,
                (isResendLoading || resendCooldown > 0) && styles.resendButtonDisabled
              ]}>
                {isResendLoading ? 'Sending...' : 
                 resendCooldown > 0 ? `Resend in ${resendCooldown}s` : 'Resend OTP'}
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.footer}>
          <TouchableOpacity onPress={handleGoBack} disabled={isLoading}>
            <Text style={styles.backButton}>← Change phone number</Text>
          </TouchableOpacity>
          
          <View style={styles.securityInfo}>
            <Text style={styles.securityTitle}>Important:</Text>
            <Text style={styles.securityText}>
              • OTP expires in 10 minutes
              {'\n'}• Enter OTP within {formatTime(otpTimer)}
              {'\n'}• This verifies your device for secure access
              {'\n'}• Rate limit applies for OTP resend
            </Text>
          </View>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 60,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  appName: {
    fontSize: 24,
    fontWeight: '700',
    color: '#8B5CF6',
    marginTop: 12,
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: '#1F2937',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#6B7280',
    marginBottom: 24,
    textAlign: 'center',
    lineHeight: 20,
  },
  phoneContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 8,
    padding: 12,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#E5E7EB',
    alignItems: 'center',
  },
  phoneLabel: {
    fontSize: 12,
    color: '#6B7280',
    marginBottom: 4,
  },
  phoneNumber: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1F2937',
  },
  timerContainer: {
    backgroundColor: '#FEF3C7',
    padding: 12,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#FDE68A',
  },
  timerText: {
    color: '#D97706',
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
  },
  errorContainer: {
    backgroundColor: '#FEF2F2',
    padding: 12,
    borderRadius: 8,
    marginTop: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#FECACA',
  },
  errorText: {
    color: '#DC2626',
    fontSize: 14,
    textAlign: 'center',
  },
  loadingContainer: {
    marginTop: 16,
    marginBottom: 16,
  },
  loadingText: {
    color: '#6B7280',
    fontSize: 14,
    textAlign: 'center',
  },
  verifyButton: {
    backgroundColor: '#8B5CF6',
    borderRadius: 12,
    paddingVertical: 16,
    alignItems: 'center',
    marginTop: 8,
    marginBottom: 20,
  },
  buttonDisabled: {
    backgroundColor: '#D1D5DB',
  },
  verifyButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  resendContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 8,
  },
  resendText: {
    fontSize: 14,
    color: '#6B7280',
    marginRight: 4,
  },
  resendButton: {
    fontSize: 14,
    color: '#8B5CF6',
    fontWeight: '600',
  },
  resendButtonDisabled: {
    color: '#D1D5DB',
  },
  footer: {
    marginTop: 32,
  },
  backButton: {
    color: '#8B5CF6',
    fontSize: 14,
    fontWeight: '500',
    textAlign: 'center',
    marginBottom: 24,
  },
  securityInfo: {
    backgroundColor: '#F5F3FF',
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#DDD6FE',
  },
  securityTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#8B5CF6',
    marginBottom: 8,
  },
  securityText: {
    fontSize: 12,
    color: '#6D28D9',
    lineHeight: 18,
  },
});

export default VerifyOTPScreen;
========================================
FILE: src/screens/dashboard/DepartmentScreen.tsx
========================================

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  RefreshControl,
  Dimensions,
  Alert,
  FlatList,
} from 'react-native';
import { useNavigation, RouteProp, useRoute } from '@react-navigation/native';
import { useQuery } from '@tanstack/react-query';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';

const { width } = Dimensions.get('window');

// Define route params type
type DepartmentScreenRouteProp = RouteProp<any, 'DepartmentScreen'>;

// Define permission categories based on department
const permissionCategories: Record<string, { title: string; permissions: string[] }[]> = {
  'HR': [
    {
      title: 'Employee Management',
      permissions: [
        'Create Employee',
        'Update Employee',
        'Delete Employee',
        'View Employee',
        'Search Employee',
        'Terminate Employee',
        'Transfer Employee',
      ]
    },
    {
      title: 'Document Management',
      permissions: [
        'Upload Document',
        'View Document',
        'Delete Document',
      ]
    },
    {
      title: 'Position Management',
      permissions: [
        'Create Position',
        'Update Position',
        'Delete Position',
        'View Position',
      ]
    },
    {
      title: 'Leave Management',
      permissions: [
        'Request Leave',
        'Approve Leave',
        'Reject Leave',
        'View Leave',
      ]
    },
    {
      title: 'Attendance',
      permissions: [
        'View Attendance',
        'Update Attendance',
      ]
    }
  ],
  'Finance': [
    {
      title: 'Invoice Management',
      permissions: [
        'Create Invoice',
        'Update Invoice',
        'Delete Invoice',
        'View Invoice',
        'Send Invoice',
        'Approve Invoice',
      ]
    },
    {
      title: 'Payment Processing',
      permissions: [
        'Process Payment',
        'Refund Payment',
        'View Payment',
      ]
    },
    {
      title: 'Financial Statements',
      permissions: [
        'View Statement',
        'Download Statement',
      ]
    },
    {
      title: 'Tax Management',
      permissions: [
        'Create Tax',
        'Update Tax',
        'View Tax',
        'Delete Tax',
      ]
    },
    {
      title: 'Budget Management',
      permissions: [
        'Create Budget',
        'Update Budget',
        'Delete Budget',
        'View Budget',
      ]
    }
  ],
  'IT': [
    {
      title: 'Asset Management',
      permissions: [
        'Create Asset',
        'Update Asset',
        'Delete Asset',
        'View Asset',
      ]
    },
    {
      title: 'Incident Management',
      permissions: [
        'Create Incident',
        'Update Incident',
        'Resolve Incident',
        'Close Incident',
        'View Incident',
      ]
    },
    {
      title: 'Access Management',
      permissions: [
        'Request Access',
        'Grant Access',
        'Revoke Access',
      ]
    },
    {
      title: 'System Configuration',
      permissions: [
        'Update Config',
        'View Config',
      ]
    }
  ],
  'Sales': [
    {
      title: 'Lead Management',
      permissions: [
        'Create Lead',
        'Update Lead',
        'Delete Lead',
        'View Lead',
      ]
    },
    {
      title: 'Deal Management',
      permissions: [
        'Create Deal',
        'Update Deal',
        'Delete Deal',
        'View Deal',
        'Close Deal',
      ]
    },
    {
      title: 'Quotation',
      permissions: [
        'Create Quote',
        'Update Quote',
        'Delete Quote',
        'View Quote',
      ]
    },
    {
      title: 'Sales Targets',
      permissions: [
        'Create Target',
        'Update Target',
        'View Target',
      ]
    }
  ],
  'Inventory': [
    {
      title: 'Item Management',
      permissions: [
        'Create Item',
        'Update Item',
        'Delete Item',
        'View Item',
      ]
    },
    {
      title: 'Stock Operations',
      permissions: [
        'Stock In',
        'Stock Out',
        'Stock Transfer',
        'Stock Adjust',
        'Stock Audit',
        'View Stock',
      ]
    },
    {
      title: 'Batch Management',
      permissions: [
        'Create Batch',
        'Update Batch',
        'View Batch',
        'Delete Batch',
      ]
    },
    {
      title: 'Warehouse Management',
      permissions: [
        'Create Warehouse',
        'Update Warehouse',
        'Delete Warehouse',
        'View Warehouse',
      ]
    }
  ],
  'default': [
    {
      title: 'Department Operations',
      permissions: [
        'View Dashboard',
        'Generate Reports',
        'Manage Settings',
        'View Analytics',
        'Create Entries',
        'Update Entries',
        'Delete Entries',
      ]
    }
  ]
};

const DepartmentScreen = () => {
  const navigation = useNavigation();
  const route = useRoute<DepartmentScreenRouteProp>();
  const { department } = route.params || {};
  
  const { adminInfo } = useAuth();
  const { showToast } = useToast();

  const [refreshing, setRefreshing] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);

  const departmentPermissions = permissionCategories[department] || permissionCategories['default'];
  const userPermissions = adminInfo?.permissions || [];

  useEffect(() => {
    if (departmentPermissions.length > 0) {
      setSelectedCategory(departmentPermissions[0].title);
    }
  }, [department]);

  const handleRefresh = async () => {
    setRefreshing(true);
    // Simulate API call
    setTimeout(() => {
      setRefreshing(false);
      showToast('success', 'Department data refreshed');
    }, 1000);
  };

  const hasPermission = (permission: string): boolean => {
    const permissionKey = permission.toLowerCase().replace(/\s+/g, '.');
    return userPermissions.some(p => p.includes(permissionKey));
  };

  const getDepartmentIcon = (dept: string) => {
    const icons: Record<string, string> = {
      'HR': 'account-group',
      'Finance': 'cash',
      'Accounting': 'calculator',
      'Procurement': 'cart',
      'Inventory': 'warehouse',
      'Logistics': 'truck',
      'Sales': 'chart-line',
      'Marketing': 'bullhorn',
      'Customer Support': 'headset',
      'Operations': 'cog',
      'IT': 'desktop-classic',
      'Production': 'factory',
      'Quality Control': 'check-circle',
      'Quality Assurance': 'shield-check',
      'R&D': 'flask',
      'Administration': 'office-building',
      'Employee Management': 'account-multiple',
      'Manager Management': 'account-tie',
      'Company Management': 'domain',
      'Super Admin Management': 'security',
    };
    return icons[dept] || 'folder';
  };

  const getDepartmentColor = (dept: string) => {
    const colors: Record<string, string> = {
      'HR': '#C084FC',
      'Finance': '#A855F7',
      'Accounting': '#9333EA',
      'Procurement': '#7C3AED',
      'Inventory': '#6D28D9',
      'Logistics': '#5B21B6',
      'Sales': '#4C1D95',
      'Marketing': '#3B0764',
      'Customer Support': '#7E22CE',
      'Operations': '#6B21A8',
      'IT': '#C084FC',
      'Production': '#A855F7',
      'Quality Control': '#9333EA',
      'Quality Assurance': '#7C3AED',
      'R&D': '#6D28D9',
      'Administration': '#5B21B6',
      'Employee Management': '#C084FC',
      'Manager Management': '#A855F7',
      'Company Management': '#9333EA',
      'Super Admin Management': '#7C3AED',
    };
    return colors[dept] || '#C084FC'; // Default purple
  };

  const renderPermissionItem = ({ item }: { item: string }) => (
    <View style={styles.permissionItem}>
      <View style={styles.permissionIconContainer}>
        {hasPermission(item) ? (
          <Icon name="check-circle" size={20} color="#10B981" />
        ) : (
          <Icon name="close-circle" size={20} color="#EF4444" />
        )}
      </View>
      <Text style={[
        styles.permissionText,
        !hasPermission(item) && styles.permissionDisabled
      ]}>
        {item}
      </Text>
      {hasPermission(item) ? (
        <View style={styles.permissionBadge}>
          <Text style={styles.permissionBadgeText}>Granted</Text>
        </View>
      ) : (
        <View style={[styles.permissionBadge, styles.permissionBadgeDisabled]}>
          <Text style={styles.permissionBadgeText}>Restricted</Text>
        </View>
      )}
    </View>
  );

  const renderCategory = () => {
    const category = departmentPermissions.find(cat => cat.title === selectedCategory);
    if (!category) return null;

    return (
      <View style={styles.categoryContainer}>
        <Text style={styles.categoryTitle}>{category.title}</Text>
        <FlatList
          data={category.permissions}
          renderItem={renderPermissionItem}
          keyExtractor={(item, index) => index.toString()}
          scrollEnabled={false}
          showsVerticalScrollIndicator={false}
        />
      </View>
    );
  };

  const departmentColor = getDepartmentColor(department);
  const departmentIcon = getDepartmentIcon(department);

  return (
    <View style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity 
          onPress={() => navigation.goBack()}
          style={styles.backButton}
        >
          <Icon name="arrow-left" size={24} color="#333" />
        </TouchableOpacity>
        
        <View style={styles.headerTitleContainer}>
          <View style={[styles.departmentIcon, { backgroundColor: `${departmentColor}15` }]}>
            <Icon name={departmentIcon as any} size={24} color={departmentColor} />
          </View>
          <View>
            <Text style={styles.headerTitle}>{department}</Text>
            <Text style={styles.headerSubtitle}>
              {departmentPermissions.length} permission categories
            </Text>
          </View>
        </View>
        
        <TouchableOpacity style={styles.menuButton}>
          <Icon name="dots-vertical" size={24} color="#64748B" />
        </TouchableOpacity>
      </View>

      <ScrollView
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[departmentColor]}
            tintColor={departmentColor}
          />
        }
        showsVerticalScrollIndicator={false}
      >
        {/* Department Overview */}
        <View style={styles.overviewContainer}>
          <Text style={styles.overviewTitle}>Department Overview</Text>
          <Text style={styles.overviewText}>
            Manage all {department} related operations and permissions. 
            Below are the available permission categories for this department.
          </Text>
          
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: departmentColor }]}>
                {departmentPermissions.length}
              </Text>
              <Text style={styles.statLabel}>Categories</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: departmentColor }]}>
                {departmentPermissions.reduce((total, cat) => total + cat.permissions.length, 0)}
              </Text>
              <Text style={styles.statLabel}>Permissions</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: departmentColor }]}>
                {departmentPermissions.reduce((total, cat) => 
                  total + cat.permissions.filter(p => hasPermission(p)).length, 0
                )}
              </Text>
              <Text style={styles.statLabel}>Granted</Text>
            </View>
          </View>
        </View>

        {/* Permission Categories */}
        <View style={styles.categoriesContainer}>
          <Text style={styles.sectionTitle}>Permission Categories</Text>
          
          <ScrollView 
            horizontal 
            showsHorizontalScrollIndicator={false}
            style={styles.categoriesScroll}
          >
            {departmentPermissions.map((category, index) => (
              <TouchableOpacity
                key={index}
                style={[
                  styles.categoryTab,
                  selectedCategory === category.title && [
                    styles.categoryTabActive,
                    { borderColor: departmentColor }
                  ]
                ]}
                onPress={() => setSelectedCategory(category.title)}
              >
                <Text style={[
                  styles.categoryTabText,
                  selectedCategory === category.title && [
                    styles.categoryTabTextActive,
                    { color: departmentColor }
                  ]
                ]}>
                  {category.title}
                </Text>
                <View style={styles.permissionCount}>
                  <Text style={styles.permissionCountText}>
                    {category.permissions.filter(p => hasPermission(p)).length}/{category.permissions.length}
                  </Text>
                </View>
              </TouchableOpacity>
            ))}
          </ScrollView>

          {/* Selected Category Permissions */}
          {renderCategory()}
        </View>

        {/* Quick Actions */}
        <View style={styles.actionsContainer}>
          <Text style={styles.sectionTitle}>Quick Actions</Text>
          <View style={styles.actionsGrid}>
            <TouchableOpacity style={styles.actionButton}>
              <View style={[styles.actionIcon, { backgroundColor: `${departmentColor}15` }]}>
                <Icon name="plus-circle" size={24} color={departmentColor} />
              </View>
              <Text style={styles.actionText}>Add New</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.actionButton}>
              <View style={[styles.actionIcon, { backgroundColor: `${departmentColor}15` }]}>
                <Icon name="chart-bar" size={24} color={departmentColor} />
              </View>
              <Text style={styles.actionText}>View Reports</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.actionButton}>
              <View style={[styles.actionIcon, { backgroundColor: `${departmentColor}15` }]}>
                <Icon name="cog" size={24} color={departmentColor} />
              </View>
              <Text style={styles.actionText}>Settings</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.actionButton}>
              <View style={[styles.actionIcon, { backgroundColor: `${departmentColor}15` }]}>
                <Icon name="download" size={24} color={departmentColor} />
              </View>
              <Text style={styles.actionText}>Export Data</Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* Department Info */}
        <View style={styles.infoContainer}>
          <Text style={styles.infoTitle}>About {department} Department</Text>
          <Text style={styles.infoText}>
            This department manages all {department.toLowerCase()} related operations. 
            You have access to specific permissions based on your role and responsibilities. 
            Contact your administrator for additional access requirements.
          </Text>
          
          <View style={styles.infoFooter}>
            <View style={styles.infoItem}>
              <Icon name="clock-outline" size={16} color="#64748B" />
              <Text style={styles.infoItemText}>Last updated: Today</Text>
            </View>
            <View style={styles.infoItem}>
              <Icon name="account-supervisor" size={16} color="#64748B" />
              <Text style={styles.infoItemText}>Managed by: Admin</Text>
            </View>
          </View>
        </View>
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F8FAFC',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 20,
    backgroundColor: '#FFFFFF',
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  backButton: {
    padding: 8,
    marginRight: 12,
  },
  headerTitleContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
  },
  departmentIcon: {
    width: 40,
    height: 40,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: '#1E293B',
  },
  headerSubtitle: {
    fontSize: 12,
    color: '#64748B',
    marginTop: 2,
  },
  menuButton: {
    padding: 8,
  },
  scrollContent: {
    paddingHorizontal: 20,
    paddingBottom: 40,
  },
  overviewContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 20,
    marginTop: 20,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  overviewTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 8,
  },
  overviewText: {
    fontSize: 14,
    color: '#64748B',
    lineHeight: 20,
    marginBottom: 20,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
  },
  statItem: {
    alignItems: 'center',
    flex: 1,
  },
  statValue: {
    fontSize: 24,
    fontWeight: '700',
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 12,
    color: '#64748B',
  },
  statDivider: {
    width: 1,
    height: 40,
    backgroundColor: '#E2E8F0',
  },
  categoriesContainer: {
    marginTop: 24,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 16,
  },
  categoriesScroll: {
    marginBottom: 20,
  },
  categoryTab: {
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
    backgroundColor: '#F1F5F9',
    marginRight: 12,
    borderWidth: 2,
    borderColor: 'transparent',
    alignItems: 'center',
  },
  categoryTabActive: {
    backgroundColor: '#FFFFFF',
    borderWidth: 2,
  },
  categoryTabText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#64748B',
  },
  categoryTabTextActive: {
    fontWeight: '600',
  },
  permissionCount: {
    marginTop: 4,
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 4,
    backgroundColor: '#F1F5F9',
  },
  permissionCountText: {
    fontSize: 11,
    color: '#64748B',
    fontWeight: '500',
  },
  categoryContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 20,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  categoryTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 16,
  },
  permissionItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#F1F5F9',
  },
  permissionIconContainer: {
    width: 32,
    marginRight: 12,
  },
  permissionText: {
    flex: 1,
    fontSize: 14,
    color: '#1E293B',
  },
  permissionDisabled: {
    color: '#94A3B8',
  },
  permissionBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 4,
    backgroundColor: '#D1FAE5',
  },
  permissionBadgeDisabled: {
    backgroundColor: '#FEE2E2',
  },
  permissionBadgeText: {
    fontSize: 11,
    fontWeight: '500',
    color: '#065F46',
  },
  actionsContainer: {
    marginTop: 24,
  },
  actionsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  actionButton: {
    width: '48%',
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  actionIcon: {
    width: 48,
    height: 48,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 12,
  },
  actionText: {
    fontSize: 13,
    color: '#475569',
    fontWeight: '500',
  },
  infoContainer: {
    marginTop: 24,
    backgroundColor: '#FAF5FF', // Light purple
    borderRadius: 12,
    padding: 20,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  infoTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#C084FC', // Purple
    marginBottom: 12,
  },
  infoText: {
    fontSize: 14,
    color: '#6B21A8',
    lineHeight: 20,
    marginBottom: 16,
  },
  infoFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  infoItem: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  infoItemText: {
    fontSize: 12,
    color: '#7E22CE',
    marginLeft: 6,
  },
});

export default DepartmentScreen;
========================================
FILE: src/screens/dashboard/MainDashboardScreen.tsx
========================================

import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  RefreshControl,
  Dimensions,
  Alert,
} from 'react-native';
import { useNavigation, useFocusEffect } from '@react-navigation/native';
import { useQuery } from '@tanstack/react-query';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';

import { useAuth } from '@/contexts/AuthContext';
import { api } from '@/services/api';
import { useToast } from '@/components/Toast';
import DepartmentCard from '@/components/DepartmentCard';
import StatsOverview from '@/components/StatsOverview';

const { width } = Dimensions.get('window');

// Define navigation types
type MainDashboardScreenNavigationProp = {
  navigate: (screen: string, params?: any) => void;
  openDrawer: () => void;
  reset: (state: any) => void;
};

const MainDashboardScreen: React.FC = () => {
  const navigation = useNavigation<MainDashboardScreenNavigationProp>();
  const { adminInfo, logout, validateSession, clearTokensAndNavigate } = useAuth();
  const { showToast } = useToast();

  const [refreshing, setRefreshing] = useState(false);
  const [dailyQuota, setDailyQuota] = useState({
    limit: 0,
    remaining: 0,
    used: 0,
  });
  const [isSessionValidated, setIsSessionValidated] = useState(false);
  const [isCheckingSession, setIsCheckingSession] = useState(true);

  // Validate session on component mount
  useEffect(() => {
    const validateSessionOnMount = async () => {
      try {
        console.log('🔍 [DASHBOARD] Validating session on mount...');
        setIsCheckingSession(true);
        const isValid = await validateSession();
        
        if (!isValid) {
          console.log('❌ [DASHBOARD] Session invalid on mount');
          showToast('error', 'Session expired. Please login with MPIN.');
          
          // Clear tokens and navigate to VerifyMPIN
          await clearTokensAndNavigate();
          
          // Navigate to VerifyMPIN
          navigation.reset({
            index: 0,
            routes: [{ name: 'VerifyMPIN' }],
          });
        } else {
          console.log('✅ [DASHBOARD] Session validated on mount');
          setIsSessionValidated(true);
        }
      } catch (error) {
        console.error('❌ [DASHBOARD] Session validation error on mount:', error);
        showToast('error', 'Session validation failed. Please login again.');
        await clearTokensAndNavigate();
        navigation.reset({
          index: 0,
          routes: [{ name: 'VerifyMPIN' }],
        });
      } finally {
        setIsCheckingSession(false);
      }
    };

    validateSessionOnMount();
  }, [validateSession, clearTokensAndNavigate, showToast, navigation]);

  // Validate session when screen comes into focus
  useFocusEffect(
    useCallback(() => {
      const validateOnFocus = async () => {
        if (isSessionValidated) {
          try {
            console.log('🔍 [DASHBOARD] Validating session on focus...');
            const isValid = await validateSession();
            
            if (!isValid) {
              console.log('❌ [DASHBOARD] Session invalid on focus');
              showToast('error', 'Session expired. Please login with MPIN.');
              
              // Use the new function instead of logout
              await clearTokensAndNavigate();
              
              // Navigate to VerifyMPIN
              navigation.reset({
                index: 0,
                routes: [{ name: 'VerifyMPIN' }],
              });
            }
          } catch (error) {
            console.error('❌ [DASHBOARD] Session validation error on focus:', error);
            showToast('error', 'Session validation failed. Please login again.');
            await clearTokensAndNavigate();
            navigation.reset({
              index: 0,
              routes: [{ name: 'VerifyMPIN' }],
            });
          }
        }
      };

      validateOnFocus();
    }, [validateSession, clearTokensAndNavigate, showToast, isSessionValidated, navigation])
  );

  const { data: profileData, refetch, isLoading: profileLoading } = useQuery({
    queryKey: ['adminProfile'],
    queryFn: () => api.getAdminProfile(),
    enabled: !!adminInfo && isSessionValidated && !isCheckingSession,
  });

  useEffect(() => {
    if (profileData?.data?.daily_quota) {
      setDailyQuota(profileData.data.daily_quota);
    }
  }, [profileData]);

  const handleRefresh = async () => {
    setRefreshing(true);
    await refetch();
    setRefreshing(false);
  };

  const handleDepartmentPress = (department: string) => {
    navigation.navigate('Department', { department });
  };

  const handleLogout = () => {
    Alert.alert(
      'Logout',
      'Are you sure you want to logout?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Logout',
          style: 'destructive',
          onPress: async () => {
            await logout();
            showToast('success', 'Logged out successfully');
            
            // Navigate to VerifyMPIN after logout
            navigation.reset({
              index: 0,
              routes: [{ name: 'VerifyMPIN' }],
            });
          },
        },
      ],
    );
  };

  // Show loading while validating session
  if (isCheckingSession || !isSessionValidated) {
    return (
      <View style={styles.loadingContainer}>
        <Icon name="shield-check" size={60} color="#C084FC" />
        <Text style={styles.loadingText}>Validating session...</Text>
      </View>
    );
  }

  const departments: string[] = adminInfo?.departments || [];

  const categorizedDepartments: Record<string, string[]> = {
    'Core Operations': departments.filter(dept =>
      ['HR', 'Finance', 'Accounting', 'Procurement', 'Inventory'].includes(dept),
    ),
    'Business Units': departments.filter(dept =>
      ['Sales', 'Marketing', 'Customer Support', 'Operations'].includes(dept),
    ),
    'Technical & Quality': departments.filter(dept =>
      ['IT', 'Production', 'Quality Control', 'Quality Assurance', 'R&D'].includes(dept),
    ),
    Administration: departments.filter(dept =>
      [
        'Administration',
        'Employee Management',
        'Manager Management',
        'Company Management',
        'Super Admin Management',
      ].includes(dept),
    ),
  };

  return (
    <View style={styles.container}>
      {/* ================= Header ================= */}
      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => {
            navigation.openDrawer();
          }}
          style={styles.menuButton}
        >
          <Icon name="menu" size={24} color="#333" />
        </TouchableOpacity>

        <View style={styles.headerTitleContainer}>
          <Text style={styles.headerTitle}>Dashboard</Text>
          <Text style={styles.headerSubtitle}>
            Welcome back, {adminInfo?.full_name || 'Admin'}
          </Text>
        </View>

        <TouchableOpacity
          onPress={() => navigation.navigate('Profile')}
          style={styles.profileButton}
        >
          <Icon name="account-circle" size={32} color="#C084FC" />
        </TouchableOpacity>
      </View>

      {/* ================= Content ================= */}
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={['#C084FC']}
            tintColor="#C084FC"
          />
        }
        showsVerticalScrollIndicator={false}
      >
        <StatsOverview
          dailyQuota={dailyQuota}
          permissions={adminInfo?.permissions?.length || 0}
          departments={departments.length}
          isLoading={profileLoading}
        />

        {/* ================= Quick Actions ================= */}
        <View style={styles.actionsContainer}>
          <Text style={styles.sectionTitle}>Quick Actions</Text>
          <View style={styles.actionsGrid}>
            <TouchableOpacity 
              style={styles.actionButton}
              onPress={() => navigation.navigate('ChangeMPIN')}
            >
              <View style={styles.iconContainer}>
                <Icon name="key-change" size={24} color="#C084FC" />
              </View>
              <Text style={styles.actionLabel}>Change MPIN</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.actionButton}>
              <View style={styles.iconContainer}>
                <Icon name="file-document" size={24} color="#C084FC" />
              </View>
              <Text style={styles.actionLabel}>Reports</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.actionButton}>
              <View style={styles.iconContainer}>
                <Icon name="calendar-clock" size={24} color="#C084FC" />
              </View>
              <Text style={styles.actionLabel}>Attendance</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.actionButton}>
              <View style={styles.iconContainer}>
                <Icon name="chart-bar" size={24} color="#C084FC" />
              </View>
              <Text style={styles.actionLabel}>Analytics</Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* ================= Departments ================= */}
        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Departments</Text>
            <Text style={styles.sectionSubtitle}>
              {departments.length} departments available
            </Text>
          </View>

          {Object.entries(categorizedDepartments).map(([category, depts]) => {
            if (depts.length === 0) return null;

            return (
              <View key={category} style={styles.categorySection}>
                <Text style={styles.categoryTitle}>{category}</Text>
                <View style={styles.departmentsGrid}>
                  {depts.map((department, index) => (
                    <DepartmentCard
                      key={department}
                      department={department}
                      index={index}
                      onPress={() => handleDepartmentPress(department)}
                    />
                  ))}
                </View>
              </View>
            );
          })}
        </View>

        {/* ================= Daily Quota ================= */}
        {dailyQuota.limit > 0 && (
          <View style={styles.quotaContainer}>
            <View style={styles.quotaHeader}>
              <Icon name="chart-bar" size={20} color="#C084FC" />
              <Text style={styles.quotaTitle}>Daily API Quota</Text>
            </View>

            <View style={styles.quotaBar}>
              <View
                style={[
                  styles.quotaFill,
                  { width: `${(dailyQuota.used / dailyQuota.limit) * 100}%` },
                ]}
              />
            </View>

            <View style={styles.quotaInfo}>
              <Text style={styles.quotaText}>
                {dailyQuota.used} / {dailyQuota.limit} requests used
              </Text>
              <Text style={styles.quotaText}>
                {dailyQuota.remaining} remaining
              </Text>
            </View>
          </View>
        )}

        {/* ================= Footer ================= */}
        <View style={styles.footer}>
          <TouchableOpacity onPress={handleLogout} style={styles.logoutButton}>
            <Icon name="logout" size={20} color="#DC2626" />
            <Text style={styles.logoutText}>Logout</Text>
          </TouchableOpacity>

          <Text style={styles.versionText}>Prayantra v1.0.0</Text>
        </View>
      </ScrollView>
    </View>
  );
};

export default MainDashboardScreen;

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#F8FAFC' },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F8FAFC',
  },
  loadingText: {
    fontSize: 16,
    color: '#64748B',
    marginTop: 20,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 20,
    backgroundColor: '#FFFFFF',
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  menuButton: {
    padding: 8,
    marginRight: 12,
  },
  headerTitleContainer: { flex: 1 },
  headerTitle: {
    fontSize: 22,
    fontWeight: '700',
    color: '#1E293B',
  },
  headerSubtitle: {
    fontSize: 13,
    color: '#64748B',
    marginTop: 2,
  },
  profileButton: { padding: 8 },
  scrollContent: {
    paddingHorizontal: 20,
    paddingBottom: 40,
  },
  actionsContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginTop: 16,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  actionsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  actionButton: {
    width: '48%',
    alignItems: 'center',
    marginBottom: 16,
  },
  iconContainer: {
    width: 56,
    height: 56,
    borderRadius: 12,
    backgroundColor: '#FAF5FF',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 8,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  actionLabel: {
    fontSize: 13,
    color: '#475569',
    textAlign: 'center',
  },
  section: { marginTop: 24 },
  sectionHeader: { marginBottom: 16 },
  sectionTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#1E293B',
  },
  sectionSubtitle: {
    fontSize: 14,
    color: '#64748B',
    marginTop: 4,
  },
  categorySection: { marginBottom: 24 },
  categoryTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#475569',
    marginBottom: 12,
  },
  departmentsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -6,
  },
  quotaContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginTop: 24,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  quotaHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  quotaTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
    marginLeft: 8,
  },
  quotaBar: {
    height: 8,
    backgroundColor: '#E2E8F0',
    borderRadius: 4,
    overflow: 'hidden',
    marginBottom: 8,
  },
  quotaFill: {
    height: '100%',
    backgroundColor: '#C084FC',
    borderRadius: 4,
  },
  quotaInfo: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  quotaText: {
    fontSize: 13,
    color: '#64748B',
  },
  footer: {
    marginTop: 32,
    alignItems: 'center',
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    backgroundColor: '#FEF2F2',
    marginBottom: 16,
  },
  logoutText: {
    color: '#DC2626',
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 8,
  },
  versionText: {
    fontSize: 12,
    color: '#94A3B8',
  },
});
========================================
FILE: src/screens/profile/ChangeMPINScreen.tsx
========================================

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { useNavigation, NavigationProp } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { api } from '@/services/api';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';
import MPINInput from '@/components/MPINInput';
import { getItem } from '@/services/storage';

// Define navigation types
type RootStackParamList = {
  MainDrawer: undefined;
  ChangeMPIN: undefined;
};

const ChangeMPINScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const { adminInfo, logout } = useAuth();
  const { showToast } = useToast();

  const [currentMpin, setCurrentMpin] = useState('');
  const [newMpin, setNewMpin] = useState('');
  const [confirmMpin, setConfirmMpin] = useState('');
  const [step, setStep] = useState(1); // 1: Current MPIN, 2: New MPIN, 3: Confirm MPIN
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const changeMPINMutation = useMutation({
    mutationFn: (data: { currentMpin: string; newMpin: string }) => 
      api.changeMPIN(adminInfo?.admin_id || '', data.currentMpin, data.newMpin),
    onSuccess: () => {
      showToast('success', 'MPIN changed successfully');
      
      // Logout user for security
      Alert.alert(
        'MPIN Changed',
        'For security reasons, please login with your new MPIN.',
        [
          {
            text: 'OK',
            onPress: async () => {
              await logout();
            }
          }
        ]
      );
    },
    onError: (error: any) => {
      const errorType = error.response?.data?.error;
      const errorMessage = error.response?.data?.message || 'Failed to change MPIN';

      if (errorType === 'invalid admin MPIN') {
        setError('Current MPIN is incorrect');
        setStep(1);
        setCurrentMpin('');
        setNewMpin('');
        setConfirmMpin('');
      } else if (errorType === 'admin MPIN is too weak') {
        setError('New MPIN is too weak. Please choose a stronger MPIN.');
        setStep(2);
        setNewMpin('');
        setConfirmMpin('');
      } else {
        showToast('error', errorMessage);
        setStep(1);
        setCurrentMpin('');
        setNewMpin('');
        setConfirmMpin('');
      }
    },
    onSettled: () => {
      setIsLoading(false);
    },
  });

  const handleMPINComplete = (enteredMpin: string) => {
    if (step === 1) {
      // Verify current MPIN
      setCurrentMpin(enteredMpin);
      setError('');
      setStep(2);
    } else if (step === 2) {
      // Validate new MPIN
      if (isWeakMpin(enteredMpin)) {
        setError('MPIN is too weak. Please choose a stronger MPIN.');
        return;
      }

      if (enteredMpin === currentMpin) {
        setError('New MPIN cannot be same as current MPIN');
        return;
      }

      setNewMpin(enteredMpin);
      setError('');
      setStep(3);
    } else {
      // Confirm new MPIN
      if (enteredMpin === newMpin) {
        setIsLoading(true);
        changeMPINMutation.mutate({
          currentMpin,
          newMpin: enteredMpin
        });
      } else {
        setError('MPIN does not match. Please try again.');
        setStep(2);
        setNewMpin('');
        setConfirmMpin('');
      }
    }
  };

  const isWeakMpin = (mpin: string) => {
    const weakPatterns = [
      '111111', '222222', '333333', '444444', '555555',
      '666666', '777777', '888888', '999999', '000000',
      '123456', '654321', '121212', '123123', '112233'
    ];
    return weakPatterns.includes(mpin) || 
           mpin.split('').every((digit, i, arr) => digit === arr[0]);
  };

  const handleBack = () => {
    if (step === 1) {
      navigation.goBack();
    } else if (step === 2) {
      setStep(1);
      setCurrentMpin('');
      setError('');
    } else if (step === 3) {
      setStep(2);
      setNewMpin('');
      setConfirmMpin('');
      setError('');
    }
  };

  const getStepTitle = () => {
    switch (step) {
      case 1: return 'Enter Current MPIN';
      case 2: return 'Enter New MPIN';
      case 3: return 'Confirm New MPIN';
      default: return 'Change MPIN';
    }
  };

  const getStepInstruction = () => {
    switch (step) {
      case 1: return 'Enter your current 6-digit MPIN';
      case 2: return 'Create a new 6-digit MPIN';
      case 3: return 'Re-enter the new MPIN to confirm';
      default: return '';
    }
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Change MPIN</Text>
          <Text style={styles.headerSubtitle}>Update your secure login PIN</Text>
        </View>

        <View style={styles.formContainer}>
          <View style={styles.stepIndicator}>
            <View style={[styles.step, step >= 1 && styles.activeStep]}>
              <Text style={[styles.stepText, step >= 1 && styles.activeStepText]}>1</Text>
            </View>
            <View style={styles.stepLine} />
            <View style={[styles.step, step >= 2 && styles.activeStep]}>
              <Text style={[styles.stepText, step >= 2 && styles.activeStepText]}>2</Text>
            </View>
            <View style={styles.stepLine} />
            <View style={[styles.step, step >= 3 && styles.activeStep]}>
              <Text style={[styles.stepText, step >= 3 && styles.activeStepText]}>3</Text>
            </View>
          </View>

          <Text style={styles.title}>{getStepTitle()}</Text>
          <Text style={styles.subtitle}>{getStepInstruction()}</Text>

          <View style={styles.mpinContainer}>
            <MPINInput
              onComplete={handleMPINComplete}
              error={!!error}
              disabled={isLoading}
              autoFocus={true}
            />
          </View>

          {error ? (
            <View style={styles.errorContainer}>
              <Text style={styles.errorText}>{error}</Text>
            </View>
          ) : (
            <View style={styles.guidelinesContainer}>
              <Text style={styles.guidelinesTitle}>
                {step === 1 ? 'Verification:' : 'MPIN Guidelines:'}
              </Text>
              {step === 1 ? (
                <>
                  <Text style={styles.guideline}>• Enter your current MPIN</Text>
                  <Text style={styles.guideline}>• This verifies your identity</Text>
                  <Text style={styles.guideline}>• Make sure no one is watching</Text>
                </>
              ) : step === 2 ? (
                <>
                  <Text style={styles.guideline}>• Must be 6 digits</Text>
                  <Text style={styles.guideline}>• Avoid simple patterns</Text>
                  <Text style={styles.guideline}>• Don't use repeated digits</Text>
                  <Text style={styles.guideline}>• Different from current MPIN</Text>
                </>
              ) : (
                <>
                  <Text style={styles.guideline}>• Re-enter the new MPIN</Text>
                  <Text style={styles.guideline}>• Make sure it matches exactly</Text>
                  <Text style={styles.guideline}>• You'll be logged out after change</Text>
                  <Text style={styles.guideline}>• Login with new MPIN</Text>
                </>
              )}
            </View>
          )}

          {isLoading && (
            <View style={styles.loadingContainer}>
              <Text style={styles.loadingText}>
                {step === 3 ? 'Changing MPIN...' : 'Verifying...'}
              </Text>
            </View>
          )}

          <TouchableOpacity
            style={styles.backButton}
            onPress={handleBack}
            disabled={isLoading}
          >
            <Text style={styles.backButtonText}>
              ← {step === 1 ? 'Cancel' : 'Back'}
            </Text>
          </TouchableOpacity>
        </View>

        <View style={styles.securityInfo}>
          <Text style={styles.securityTitle}>Important Security Notes:</Text>
          <Text style={styles.securityText}>
            • You will be automatically logged out after MPIN change
            {'\n'}• Login immediately with your new MPIN
            {'\n'}• Never share your MPIN with anyone
            {'\n'}• Choose a MPIN you can remember but others can't guess
            {'\n'}• You can reset MPIN anytime from login screen
          </Text>
        </View>

        <View style={styles.userInfo}>
          <Text style={styles.userInfoText}>
            Changing MPIN for: {adminInfo?.full_name || 'Admin'}
          </Text>
          <Text style={styles.userInfoText}>
            Username: {adminInfo?.username || 'N/A'}
          </Text>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 40,
  },
  header: {
    marginBottom: 24,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: '700',
    color: '#1E293B',
    marginBottom: 4,
  },
  headerSubtitle: {
    fontSize: 14,
    color: '#64748B',
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
    marginBottom: 24,
  },
  stepIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 32,
  },
  step: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#E2E8F0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  activeStep: {
    backgroundColor: '#1565C0',
  },
  stepText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#64748B',
  },
  activeStepText: {
    color: '#FFFFFF',
  },
  stepLine: {
    width: 30,
    height: 2,
    backgroundColor: '#E2E8F0',
    marginHorizontal: 4,
  },
  title: {
    fontSize: 20,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 32,
    textAlign: 'center',
    lineHeight: 20,
  },
  mpinContainer: {
    marginBottom: 24,
  },
  errorContainer: {
    backgroundColor: '#FEF2F2',
    padding: 16,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#FECACA',
  },
  errorText: {
    color: '#DC2626',
    fontSize: 14,
    textAlign: 'center',
  },
  guidelinesContainer: {
    backgroundColor: '#F0F9FF',
    padding: 16,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#BAE6FD',
  },
  guidelinesTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#0369A1',
    marginBottom: 8,
  },
  guideline: {
    fontSize: 13,
    color: '#475569',
    marginBottom: 4,
    lineHeight: 18,
  },
  loadingContainer: {
    marginBottom: 24,
  },
  loadingText: {
    color: '#64748B',
    fontSize: 14,
    textAlign: 'center',
  },
  backButton: {
    alignItems: 'center',
    paddingVertical: 12,
  },
  backButtonText: {
    color: '#1565C0',
    fontSize: 14,
    fontWeight: '500',
  },
  securityInfo: {
    backgroundColor: '#FEF3C7',
    padding: 16,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#FDE68A',
  },
  securityTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#D97706',
    marginBottom: 8,
  },
  securityText: {
    fontSize: 12,
    color: '#92400E',
    lineHeight: 18,
  },
  userInfo: {
    backgroundColor: '#F1F5F9',
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  userInfoText: {
    fontSize: 13,
    color: '#475569',
    marginBottom: 4,
  },
});

export default ChangeMPINScreen;
========================================
FILE: src/screens/profile/ProfileScreen.tsx
========================================

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Alert,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';

type IconName = React.ComponentProps<typeof Icon>['name'];

const ProfileScreen = () => {
  const navigation = useNavigation();
  const { adminInfo, logout } = useAuth();
  const { showToast } = useToast();

  const getRoleColor = (role: string) => {
    switch (role) {
      case 'super_admin':
        return '#C084FC';
      case 'admin':
        return '#8B5CF6';
      case 'manager':
        return '#7C3AED';
      case 'employee':
        return '#6D28D9';
      default:
        return '#9333EA';
    }
  };

  const getRoleName = (role: string) => {
    switch (role) {
      case 'super_admin':
        return 'Super Administrator';
      case 'admin':
        return 'Administrator';
      case 'manager':
        return 'Manager';
      case 'employee':
        return 'Employee';
      default:
        return role;
    }
  };

  const getDepartmentIcon = (department: string): IconName => {
    const icons: Record<string, IconName> = {
      'HR': 'account-group',
      'Finance': 'cash',
      'Accounting': 'calculator',
      'Procurement': 'cart',
      'Inventory': 'warehouse',
      'Logistics': 'truck',
      'Sales': 'chart-line',
      'Marketing': 'bullhorn',
      'Customer Support': 'headset',
      'Operations': 'cog',
      'IT': 'desktop-classic',
      'Production': 'factory',
      'Quality Control': 'check-circle',
      'Quality Assurance': 'shield-check',
      'R&D': 'flask',
      'Administration': 'office-building',
      'Employee Management': 'account-multiple',
      'Manager Management': 'account-tie',
      'Company Management': 'domain',
      'Super Admin Management': 'security',
    };
    return icons[department] || 'folder';
  };

  const departmentColors = [
    '#C084FC', '#A855F7', '#9333EA', '#7C3AED', '#6D28D9',
    '#5B21B6', '#4C1D95', '#3B0764', '#7E22CE', '#6B21A8'
  ];

  const getDepartmentColor = (index: number) => {
    return departmentColors[index % departmentColors.length];
  };

  const handleLogout = () => {
    Alert.alert(
      'Logout',
      'Are you sure you want to logout?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Logout',
          style: 'destructive',
          onPress: async () => {
            await logout();
            showToast('success', 'Logged out successfully');
            // @ts-ignore
            navigation.navigate('LoginInitiate');
          },
        },
      ],
    );
  };

  return (
    <ScrollView style={styles.container} showsVerticalScrollIndicator={false}>
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => {
            // @ts-ignore
            navigation.openDrawer();
          }}
          style={styles.backButton}
        >
          <Icon name="arrow-left" size={24} color="#333" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Profile</Text>
        <View style={{ width: 40 }} />
      </View>

      {/* Profile Card */}
      <View style={styles.profileCard}>
        <View style={styles.avatarContainer}>
          <Icon name="account-circle" size={80} color="#C084FC" />
          <View style={[styles.roleBadge, { backgroundColor: getRoleColor(adminInfo?.role_string || 'admin') }]}>
            <Text style={styles.roleBadgeText}>
              {getRoleName(adminInfo?.role_string || 'admin')}
            </Text>
          </View>
        </View>

        <Text style={styles.name}>{adminInfo?.full_name || 'Admin User'}</Text>
        <Text style={styles.username}>@{adminInfo?.username || 'admin'}</Text>

        <View style={styles.infoGrid}>
          <View style={styles.infoItem}>
            <Icon name="office-building" size={20} color="#C084FC" />
            <Text style={styles.infoLabel}>Departments</Text>
            <Text style={styles.infoValue}>{adminInfo?.departments?.length || 0}</Text>
          </View>
          
          <View style={styles.infoItem}>
            <Icon name="shield-check" size={20} color="#C084FC" />
            <Text style={styles.infoLabel}>Permissions</Text>
            <Text style={styles.infoValue}>{adminInfo?.permissions?.length || 0}</Text>
          </View>
          
          <View style={styles.infoItem}>
            <Icon name="account-check" size={20} color="#C084FC" />
            <Text style={styles.infoLabel}>Status</Text>
            <Text style={styles.infoValue}>
              {adminInfo?.is_active ? 'Active' : 'Inactive'}
            </Text>
          </View>
        </View>
      </View>

      {/* Departments Section */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Departments</Text>
        <View style={styles.departmentsGrid}>
          {adminInfo?.departments?.map((dept, index) => (
            <View key={dept} style={styles.departmentTag}>
              <Icon 
                name={getDepartmentIcon(dept)} 
                size={16} 
                color={getDepartmentColor(index)} 
                style={styles.departmentIcon}
              />
              <Text style={styles.departmentText}>{dept}</Text>
            </View>
          ))}
        </View>
      </View>

      {/* Actions Section */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Account Actions</Text>
        
        <TouchableOpacity
          style={styles.actionButton}
          onPress={() => navigation.navigate('ChangeMPIN' as never)}
        >
          <View style={[styles.actionIcon, { backgroundColor: '#F5F3FF' }]}>
            <Icon name="key-change" size={24} color="#C084FC" />
          </View>
          <View style={styles.actionContent}>
            <Text style={styles.actionTitle}>Change MPIN</Text>
            <Text style={styles.actionSubtitle}>Update your secure login PIN</Text>
          </View>
          <Icon name="chevron-right" size={20} color="#CBD5E1" />
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.actionButton}
          onPress={handleLogout}
        >
          <View style={[styles.actionIcon, { backgroundColor: '#FEF2F2' }]}>
            <Icon name="logout" size={24} color="#EF4444" />
          </View>
          <View style={styles.actionContent}>
            <Text style={[styles.actionTitle, { color: '#EF4444' }]}>Logout</Text>
            <Text style={styles.actionSubtitle}>Sign out from your account</Text>
          </View>
          <Icon name="chevron-right" size={20} color="#CBD5E1" />
        </TouchableOpacity>
      </View>

      {/* Permissions Section (Collapsible) */}
      {adminInfo?.permissions && adminInfo.permissions.length > 0 && (
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>
            Permissions ({adminInfo.permissions.length})
          </Text>
          <View style={styles.permissionsGrid}>
            {adminInfo.permissions.slice(0, 20).map((permission, index) => (
              <View key={index} style={styles.permissionTag}>
                <Text style={styles.permissionText}>{permission}</Text>
              </View>
            ))}
            {adminInfo.permissions.length > 20 && (
              <Text style={styles.moreText}>
                +{adminInfo.permissions.length - 20} more permissions
              </Text>
            )}
          </View>
        </View>
      )}

      {/* Footer */}
      <View style={styles.footer}>
        <Text style={styles.footerText}>Prayantra Admin Dashboard</Text>
        <Text style={styles.versionText}>Version 1.0.0</Text>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F8FAFC',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 20,
    backgroundColor: '#FFFFFF',
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  backButton: {
    padding: 8,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: '#1E293B',
  },
  profileCard: {
    backgroundColor: '#FFFFFF',
    marginHorizontal: 20,
    marginTop: 20,
    borderRadius: 16,
    padding: 24,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  avatarContainer: {
    alignItems: 'center',
    marginBottom: 16,
  },
  roleBadge: {
    marginTop: 8,
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 12,
  },
  roleBadgeText: {
    fontSize: 12,
    fontWeight: '600',
    color: '#FFFFFF',
  },
  name: {
    fontSize: 24,
    fontWeight: '700',
    color: '#1E293B',
    marginBottom: 4,
  },
  username: {
    fontSize: 14,
    color: '#64748B',
    marginBottom: 24,
  },
  infoGrid: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
    marginTop: 16,
  },
  infoItem: {
    alignItems: 'center',
    flex: 1,
  },
  infoLabel: {
    fontSize: 12,
    color: '#64748B',
    marginTop: 8,
    marginBottom: 4,
  },
  infoValue: {
    fontSize: 16,
    fontWeight: '700',
    color: '#1E293B',
  },
  section: {
    backgroundColor: '#FFFFFF',
    marginHorizontal: 20,
    marginTop: 16,
    borderRadius: 16,
    padding: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 16,
  },
  departmentsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -4,
  },
  departmentTag: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F8FAFC',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 20,
    margin: 4,
  },
  departmentIcon: {
    marginRight: 6,
  },
  departmentText: {
    fontSize: 12,
    color: '#475569',
    fontWeight: '500',
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#F1F5F9',
  },
  actionIcon: {
    width: 48,
    height: 48,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 16,
  },
  actionContent: {
    flex: 1,
  },
  actionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 4,
  },
  actionSubtitle: {
    fontSize: 12,
    color: '#64748B',
  },
  permissionsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -4,
  },
  permissionTag: {
    backgroundColor: '#F5F3FF',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 12,
    margin: 4,
  },
  permissionText: {
    fontSize: 11,
    color: '#6D28D9',
    fontWeight: '500',
  },
  moreText: {
    fontSize: 12,
    color: '#64748B',
    fontStyle: 'italic',
    marginTop: 8,
    textAlign: 'center',
    width: '100%',
  },
  footer: {
    alignItems: 'center',
    marginTop: 40,
    marginBottom: 40,
  },
  footerText: {
    fontSize: 14,
    color: '#64748B',
    marginBottom: 8,
  },
  versionText: {
    fontSize: 12,
    color: '#94A3B8',
  },
});

export default ProfileScreen;
========================================
FILE: src/services/api.ts
========================================

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
} from 'axios';
import { Platform } from 'react-native';
import { getItem, setItem, removeItem, STORAGE_KEYS } from './storage';
import { getStoredDeviceInfo } from './deviceInfo';
import { ApiError } from '@/types';

/* ============================================================
   API CONFIG
   ============================================================ */

const API_BASE_URL = 'http://192.168.31.102:8080/api/v1';
const API_TIMEOUT = 30000;

/* ============================================================
   API SERVICE (SINGLETON)
   ============================================================ */

class ApiService {
  private static instance: ApiService;
  private api: AxiosInstance;

  private isRefreshing = false;
  private failedQueue: Array<{
    resolve: (value?: unknown) => void;
    reject: (reason?: unknown) => void;
  }> = [];

  private constructor() {
    this.api = axios.create({
      baseURL: API_BASE_URL,
      timeout: API_TIMEOUT,
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
        'X-Platform': Platform.OS,
        'X-App-Version': '1.0.0',
      },
    });

    this.setupInterceptors();
  }

  static getInstance(): ApiService {
    if (!ApiService.instance) {
      ApiService.instance = new ApiService();
    }
    return ApiService.instance;
  }

  /* ============================================================
     INTERCEPTORS
     ============================================================ */

  private setupInterceptors() {
    /* ---------------- REQUEST ---------------- */
    this.api.interceptors.request.use(
      async (config) => {
        const token = await getItem(STORAGE_KEYS.ACCESS_TOKEN);

        if (token) {
          (config.headers as any).Authorization = `Bearer ${token}`;
        }

        // Attach device info to auth / otp requests
        if (config.url?.includes('/auth') || config.url?.includes('/otp')) {
          const device = await getStoredDeviceInfo();

          if (config.method !== 'get' && config.data) {
            config.data.device_id = device.deviceId;
            config.data.device_fingerprint = device.deviceFingerprint;
            config.data.user_agent = device.userAgent;
          }
        }

        return config;
      },
      (error) => Promise.reject(error),
    );

    /* ---------------- RESPONSE ---------------- */
    this.api.interceptors.response.use(
      (response: AxiosResponse) => response,
      async (error: AxiosError<ApiError>) => {
        const originalRequest = error.config as AxiosRequestConfig & {
          _retry?: boolean;
        };

        /* ---------- RATE LIMIT ---------- */
        if (error.response?.status === 429) {
          const retryAfter = error.response.data?.retry_after || 5;
          await new Promise((r) => setTimeout(r, retryAfter * 1000));
          return this.api(originalRequest);
        }

        /* ---------- UNAUTHORIZED ---------- */
        if (error.response?.status === 401 && !originalRequest._retry) {
          if (this.isRefreshing) {
            return new Promise((resolve, reject) => {
              this.failedQueue.push({ resolve, reject });
            }).then(() => this.api(originalRequest));
          }

          originalRequest._retry = true;
          this.isRefreshing = true;

          try {
            const refreshToken = await getItem(STORAGE_KEYS.REFRESH_TOKEN);
            if (!refreshToken) throw new Error('No refresh token');

            const response = await this.refreshToken(refreshToken);
            const newAccessToken = response.data.access_token;

            await setItem(STORAGE_KEYS.ACCESS_TOKEN, newAccessToken);
            await setItem(STORAGE_KEYS.REFRESH_TOKEN, response.data.refresh_token);

            this.processQueue(null, newAccessToken);

            if (!originalRequest.headers) {
              originalRequest.headers = {};
            }

            (originalRequest.headers as any).Authorization =
              `Bearer ${newAccessToken}`;

            return this.api(originalRequest);
          } catch (refreshError) {
            this.processQueue(refreshError, null);

            await removeItem(STORAGE_KEYS.ACCESS_TOKEN);
            await removeItem(STORAGE_KEYS.REFRESH_TOKEN);
            await removeItem(STORAGE_KEYS.ADMIN_INFO);

            return Promise.reject(refreshError);
          } finally {
            this.isRefreshing = false;
          }
        }

        return Promise.reject(error);
      },
    );
  }

  private processQueue(error: unknown, token: string | null) {
    this.failedQueue.forEach((p) =>
      error ? p.reject(error) : p.resolve(token),
    );
    this.failedQueue = [];
  }

  /* ============================================================
     AUTH APIs
     ============================================================ */

  async loginInitiate(phoneNumber: string) {
    const d = await getStoredDeviceInfo();
    return this.api.post('/admin-auth/login/initiate', {
      phone_number: phoneNumber,
      device_id: d.deviceId,
      device_fingerprint: d.deviceFingerprint,
    });
  }

  async sendOTP(phoneNumber: string, purpose: 'admin_login') {
    const d = await getStoredDeviceInfo();
    return this.api.post('/otp/send', {
      phone_number: phoneNumber,
      purpose,
      device_id: d.deviceId,
      device_fingerprint: d.deviceFingerprint,
      user_agent: d.userAgent,
    });
  }

  async verifyOTP(phoneNumber: string, otp: string) {
    const d = await getStoredDeviceInfo();
    return this.api.post('/admin-auth/login/verify-otp', {
      phone_number: phoneNumber,
      otp,
      device_id: d.deviceId,
      device_fingerprint: d.deviceFingerprint,
      user_agent: d.userAgent,
    });
  }

  async verifyMPIN(phoneNumber: string, mpin: string) {
    const d = await getStoredDeviceInfo();
    return this.api.post('/admin-auth/login/verify-mpin', {
      phone_number: phoneNumber,
      mpin,
      device_id: d.deviceId,
      device_fingerprint: d.deviceFingerprint,
      user_agent: d.userAgent,
    });
  }

  async setupMPIN(adminId: string, mpin: string) {
    const d = await getStoredDeviceInfo();
    return this.api.post('/admin-auth/mpin/setup', {
      admin_id: adminId,
      mpin,
      device_id: d.deviceId,
      device_fingerprint: d.deviceFingerprint,
      user_agent: d.userAgent,
    });
  }

  async validateSession() {
    const d = await getStoredDeviceInfo();
    return this.api.get('/auth/validate', {
      headers: { 'X-Device-ID': d.deviceId },
    });
  }

  async refreshToken(refreshToken: string) {
    return this.api.post('/admin-auth/refresh', {
      refresh_token: refreshToken,
    });
  }

  async logout(refreshToken: string) {
    return this.api.post('/admin-auth/logout', {
      refresh_token: refreshToken,
    });
  }

  /* ============================================================
     ADMIN APIs
     ============================================================ */

  async getAdminProfile() {
    return this.api.get('/admin/profile');
  }

  async changeMPIN(adminId: string, current: string, next: string) {
    const d = await getStoredDeviceInfo();
    return this.api.post('/admin-auth/mpin/change', {
      admin_id: adminId,
      current_mpin: current,
      new_mpin: next,
      device_id: d.deviceId,
      device_fingerprint: d.deviceFingerprint,
      user_agent: d.userAgent,
    });
  }

  async forgotMPIN(phoneNumber: string) {
    const d = await getStoredDeviceInfo();
    return this.api.post('/admin-auth/mpin/forgot', {
      phone_number: phoneNumber,
      device_id: d.deviceId,
      device_fingerprint: d.deviceFingerprint,
      user_agent: d.userAgent,
    });
  }

  async verifyForgotMPIN(phoneNumber: string, otp: string, newMpin: string) {
    const d = await getStoredDeviceInfo();
    return this.api.post('/admin-auth/mpin/forgot/verify', {
      phone_number: phoneNumber,
      otp_code: otp,
      new_mpin: newMpin,
      device_id: d.deviceId,
      device_fingerprint: d.deviceFingerprint,
      user_agent: d.userAgent,
    });
  }
}

/* ============================================================
   EXPORT
   ============================================================ */

export const api = ApiService.getInstance();

// import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';
// import { getItem, setItem, removeItem, STORAGE_KEYS } from './storage';
// import { Platform } from 'react-native';
// import { getStoredDeviceInfo } from './deviceInfo';
// import { AuthTokens, ApiError } from '@/types';

// const API_BASE_URL = 'http://192.168.31.102:8080/api/v1';
// const API_TIMEOUT = 30000;

// class ApiService {
//   private static instance: ApiService;
//   private isRefreshing = false;
//   private failedQueue: Array<{
//     resolve: (value?: unknown) => void;
//     reject: (reason?: unknown) => void;
//   }> = [];

//   private constructor() {
//     this.setupInterceptors();
//   }

//   static getInstance(): ApiService {
//     if (!ApiService.instance) {
//       ApiService.instance = new ApiService();
//     }
//     return ApiService.instance;
//   }

//   private getApi() {
//     return axios.create({
//       baseURL: API_BASE_URL,
//       timeout: API_TIMEOUT,
//       headers: {
//         'Content-Type': 'application/json',
//         'Accept': 'application/json',
//         'X-Platform': Platform.OS,
//         'X-App-Version': '1.0.0',
//       },
//     });
//   }

//   private setupInterceptors() {
//     const api = this.getApi();

//     // Request interceptor - ADDED DEBUG LOGGING
//     api.interceptors.request.use(
//       async (config) => {
//         try {
//           console.log('🔐 [INTERCEPTOR] Request URL:', config.url);
//           console.log('🔐 [INTERCEPTOR] Request Method:', config.method?.toUpperCase());
          
//           const accessToken = await getItem(STORAGE_KEYS.ACCESS_TOKEN);
//           console.log('🔐 [INTERCEPTOR] Access Token Available:', !!accessToken);
//           console.log('🔐 [INTERCEPTOR] Access Token Preview:', accessToken ? `${accessToken.substring(0, 30)}...` : 'NONE');
          
//           if (accessToken) {
//             const authHeader = `Bearer ${accessToken}`;
//             config.headers.Authorization = authHeader;
//             console.log('✅ [INTERCEPTOR] Set Authorization Header for:', config.url);
//             console.log('✅ [INTERCEPTOR] Auth Header Preview:', authHeader.substring(0, 50) + '...');
//           } else {
//             console.log('⚠️ [INTERCEPTOR] NO ACCESS TOKEN FOUND for:', config.url);
//           }

//           // Add device info for auth endpoints
//           if (config.url?.includes('/auth') || config.url?.includes('/otp')) {
//             const deviceInfo = await getStoredDeviceInfo();
//             if (config.data && deviceInfo) {
//               config.data.device_id = deviceInfo.deviceId;
//               config.data.device_fingerprint = deviceInfo.deviceFingerprint;
//               config.data.user_agent = deviceInfo.userAgent;
//             }
//           }

//           // Log final headers
//           console.log('📤 [INTERCEPTOR] Final Headers for', config.url, ':', {
//             Authorization: config.headers.Authorization ? '✅ Present' : '❌ Missing',
//             'X-Device-ID': config.headers['X-Device-ID'] || 'Not set',
//             'Content-Type': config.headers['Content-Type'],
//           });

//           return config;
//         } catch (error) {
//           console.error('❌ [INTERCEPTOR] Error:', error);
//           return Promise.reject(error);
//         }
//       },
//       (error) => {
//         console.error('❌ [INTERCEPTOR] Request error:', error);
//         return Promise.reject(error);
//       }
//     );

//     // Response interceptor - ADDED DEBUG LOGGING
//     api.interceptors.response.use(
//       (response) => {
//         console.log('✅ [INTERCEPTOR] Response:', {
//           url: response.config.url,
//           status: response.status,
//           data: response.data
//         });
//         return response;
//       },
//       async (error: AxiosError<ApiError>) => {
//         console.error('❌ [INTERCEPTOR] Response error:', {
//           url: error.config?.url,
//           status: error.response?.status,
//           data: error.response?.data,
//           headers: error.config?.headers
//         });

//         const originalRequest = error.config as AxiosRequestConfig & { _retry?: boolean };

//         // Handle 429 Rate Limit
//         if (error.response?.status === 429) {
//           const retryAfter = error.response.data?.retry_after || 5;
//           console.log(`⏰ [INTERCEPTOR] Rate limited, retrying after ${retryAfter}s`);
//           await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
//           return this.getApi()(originalRequest);
//         }

//         // Handle 401 Unauthorized
//         if (error.response?.status === 401 && !originalRequest._retry) {
//           if (error.response.data?.error === 'MPIN rate limit exceeded') {
//             throw error;
//           }

//           if (this.isRefreshing) {
//             console.log('🔄 [INTERCEPTOR] Already refreshing token, queuing request');
//             return new Promise((resolve, reject) => {
//               this.failedQueue.push({ resolve, reject });
//             }).then(() => this.getApi()(originalRequest))
//               .catch(err => Promise.reject(err));
//           }

//           originalRequest._retry = true;
//           this.isRefreshing = true;
//           console.log('🔄 [INTERCEPTOR] Starting token refresh...');

//           try {
//             const refreshToken = await getItem(STORAGE_KEYS.REFRESH_TOKEN);
            
//             if (!refreshToken) {
//               console.error('❌ [INTERCEPTOR] No refresh token available');
//               throw new Error('No refresh token available');
//             }

//             const response = await this.refreshToken(refreshToken);
//             const newAccessToken = response.data.access_token;
            
//             console.log('✅ [INTERCEPTOR] Token refresh successful');
            
//             await setItem(STORAGE_KEYS.ACCESS_TOKEN, newAccessToken);
//             await setItem(STORAGE_KEYS.REFRESH_TOKEN, response.data.refresh_token);

//             // Retry failed requests
//             this.processQueue(null, newAccessToken);

//             // Retry original request
//             originalRequest.headers = {
//               ...originalRequest.headers,
//               Authorization: `Bearer ${newAccessToken}`,
//             };
            
//             return this.getApi()(originalRequest);
//           } catch (refreshError) {
//             console.error('❌ [INTERCEPTOR] Token refresh failed:', refreshError);
//             this.processQueue(refreshError, null);
            
//             // Clear all auth data
//             await removeItem(STORAGE_KEYS.ACCESS_TOKEN);
//             await removeItem(STORAGE_KEYS.REFRESH_TOKEN);
//             await removeItem(STORAGE_KEYS.ADMIN_INFO);
            
//             throw refreshError;
//           } finally {
//             this.isRefreshing = false;
//           }
//         }

//         return Promise.reject(error);
//       }
//     );

//     return api;
//   }

//   private processQueue(error: unknown, token: string | null) {
//     this.failedQueue.forEach(promise => {
//       if (error) {
//         promise.reject(error);
//       } else {
//         promise.resolve(token);
//       }
//     });
//     this.failedQueue = [];
//   }

//   // Auth APIs
//   async loginInitiate(phoneNumber: string) {
//     const deviceInfo = await getStoredDeviceInfo();
//     return this.getApi().post('/admin-auth/login/initiate', {
//       phone_number: phoneNumber,
//       device_id: deviceInfo.deviceId,
//       device_fingerprint: deviceInfo.deviceFingerprint,
//     });
//   }

//   async sendOTP(phoneNumber: string, purpose: 'admin_login') {
//     const deviceInfo = await getStoredDeviceInfo();
//     return this.getApi().post('/otp/send', {
//       phone_number: phoneNumber,
//       purpose,
//       device_id: deviceInfo.deviceId,
//       device_fingerprint: deviceInfo.deviceFingerprint,
//       user_agent: deviceInfo.userAgent,
//     });
//   }

//   async verifyOTP(phoneNumber: string, otp: string) {
//     const deviceInfo = await getStoredDeviceInfo();
//     return this.getApi().post('/admin-auth/login/verify-otp', {
//       phone_number: phoneNumber,
//       otp,
//       device_id: deviceInfo.deviceId,
//       device_fingerprint: deviceInfo.deviceFingerprint,
//       user_agent: deviceInfo.userAgent,
//     });
//   }

//   async setupMPIN(adminId: string, mpin: string) {
//     const deviceInfo = await getStoredDeviceInfo();
//     return this.getApi().post('/admin-auth/mpin/setup', {
//       admin_id: adminId,
//       mpin,
//       device_id: deviceInfo.deviceId,
//       device_fingerprint: deviceInfo.deviceFingerprint,
//       user_agent: deviceInfo.userAgent,
//     });
//   }

//   async verifyMPIN(phoneNumber: string, mpin: string) {
//     const deviceInfo = await getStoredDeviceInfo();
//     return this.getApi().post('/admin-auth/login/verify-mpin', {
//       phone_number: phoneNumber,
//       mpin,
//       device_id: deviceInfo.deviceId,
//       device_fingerprint: deviceInfo.deviceFingerprint,
//       user_agent: deviceInfo.userAgent,
//     });
//   }

//   async changeMPIN(adminId: string, currentMpin: string, newMpin: string) {
//     const deviceInfo = await getStoredDeviceInfo();
//     return this.getApi().post('/admin-auth/mpin/change', {
//       admin_id: adminId,
//       current_mpin: currentMpin,
//       new_mpin: newMpin,
//       device_id: deviceInfo.deviceId,
//       device_fingerprint: deviceInfo.deviceFingerprint,
//       user_agent: deviceInfo.userAgent,
//     });
//   }

//   async forgotMPIN(phoneNumber: string) {
//     const deviceInfo = await getStoredDeviceInfo();
//     return this.getApi().post('/admin-auth/mpin/forgot', {
//       phone_number: phoneNumber,
//       device_id: deviceInfo.deviceId,
//       device_fingerprint: deviceInfo.deviceFingerprint,
//       user_agent: deviceInfo.userAgent,
//     });
//   }

//   async validateSession() {
//     console.log('🔍 [API] Starting session validation...');
    
//     const deviceInfo = await getStoredDeviceInfo();
//     console.log('📱 [API] Device ID for validation:', deviceInfo.deviceId);
    
//     // Check token before making request
//     const accessToken = await getItem(STORAGE_KEYS.ACCESS_TOKEN);
//     console.log('🔐 [API] Token check before request:', {
//       hasToken: !!accessToken,
//       tokenLength: accessToken?.length || 0,
//       tokenPreview: accessToken ? `${accessToken.substring(0, 30)}...` : 'NONE'
//     });
    
//     return this.getApi().get('/auth/validate', {
//       headers: {
//         'X-Device-ID': deviceInfo.deviceId,
//         // Authorization header should be added by interceptor
//       },
//     });
//   }

//   async verifyForgotMPIN(phoneNumber: string, otpCode: string, newMpin: string) {
//     const deviceInfo = await getStoredDeviceInfo();
//     return this.getApi().post('/admin-auth/mpin/forgot/verify', {
//       phone_number: phoneNumber,
//       device_id: deviceInfo.deviceId,
//       new_mpin: newMpin,
//       otp_code: otpCode,
//       device_fingerprint: deviceInfo.deviceFingerprint,
//       user_agent: deviceInfo.userAgent,
//     });
//   }

//   async refreshToken(refreshToken: string) {
//     console.log('🔄 [API] Refreshing token...');
//     return this.getApi().post('/admin-auth/refresh', {
//       refresh_token: refreshToken,
//     });
//   }

//   async logout(refreshToken: string) {
//     console.log('🚪 [API] Logging out...');
//     return this.getApi().post('/admin-auth/logout', {
//       refresh_token: refreshToken,
//     });
//   }

//   // Admin Profile API
//   async getAdminProfile() {
//     console.log('👤 [API] Getting admin profile...');
//     return this.getApi().get('/admin/profile');
//   }
// }

// export const api = ApiService.getInstance();
========================================
FILE: src/services/deviceInfo.ts
========================================

import * as Crypto from 'expo-crypto';
import * as Device from 'expo-device';
import * as LocalAuthentication from 'expo-local-authentication';
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';
import { getItem, setItem } from './storage';

// Keychain/Keystore keys
const SECURE_DEVICE_ID_KEY = 'prayantra_persistent_device_id';
const SECURE_DEVICE_FINGERPRINT_KEY = 'prayantra_persistent_device_fingerprint';

export interface DeviceInfo {
  deviceId: string;
  deviceFingerprint: string;
  userAgent: string;
  biometricType: string;
  isBiometricSupported: boolean;
  secureStorageAvailable: boolean;
}

const generateSecureUserAgent = (): string => {
  const appName = 'Prayantra';
  const appVersion = '1.0';
  const platform = Platform.OS;
  
  if (platform === 'ios') {
    return `${appName}/${appVersion} (iOS)`;
  } else if (platform === 'android') {
    return `${appName}/${appVersion} (Android)`;
  } else {
    return `${appName}/${appVersion} (${platform})`;
  }
};

export const getDeviceInfo = async (): Promise<DeviceInfo> => {
  try {
    // Generate or retrieve device ID from SecureStore
    let deviceId = await SecureStore.getItemAsync(SECURE_DEVICE_ID_KEY);
    
    if (!deviceId) {
      // Create a STATIC device ID that doesn't change
      const deviceType = await Device.getDeviceTypeAsync();
      const osVersion = Device.osVersion || 'Unknown';
      const deviceModel = Device.modelName || 'Unknown';
      const deviceBrand = Device.brand || 'Unknown';
      
      // Create a deterministic hash from static device properties
      const staticString = `${deviceModel}-${deviceBrand}-${Platform.OS}-${osVersion}-${deviceType}`;
      const deviceHash = await Crypto.digestStringAsync(
        Crypto.CryptoDigestAlgorithm.SHA256,
        staticString
      );
      
      // Use first 24 chars for device ID (makes it stable)
      deviceId = `prayantra-${Platform.OS}-${deviceHash.substring(0, 24)}`;
      await SecureStore.setItemAsync(SECURE_DEVICE_ID_KEY, deviceId);
      console.log('🆕 [DEVICE] Generated NEW static device ID:', deviceId);
    } else {
      console.log('✅ [DEVICE] Using existing device ID:', deviceId);
    }

    // Generate or retrieve device fingerprint from SecureStore
    let deviceFingerprint = await SecureStore.getItemAsync(SECURE_DEVICE_FINGERPRINT_KEY);
    
    if (!deviceFingerprint) {
      // Create a STATIC fingerprint without timestamp
      const fingerprintData = {
        device_id: deviceId,
        device_model: Device.modelName || 'Unknown',
        device_brand: Device.brand || 'Unknown',
        platform: Platform.OS,
        os_version: Device.osVersion || 'Unknown',
        device_type: await Device.getDeviceTypeAsync(),
        is_emulator: !Device.isDevice,
        // Static properties only - NO timestamp
        app_version: '1.0.0',
        app_build: '1'
      };

      deviceFingerprint = JSON.stringify(fingerprintData);
      await SecureStore.setItemAsync(SECURE_DEVICE_FINGERPRINT_KEY, deviceFingerprint);
      console.log('🆕 [DEVICE] Generated NEW static device fingerprint');
    } else {
      console.log('✅ [DEVICE] Using existing device fingerprint');
    }

    const userAgent = generateSecureUserAgent();

    // Store in AsyncStorage for quick access
    await setItem('device_id', deviceId);
    await setItem('device_fingerprint', deviceFingerprint);
    await setItem('user_agent', userAgent);

    return {
      deviceId,
      deviceFingerprint,
      userAgent,
      biometricType: 'none',
      isBiometricSupported: false,
      secureStorageAvailable: true,
    };
  } catch (error) {
    console.error('❌ [DEVICE] Device info generation failed:', error);
    
    // Static fallback
    const fallbackId = `prayantra-${Platform.OS}-static-fallback`;
    const fallbackFingerprint = JSON.stringify({ 
      device_id: fallbackId,
      platform: Platform.OS,
      is_fallback: true 
    });
    
    return {
      deviceId: fallbackId,
      deviceFingerprint: fallbackFingerprint,
      userAgent: generateSecureUserAgent(),
      biometricType: 'none',
      isBiometricSupported: false,
      secureStorageAvailable: false,
    };
  }
};

export const getStoredDeviceInfo = async (): Promise<DeviceInfo> => {
  try {
    // FIRST: Check SecureStore (primary source of truth)
    let deviceId = await SecureStore.getItemAsync(SECURE_DEVICE_ID_KEY);
    let deviceFingerprint = await SecureStore.getItemAsync(SECURE_DEVICE_FINGERPRINT_KEY);
    
    // SECOND: If not in SecureStore, check AsyncStorage (fallback cache)
    if (!deviceId || !deviceFingerprint) {
      console.log('🔄 [DEVICE] No device info in SecureStore, checking AsyncStorage...');
      deviceId = await getItem('device_id') || '';
      deviceFingerprint = await getItem('device_fingerprint') || '';
    }
    
    // THIRD: If still not found, generate NEW device info
    if (!deviceId || !deviceFingerprint) {
      console.log('🆕 [DEVICE] No stored device info found, generating new...');
      const newDeviceInfo = await getDeviceInfo();
      
      // Return the newly generated info
      return newDeviceInfo;
    }

    console.log('✅ [DEVICE] Using stored device info');
    
    const userAgent = await getItem('user_agent') || generateSecureUserAgent();
    
    return {
      deviceId,
      deviceFingerprint,
      userAgent,
      biometricType: 'none',
      isBiometricSupported: false,
      secureStorageAvailable: true,
    };
  } catch (error) {
    console.error('❌ [DEVICE] Error getting stored device info:', error);
    return getDeviceInfo();
  }
};

export const initializeDeviceInfo = async (): Promise<void> => {
  console.log("🚀 INITIALIZING DEVICE INFORMATION...");
  try {
    const deviceInfo = await getDeviceInfo();
    console.log("✅ DEVICE INFORMATION INITIALIZED:", {
      deviceId: deviceInfo.deviceId,
      fingerprintLength: deviceInfo.deviceFingerprint.length,
      userAgent: deviceInfo.userAgent
    });
  } catch (error) {
    console.error("❌ DEVICE INITIALIZATION FAILED:", error);
  }
};

// Debug helper function to check current device info
export const debugDeviceInfo = async (): Promise<void> => {
  console.log('🔍 [DEVICE DEBUG] Current device info:');
  
  const secureId = await SecureStore.getItemAsync(SECURE_DEVICE_ID_KEY);
  const secureFp = await SecureStore.getItemAsync(SECURE_DEVICE_FINGERPRINT_KEY);
  const asyncId = await getItem('device_id');
  const asyncFp = await getItem('device_fingerprint');
  
  console.log('SecureStore Device ID:', secureId);
  console.log('SecureStore Fingerprint:', secureFp?.substring(0, 100) + '...');
  console.log('AsyncStorage Device ID:', asyncId);
  console.log('AsyncStorage Fingerprint:', asyncFp?.substring(0, 100) + '...');
  
  // Get current device info
  const currentInfo = await getStoredDeviceInfo();
  console.log('Current Device Info:', {
    deviceId: currentInfo.deviceId,
    fingerprintPreview: currentInfo.deviceFingerprint.substring(0, 100) + '...',
    userAgent: currentInfo.userAgent
  });
};

// Reset device info (only for testing or troubleshooting)
export const resetDeviceInfo = async (): Promise<void> => {
  try {
    console.log("🔄 [DEVICE] Resetting device info...");
    await SecureStore.deleteItemAsync(SECURE_DEVICE_ID_KEY);
    await SecureStore.deleteItemAsync(SECURE_DEVICE_FINGERPRINT_KEY);
    await getDeviceInfo(); // This will generate new ones
    console.log("✅ [DEVICE] Device info reset complete");
  } catch (error) {
    console.error("❌ [DEVICE] Error resetting device info:", error);
  }
};
========================================
FILE: src/services/storage.ts
========================================

import AsyncStorage from '@react-native-async-storage/async-storage';
import * as SecureStore from 'expo-secure-store';

// Regular storage for non-sensitive data
export const setItem = async (key: string, value: string): Promise<void> => {
  try {
    if (value === undefined || value === null) {
      console.warn(`Attempting to store null/undefined value for key: ${key}`);
      return;
    }
    await AsyncStorage.setItem(key, value);
  } catch (error) {
    console.error('Error storing data:', error);
  }
};

export const getItem = async (key: string): Promise<string | null> => {
  try {
    return await AsyncStorage.getItem(key);
  } catch (error) {
    console.error('Error retrieving data:', error);
    return null;
  }
};

export const removeItem = async (key: string): Promise<void> => {
  try {
    await AsyncStorage.removeItem(key);
  } catch (error) {
    console.error('Error removing data:', error);
  }
};

// Clear only session data (tokens and admin info), keep phone number
export const clearSessionData = async (): Promise<void> => {
  try {
    const keys = [
      STORAGE_KEYS.ACCESS_TOKEN,
      STORAGE_KEYS.REFRESH_TOKEN,
      STORAGE_KEYS.ADMIN_INFO,
    ];
    
    await AsyncStorage.multiRemove(keys);
    console.log("✅ SESSION DATA CLEARED, PHONE NUMBER & ADMIN ID PRESERVED");
  } catch (error) {
    console.error('Error clearing session data:', error);
  }
};

// Clear everything including phone number and admin ID
export const clearAllUserData = async (): Promise<void> => {
  try {
    const keys = [
      STORAGE_KEYS.ACCESS_TOKEN,
      STORAGE_KEYS.REFRESH_TOKEN,
      STORAGE_KEYS.ADMIN_ID,
      STORAGE_KEYS.ADMIN_INFO,
      STORAGE_KEYS.PHONE_NUMBER,
    ];

    await AsyncStorage.multiRemove(keys);
    console.log("✅ ALL USER DATA CLEARED");
  } catch (error) {
    console.error('Error clearing all user data:', error);
  }
};

// Clear everything including device info (only for app uninstall scenarios)
export const clearAllStorage = async (): Promise<void> => {
  try {
    // Clear all AsyncStorage
    await AsyncStorage.clear();
    
    // Clear all SecureStore
    await SecureStore.deleteItemAsync('persistent_device_id');
    await SecureStore.deleteItemAsync('installation_id');
    
    console.log("✅ COMPLETE STORAGE CLEARED INCLUDING DEVICE INFO");
  } catch (error) {
    console.error('Error clearing all storage:', error);
  }
};

// Helper to check if user has stored phone number
export const hasStoredPhoneNumber = async (): Promise<boolean> => {
  try {
    const phoneNumber = await getItem(STORAGE_KEYS.PHONE_NUMBER);
    const adminId = await getItem(STORAGE_KEYS.ADMIN_ID);
    return !!(phoneNumber && adminId);
  } catch (error) {
    return false;
  }
};

// Get formatted phone number (stored as +919876543210 format)
export const getFormattedPhoneNumber = async (): Promise<string | null> => {
  try {
    const phoneNumber = await getItem(STORAGE_KEYS.PHONE_NUMBER);
    // Return phone number as stored (format: +919876543210)
    return phoneNumber;
  } catch (error) {
    return null;
  }
};

// Get phone number with spaces for display
export const getDisplayPhoneNumber = async (): Promise<string | null> => {
  try {
    const phoneNumber = await getItem(STORAGE_KEYS.PHONE_NUMBER);
    if (!phoneNumber) return null;
    
    // Format: +91 98765 43210
    const countryCode = phoneNumber.substring(0, 3); // +91
    const remaining = phoneNumber.substring(3);
    
    if (remaining.length === 10) {
      return `${countryCode} ${remaining.substring(0, 5)} ${remaining.substring(5)}`;
    }
    
    return phoneNumber;
  } catch (error) {
    return null;
  }
};

// Store phone number permanently (for auto-login feature)
export const storePhoneNumberPermanently = async (phoneNumber: string, adminId: string): Promise<void> => {
  try {
    // Remove all spaces and store in format: +919876543210
    const formattedPhone = phoneNumber.replace(/\s/g, '');
    
    console.log('🔐 [STORAGE] Storing phone number permanently:', {
      original: phoneNumber,
      formatted: formattedPhone,
      adminId
    });
    
    await setItem(STORAGE_KEYS.PHONE_NUMBER, formattedPhone);
    await setItem(STORAGE_KEYS.ADMIN_ID, adminId);
    
    console.log('✅ [STORAGE] Phone number stored permanently');
  } catch (error) {
    console.error('❌ [STORAGE] Error storing phone number:', error);
    throw error;
  }
};

// Remove phone number permanently (when user explicitly removes it)
export const removePhoneNumberPermanently = async (): Promise<void> => {
  try {
    console.log('🔐 [STORAGE] Removing phone number permanently');
    await removeItem(STORAGE_KEYS.PHONE_NUMBER);
    await removeItem(STORAGE_KEYS.ADMIN_ID);
    console.log('✅ [STORAGE] Phone number removed permanently');
  } catch (error) {
    console.error('❌ [STORAGE] Error removing phone number:', error);
    throw error;
  }
};

// Storage keys based on your API responses
export const STORAGE_KEYS = {
  ACCESS_TOKEN: 'access_token',
  REFRESH_TOKEN: 'refresh_token',
  ADMIN_ID: 'admin_id',
  ADMIN_INFO: 'admin_info',
  PHONE_NUMBER: 'phone_number', // Store as +919876543210 format
  DEVICE_ID: 'device_id',
  USER_AGENT: 'user_agent',
  DEVICE_FINGERPRINT: 'device_fingerprint',
};
========================================
FILE: src/types/index.ts
========================================

export interface AdminAuthResponse {
    success: boolean;
    data: {
      user_exists: boolean;
      has_mpin: boolean;
      mpin_locked: boolean;
      device_trusted: boolean;
      flow_state: string;
      message: string;
      user_id: string;
    };
    message: string;
    timestamp: string;
  }
  
  export interface OTPVerifyResponse {
    success: boolean;
    data: {
      admin_id: string;
      daily_quota: {
        limit: number;
        remaining: number;
        used: number;
      };
      device_trusted: boolean;
      has_mpin: boolean;
      message: string;
      mpin_locked: boolean;
    };
    message: string;
    timestamp: string;
  }
  
  export interface MPINVerifyResponse {
    success: boolean;
    data: {
      admin: AdminInfo;
      message: string;
      tokens: AuthTokens;
    };
    message: string;
    timestamp: string;
  }
  
  export interface AdminInfo {
    admin_id: string;
    departments: string[];
    full_name: string;
    is_active: boolean;
    permissions: string[];
    role_string: string;
    role_type: number;
    username: string;
  }
  
  export interface AuthTokens {
    access_token: string;
    refresh_token: string;
    expires_in: number;
    token_type: string;
  }
  
  export interface DeviceInfo {
    deviceId: string;
    deviceFingerprint: string;
    userAgent: string;
    biometricType: string;
    isBiometricSupported: boolean;
    secureStorageAvailable: boolean;
  }
  
  export interface ApiError {
    success: boolean;
    error?: string;
    message: string;
    timestamp: string;
    retry_after?: number;
    expires_at?: string;
  }
  
  export type LoginFlowState = 
    | 'existing_user_mpin'
    | 'new_user_no_mpin'
    | 'device_not_trusted'
    | 'mpin_locked';
  
  export interface DailyQuota {
    limit: number;
    remaining: number;
    used: number;
  }
  
  export interface AxiosErrorResponse {
    response?: {
      status: number;
      data: ApiError;
      config?: {
        data?: string;
      };
    };
  }