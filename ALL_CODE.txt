
========================================
FILE: App.tsx
========================================

import 'react-native-gesture-handler';
import React, { useEffect, useState } from 'react';
import { StatusBar } from 'expo-status-bar';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { NavigationContainer } from '@react-navigation/native';
import { View, Text, StyleSheet } from 'react-native'; // Added missing imports
import { QueryProvider } from './src/contexts/QueryProvider';
import { AuthProvider } from './src/contexts/AuthContext';
import { ToastProvider } from './src/components/Toast';
import AppNavigator from './src/navigation/AppNavigator';
import SplashScreen from './src/screens/SplashScreen';
import { initializeDeviceInfo } from './src/services/deviceInfo';
import * as SplashScreenModule from 'expo-splash-screen';

// Keep the splash screen visible while we fetch resources
SplashScreenModule.preventAutoHideAsync();

const App = () => {
  const [isReady, setIsReady] = useState(false);
  const [deviceInitialized, setDeviceInitialized] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function prepare() {
      try {
        await initializeDeviceInfo();
        setDeviceInitialized(true);

        // Simulate loading
        await new Promise(resolve => setTimeout(resolve, 1500));
      } catch (e: any) {
        console.error('App initialization failed:', e);
        setError(e.message || 'Unknown error');
      } finally {
        setIsReady(true);
        try {
          await SplashScreenModule.hideAsync();
        } catch (e) {
          console.error('Failed to hide splash screen:', e);
        }
      }
    }

    prepare();
  }, []);

  // Show error screen
  if (error) {
    return (
      <SafeAreaProvider>
        <GestureHandlerRootView style={{ flex: 1 }}>
          <View style={styles.errorContainer}>
            <Text style={styles.errorTitle}>Initialization Error</Text>
            <Text style={styles.errorText}>{error}</Text>
          </View>
        </GestureHandlerRootView>
      </SafeAreaProvider>
    );
  }

  // Show splash screen while loading
  if (!isReady || !deviceInitialized) {
    return <SplashScreen />;
  }

  // Main app
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <QueryProvider>
          <AuthProvider>
            <ToastProvider>
              <NavigationContainer>
                <AppNavigator />
              </NavigationContainer>
            </ToastProvider>
          </AuthProvider>
        </QueryProvider>
        <StatusBar style="auto" />
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
};

const styles = StyleSheet.create({
  errorContainer: {
    flex: 1,
    backgroundColor: '#FEF2F2',
    padding: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorTitle: {
    fontSize: 24,
    color: '#DC2626',
    fontWeight: 'bold',
    marginBottom: 20,
  },
  errorText: {
    fontSize: 16,
    color: '#7F1D1D',
    marginBottom: 20,
    textAlign: 'center',
  },
});

export default App;
========================================
FILE: src/components/DepartmentCard.tsx
========================================

import React from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
} from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface DepartmentCardProps {
  department: string;
  index: number;
  onPress: () => void;
}

const departmentIcons: Record<string, string> = {
  HR: 'account-group',
  Finance: 'cash',
  Accounting: 'calculator',
  Procurement: 'cart',
  Inventory: 'warehouse',
  Logistics: 'truck',
  Sales: 'chart-line',
  Marketing: 'bullhorn',
  'Customer Support': 'headset',
  Operations: 'cog',
  IT: 'desktop-classic',
  Production: 'factory',
  'Quality Control': 'check-circle',
  'Quality Assurance': 'shield-check',
  'R&D': 'flask',
  Administration: 'office-building',
  'Employee Management': 'account-multiple',
  'Manager Management': 'account-tie',
  'Company Management': 'domain',
  'Super Admin Management': 'security',
};

const departmentColors = [
  '#C084FC', // Purple
  '#A855F7',
  '#9333EA',
  '#7C3AED',
  '#6D28D9',
  '#5B21B6',
  '#4C1D95',
  '#3B0764',
  '#7E22CE',
  '#6B21A8',
];

const DepartmentCard: React.FC<DepartmentCardProps> = ({
  department,
  index,
  onPress,
}) => {
  const icon = departmentIcons[department] || 'folder';
  const color = departmentColors[index % departmentColors.length];

  return (
    <TouchableOpacity style={styles.card} onPress={onPress} activeOpacity={0.7}>
      <View style={[styles.iconContainer, { backgroundColor: `${color}15` }]}>
        <MaterialCommunityIcons name={icon as any} size={28} color={color} />
      </View>

      <Text style={styles.departmentName} numberOfLines={2}>
        {department}
      </Text>

      <View style={styles.arrowContainer}>
        <MaterialCommunityIcons name="chevron-right" size={20} color="#CBD5E1" />
      </View>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  card: {
    width: '48%',
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginHorizontal: '1%',
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#E2E8F0',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 2,
  },
  iconContainer: {
    width: 56,
    height: 56,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 12,
  },
  departmentName: {
    fontSize: 15,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 8,
    minHeight: 40,
  },
  arrowContainer: {
    alignItems: 'flex-end',
  },
});

export default React.memo(DepartmentCard);
========================================
FILE: src/components/MPINInput.tsx
========================================

import React, { useRef, useState, useEffect } from 'react';
import {
  View,
  TextInput,
  StyleSheet,
  TouchableWithoutFeedback,
  Keyboard,
  Text,
  Dimensions,
} from 'react-native';

const { width } = Dimensions.get('window');

interface MPINInputProps {
  length?: number;
  onComplete: (mpin: string) => void;
  error?: boolean;
  disabled?: boolean;
  autoFocus?: boolean;
}

const MPINInput: React.FC<MPINInputProps> = ({
  length = 6,
  onComplete,
  error = false,
  disabled = false,
  autoFocus = true,
}) => {
  const [mpin, setMpin] = useState<string[]>(Array(length).fill(''));
  const inputsRef = useRef<TextInput[]>([]);

  useEffect(() => {
    if (autoFocus) {
      setTimeout(() => {
        inputsRef.current[0]?.focus();
      }, 100);
    }
  }, [autoFocus]);

  const handleChangeText = (text: string, index: number) => {
    if (disabled) return;

    const newMpin = [...mpin];
    
    // Handle paste
    if (text.length > 1) {
      const pastedDigits = text.split('').slice(0, length);
      pastedDigits.forEach((digit, idx) => {
        if (idx < length) {
          newMpin[idx] = digit;
        }
      });
      setMpin(newMpin);
      
      // Focus last input
      const lastIndex = Math.min(pastedDigits.length, length - 1);
      inputsRef.current[lastIndex]?.focus();
      
      // Check if complete
      if (pastedDigits.length === length) {
        onComplete(pastedDigits.join(''));
      }
      return;
    }

    // Single digit input
    newMpin[index] = text;
    setMpin(newMpin);

    // Auto-focus next input
    if (text && index < length - 1) {
      inputsRef.current[index + 1]?.focus();
    }

    // Check if all digits are entered
    const currentMpin = newMpin.join('');
    if (currentMpin.length === length) {
      onComplete(currentMpin);
      Keyboard.dismiss();
    }
  };

  const handleKeyPress = (e: any, index: number) => {
    // Handle backspace
    if (e.nativeEvent.key === 'Backspace' && !mpin[index] && index > 0) {
      inputsRef.current[index - 1]?.focus();
    }
  };

  const handleInputFocus = (index: number) => {
    // Clear the input when focusing if it's not the first empty one
    const firstEmptyIndex = mpin.findIndex(digit => digit === '');
    if (firstEmptyIndex !== -1 && index > firstEmptyIndex) {
      inputsRef.current[firstEmptyIndex]?.focus();
    }
  };

  const clearMpin = () => {
    setMpin(Array(length).fill(''));
    inputsRef.current[0]?.focus();
  };

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <View style={styles.container}>
        <View style={styles.inputsContainer}>
          {Array.from({ length }).map((_, index) => (
            <View key={index} style={styles.inputWrapper}>
              <TextInput
                ref={ref => {
                  if (ref) inputsRef.current[index] = ref;
                }}
                style={[
                  styles.input,
                  error && styles.inputError,
                  mpin[index] && styles.inputFilled,
                ]}
                value={mpin[index]}
                onChangeText={text => handleChangeText(text, index)}
                onKeyPress={e => handleKeyPress(e, index)}
                onFocus={() => handleInputFocus(index)}
                keyboardType="number-pad"
                maxLength={index === 0 ? length : 1}
                secureTextEntry
                editable={!disabled}
                selectTextOnFocus
                autoFocus={index === 0 && autoFocus}
                contextMenuHidden
              />
              {index < length - 1 && <View style={styles.separator} />}
            </View>
          ))}
        </View>
        
        {error && (
          <Text style={styles.errorText}>Invalid MPIN. Please try again.</Text>
        )}
        
        <TouchableWithoutFeedback onPress={clearMpin} disabled={disabled}>
          <View style={styles.clearButton}>
            <Text style={styles.clearButtonText}>Clear MPIN</Text>
          </View>
        </TouchableWithoutFeedback>
      </View>
    </TouchableWithoutFeedback>
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    paddingVertical: 20,
  },
  inputsContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  inputWrapper: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  input: {
    width: 44,
    height: 52,
    borderWidth: 1.5,
    borderColor: '#CBD5E1',
    borderRadius: 8,
    fontSize: 20,
    fontWeight: '600',
    textAlign: 'center',
    color: '#1E293B',
    backgroundColor: '#FFFFFF',
  },
  inputFilled: {
    borderColor: '#C084FC', // Purple
    backgroundColor: '#FAF5FF',
  },
  inputError: {
    borderColor: '#DC2626',
    backgroundColor: '#FEF2F2',
  },
  separator: {
    width: 8,
  },
  errorText: {
    color: '#DC2626',
    fontSize: 14,
    marginTop: 12,
    textAlign: 'center',
  },
  clearButton: {
    marginTop: 24,
    paddingVertical: 8,
    paddingHorizontal: 16,
  },
  clearButtonText: {
    color: '#C084FC', // Purple
    fontSize: 14,
    fontWeight: '500',
  },
});

export default React.memo(MPINInput);
========================================
FILE: src/components/OTPInput.tsx
========================================

import React, { useRef, useState, useEffect } from 'react';
import {
  View,
  TextInput,
  StyleSheet,
  TouchableWithoutFeedback,
  Keyboard,
  Text,
  Dimensions,
} from 'react-native';

const { width } = Dimensions.get('window');

interface OTPInputProps {
  length?: number;
  onComplete: (otp: string) => void;
  error?: boolean;
  disabled?: boolean;
  autoFocus?: boolean;
}

const OTPInput: React.FC<OTPInputProps> = ({
  length = 6,
  onComplete,
  error = false,
  disabled = false,
  autoFocus = true,
}) => {
  const [otp, setOtp] = useState<string[]>(Array(length).fill(''));
  const inputsRef = useRef<TextInput[]>([]);

  useEffect(() => {
    if (autoFocus) {
      setTimeout(() => {
        inputsRef.current[0]?.focus();
      }, 100);
    }
  }, [autoFocus]);

  const handleChangeText = (text: string, index: number) => {
    if (disabled) return;

    const newOtp = [...otp];
    
    // Handle paste
    if (text.length > 1) {
      const pastedDigits = text.split('').slice(0, length);
      pastedDigits.forEach((digit, idx) => {
        if (idx < length) {
          newOtp[idx] = digit;
        }
      });
      setOtp(newOtp);
      
      // Focus last input
      const lastIndex = Math.min(pastedDigits.length, length - 1);
      inputsRef.current[lastIndex]?.focus();
      
      // Check if complete
      if (pastedDigits.length === length) {
        onComplete(pastedDigits.join(''));
      }
      return;
    }

    // Single digit input
    newOtp[index] = text;
    setOtp(newOtp);

    // Auto-focus next input
    if (text && index < length - 1) {
      inputsRef.current[index + 1]?.focus();
    }

    // Check if all digits are entered
    const currentOtp = newOtp.join('');
    if (currentOtp.length === length) {
      onComplete(currentOtp);
      Keyboard.dismiss();
    }
  };

  const handleKeyPress = (e: any, index: number) => {
    // Handle backspace
    if (e.nativeEvent.key === 'Backspace' && !otp[index] && index > 0) {
      inputsRef.current[index - 1]?.focus();
    }
  };

  const handleInputFocus = (index: number) => {
    // Clear the input when focusing if it's not the first empty one
    const firstEmptyIndex = otp.findIndex(digit => digit === '');
    if (firstEmptyIndex !== -1 && index > firstEmptyIndex) {
      inputsRef.current[firstEmptyIndex]?.focus();
    }
  };

  const clearOtp = () => {
    setOtp(Array(length).fill(''));
    inputsRef.current[0]?.focus();
  };

  return (
    <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
      <View style={styles.container}>
        <View style={styles.inputsContainer}>
          {Array.from({ length }).map((_, index) => (
            <View key={index} style={styles.inputWrapper}>
              <TextInput
                ref={ref => {
                  if (ref) inputsRef.current[index] = ref;
                }}
                style={[
                  styles.input,
                  error && styles.inputError,
                  otp[index] && styles.inputFilled,
                ]}
                value={otp[index]}
                onChangeText={text => handleChangeText(text, index)}
                onKeyPress={e => handleKeyPress(e, index)}
                onFocus={() => handleInputFocus(index)}
                keyboardType="number-pad"
                maxLength={index === 0 ? length : 1}
                editable={!disabled}
                selectTextOnFocus
                autoFocus={index === 0 && autoFocus}
                contextMenuHidden
              />
            </View>
          ))}
        </View>
        
        {error && (
          <Text style={styles.errorText}>Invalid OTP. Please try again.</Text>
        )}
        
        <TouchableWithoutFeedback onPress={clearOtp} disabled={disabled}>
          <View style={styles.clearButton}>
            <Text style={styles.clearButtonText}>Clear OTP</Text>
          </View>
        </TouchableWithoutFeedback>
      </View>
    </TouchableWithoutFeedback>
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    paddingVertical: 20,
  },
  inputsContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    gap: 12,
  },
  inputWrapper: {
    alignItems: 'center',
  },
  input: {
    width: 48,
    height: 56,
    borderWidth: 1.5,
    borderColor: '#CBD5E1',
    borderRadius: 8,
    fontSize: 20,
    fontWeight: '600',
    textAlign: 'center',
    color: '#1E293B',
    backgroundColor: '#FFFFFF',
  },
  inputFilled: {
    borderColor: '#C084FC', // Purple
    backgroundColor: '#FAF5FF',
  },
  inputError: {
    borderColor: '#DC2626',
    backgroundColor: '#FEF2F2',
  },
  errorText: {
    color: '#DC2626',
    fontSize: 14,
    marginTop: 12,
    textAlign: 'center',
  },
  clearButton: {
    marginTop: 24,
    paddingVertical: 8,
    paddingHorizontal: 16,
  },
  clearButtonText: {
    color: '#C084FC', // Purple
    fontSize: 14,
    fontWeight: '500',
  },
});

export default React.memo(OTPInput);
========================================
FILE: src/components/PrayantraLogo.tsx
========================================

import React, { useEffect, useRef } from 'react';
import { View, StyleSheet, ViewStyle, Animated, Easing } from 'react-native';
import Svg, {
  Path,
  Defs,
  LinearGradient,
  RadialGradient,
  Stop,
  Circle,
  G,
  Text as SvgText,
} from 'react-native-svg';

interface PrayantraLogoProps {
  size?: number;
  animated?: boolean;
  style?: ViewStyle;
  showText?: boolean;
}

export const PrayantraLogo: React.FC<PrayantraLogoProps> = ({
  size = 100,
  animated = false,
  style,
  showText = true,
}) => {
  // Animation refs for logo elements
  const ring1Anim = useRef(new Animated.Value(0)).current;
  const ring2Anim = useRef(new Animated.Value(0)).current;
  const dashAnim = useRef(new Animated.Value(0)).current;
  const particleAnims = useRef([...Array(6)].map(() => new Animated.Value(0))).current;
  const cubeAnim = useRef(new Animated.Value(0)).current;
  const glowAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (animated) {
      // Start all animations
      Animated.parallel([
        // Ring 1 animation
        Animated.loop(
          Animated.sequence([
            Animated.timing(ring1Anim, {
              toValue: 1,
              duration: 2000,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
            Animated.timing(ring1Anim, {
              toValue: 0,
              duration: 2000,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
          ])
        ),
        
        // Ring 2 animation
        Animated.loop(
          Animated.sequence([
            Animated.timing(ring2Anim, {
              toValue: 1,
              duration: 1500,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
            Animated.timing(ring2Anim, {
              toValue: 0,
              duration: 1500,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
          ])
        ),
        
        // Dash animation
        Animated.loop(
          Animated.timing(dashAnim, {
            toValue: 1,
            duration: 1500,
            easing: Easing.linear,
            useNativeDriver: false,
          })
        ),
        
        // Cube rotation
        Animated.loop(
          Animated.timing(cubeAnim, {
            toValue: 1,
            duration: 10000,
            easing: Easing.linear,
            useNativeDriver: false,
          })
        ),
        
        // Glow animation
        Animated.loop(
          Animated.sequence([
            Animated.timing(glowAnim, {
              toValue: 1,
              duration: 2000,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
            Animated.timing(glowAnim, {
              toValue: 0.5,
              duration: 2000,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
          ])
        ),
        
        // Particle animations
        ...particleAnims.map((anim, index) => 
          Animated.loop(
            Animated.sequence([
              Animated.timing(anim, {
                toValue: 1,
                duration: 1000 + index * 200,
                easing: Easing.inOut(Easing.sin),
                useNativeDriver: false,
              }),
              Animated.timing(anim, {
                toValue: 0,
                duration: 1000 + index * 200,
                easing: Easing.inOut(Easing.sin),
                useNativeDriver: false,
              }),
            ])
          )
        ),
      ]).start();
    }
  }, [animated]);

  const ring1Radius = ring1Anim.interpolate({
    inputRange: [0, 1],
    outputRange: [85, 95],
  });

  const ring2Radius = ring2Anim.interpolate({
    inputRange: [0, 1],
    outputRange: [70, 75],
  });

  const dashOffset = dashAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 20],
  });

  const dashOffset2 = dashAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [20, 0],
  });

  const cubeRotate = cubeAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0 100 100', '45 100 100'],
  });

  const glowOpacity = glowAnim.interpolate({
    inputRange: [0, 0.5, 1],
    outputRange: [0.7, 1, 0.7],
  });

  return (
    <View style={[styles.container, style]}>
      <Svg width={size} height={size} viewBox="0 0 200 200">
        <Defs>
          <LinearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%">
            <Stop offset="0%" stopColor="#4A00E0" stopOpacity="1" />
            <Stop offset="50%" stopColor="#8E2DE2" stopOpacity="1" />
            <Stop offset="100%" stopColor="#00B4DB" stopOpacity="1" />
          </LinearGradient>
          
          <LinearGradient id="grad2" x1="0%" y1="0%" x2="0%" y2="100%">
            <Stop offset="0%" stopColor="#00B4DB" stopOpacity="0.9" />
            <Stop offset="100%" stopColor="#0083B0" stopOpacity="0.9" />
          </LinearGradient>
          
          <RadialGradient id="centerGlow" cx="50%" cy="50%" r="50%">
            <Stop offset="0%" stopColor="#FFFFFF" stopOpacity="0.3" />
            <Stop offset="100%" stopColor="#FFFFFF" stopOpacity="0" />
          </RadialGradient>
        </Defs>
        
        {/* Outer rings */}
        <G>
          {/* Animated outer ring 1 */}
          {animated ? (
            <AnimatedCircle 
              cx="100"
              cy="100"
              r={ring1Radius}
              fill="none"
              stroke="url(#grad1)"
              strokeWidth="2"
            />
          ) : (
            <Circle cx="100" cy="100" r="85" fill="none" stroke="url(#grad1)" strokeWidth="2" />
          )}
          
          {/* Animated outer ring 2 */}
          {animated ? (
            <AnimatedCircle 
              cx="100"
              cy="100"
              r={ring2Radius}
              fill="none"
              stroke="rgba(142, 45, 226, 0.4)"
              strokeWidth="1.5"
            />
          ) : (
            <Circle cx="100" cy="100" r="70" fill="none" stroke="rgba(142, 45, 226, 0.4)" strokeWidth="1.5" />
          )}
        </G>
        
        {/* Central core */}
        <G>
          {/* Center circle */}
          <Circle cx="100" cy="100" r="30" fill="url(#grad2)" />
          
          {/* Neural network paths */}
          {animated ? (
            <>
              <AnimatedPath
                d="M70,100 Q100,70 130,100 Q100,130 70,100"
                fill="none"
                stroke="rgba(255,255,255,0.5)"
                strokeWidth="1.5"
                strokeDasharray="5,5"
                strokeDashoffset={dashOffset}
              />
              <AnimatedPath
                d="M100,70 Q130,100 100,130 Q70,100 100,70"
                fill="none"
                stroke="rgba(255,255,255,0.5)"
                strokeWidth="1.5"
                strokeDasharray="5,5"
                strokeDashoffset={dashOffset2}
              />
            </>
          ) : (
            <>
              <Path
                d="M70,100 Q100,70 130,100 Q100,130 70,100"
                fill="none"
                stroke="rgba(255,255,255,0.5)"
                strokeWidth="1.5"
                strokeDasharray="5,5"
              />
              <Path
                d="M100,70 Q130,100 100,130 Q70,100 100,70"
                fill="none"
                stroke="rgba(255,255,255,0.5)"
                strokeWidth="1.5"
                strokeDasharray="5,5"
              />
            </>
          )}
          
          {/* Animated particles around center */}
          {[...Array(6)].map((_, i) => {
            const angle = (i * 60) * Math.PI / 180;
            const radius = 50;
            const x = 100 + radius * Math.cos(angle);
            const y = 100 + radius * Math.sin(angle);
            
            if (animated) {
              return (
                <AnimatedCircle
                  key={i}
                  cx={x}
                  cy={y}
                  r={particleAnims[i].interpolate({
                    inputRange: [0, 1],
                    outputRange: [4, 6],
                  })}
                  fill="#00B4DB"
                  opacity={particleAnims[i].interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.7, 1],
                  })}
                />
              );
            } else {
              return (
                <Circle key={i} cx={x} cy={y} r="4" fill="#00B4DB" opacity="0.8" />
              );
            }
          })}
          
          {/* Center cube/tech element */}
          {animated ? (
            <AnimatedPath
              d="M90,90 L110,90 L110,110 L90,110 Z"
              fill="none"
              stroke="white"
              strokeWidth="2"
              strokeLinecap="round"
              rotation={cubeRotate}
            />
          ) : (
            <Path
              d="M90,90 L110,90 L110,110 L90,110 Z"
              fill="none"
              stroke="white"
              strokeWidth="2"
              strokeLinecap="round"
            />
          )}
          
          {/* Center glow with animation */}
          {animated ? (
            <AnimatedCircle 
              cx="100"
              cy="100"
              r="35"
              fill="url(#centerGlow)"
              opacity={glowOpacity}
            />
          ) : (
            <Circle cx="100" cy="100" r="35" fill="url(#centerGlow)" opacity="0.8" />
          )}
        </G>
        
        {/* App Name and Tagline */}
        {showText && (
          <G>
            <SvgText
              x="100"
              y="170"
              textAnchor="middle"
              fill="white"
              fontSize="14"
              fontWeight="bold"
              fontFamily="sans-serif"
            >
              PRAYANTRA
            </SvgText>
            <SvgText
              x="100"
              y="185"
              textAnchor="middle"
              fill="rgba(255,255,255,0.8)"
              fontSize="8"
              fontFamily="sans-serif"
            >
              Powering Enterprise
            </SvgText>
          </G>
        )}
      </Svg>
    </View>
  );
};

// Helper components for animated SVG elements
const AnimatedCircle = ({ cx, cy, r, fill, stroke, strokeWidth, opacity, ...props }: any) => {
  const getValue = (value: any) => {
    if (value && typeof value === 'object' && 'interpolate' in value) {
      return value.__getValue ? value.__getValue() : value;
    }
    return value;
  };

  return (
    <Circle
      cx={getValue(cx)}
      cy={getValue(cy)}
      r={getValue(r)}
      fill={fill}
      stroke={stroke}
      strokeWidth={strokeWidth}
      opacity={getValue(opacity)}
      {...props}
    />
  );
};

const AnimatedPath = ({ d, fill, stroke, strokeWidth, strokeDasharray, strokeDashoffset, rotation, ...props }: any) => {
  const getValue = (value: any) => {
    if (value && typeof value === 'object' && 'interpolate' in value) {
      return value.__getValue ? value.__getValue() : value;
    }
    return value;
  };

  const transform = rotation ? `rotate(${getValue(rotation)})` : undefined;
  
  return (
    <Path
      d={d}
      fill={fill}
      stroke={stroke}
      strokeWidth={strokeWidth}
      strokeDasharray={strokeDasharray}
      strokeDashoffset={getValue(strokeDashoffset)}
      transform={transform}
      {...props}
    />
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
  },
});

export default PrayantraLogo;
========================================
FILE: src/components/QuickActions.tsx
========================================

import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface QuickActionsProps {
  navigation: any;
}

const QuickActions: React.FC<QuickActionsProps> = ({ navigation }) => {
  const actions = [
    { icon: 'account-plus', label: 'Add Employee', screen: 'AddEmployee' },
    { icon: 'file-document', label: 'Create Report', screen: 'CreateReport' },
    { icon: 'calendar-clock', label: 'Attendance', screen: 'Attendance' },
    { icon: 'chart-bar', label: 'Analytics', screen: 'Analytics' },
  ];

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Quick Actions</Text>

      <View style={styles.actionsGrid}>
        {actions.map((action, index) => (
          <TouchableOpacity
            key={index}
            style={styles.actionButton}
            onPress={() => navigation.navigate(action.screen)}
          >
            <View style={styles.iconContainer}>
              <MaterialCommunityIcons
                name={action.icon as any}
                size={24}
                color="#C084FC" // Purple
              />
            </View>

            <Text style={styles.actionLabel}>{action.label}</Text>
          </TouchableOpacity>
        ))}
      </View>
    </View>
  );
};

export default QuickActions;

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginTop: 16,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 16,
  },
  actionsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  actionButton: {
    width: '48%',
    alignItems: 'center',
    marginBottom: 16,
  },
  iconContainer: {
    width: 56,
    height: 56,
    borderRadius: 12,
    backgroundColor: '#FAF5FF', // Light purple background
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 8,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  actionLabel: {
    fontSize: 13,
    color: '#475569',
    textAlign: 'center',
  },
});
========================================
FILE: src/components/StatsOverview.tsx
========================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface StatsOverviewProps {
  dailyQuota: {
    limit: number;
    remaining: number;
    used: number;
  };
  permissions: number;
  departments: number;
  isLoading: boolean;
}

const StatsOverview: React.FC<StatsOverviewProps> = ({
  dailyQuota,
  permissions,
  departments,
  isLoading,
}) => {
  const stats = [
    {
      icon: 'shield-check',
      label: 'Permissions',
      value: permissions.toString(),
      color: '#C084FC', // Purple
      bgColor: '#FAF5FF',
    },
    {
      icon: 'office-building',
      label: 'Departments',
      value: departments.toString(),
      color: '#A855F7', // Purple
      bgColor: '#F3E8FF',
    },
    {
      icon: 'chart-bar',
      label: 'Quota Used',
      value: dailyQuota.used.toString(),
      color: '#9333EA', // Purple
      bgColor: '#E9D5FF',
    },
    {
      icon: 'clock-outline',
      label: 'Quota Left',
      value: dailyQuota.remaining.toString(),
      color: '#7C3AED', // Purple
      bgColor: '#DDD6FE',
    },
  ];

  if (isLoading) {
    return (
      <View style={styles.container}>
        <Text>Loading stats...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Overview</Text>

      <View style={styles.statsGrid}>
        {stats.map((stat, index) => (
          <View key={index} style={styles.statCard}>
            <View
              style={[
                styles.iconContainer,
                { backgroundColor: stat.bgColor },
              ]}
            >
              <MaterialCommunityIcons
                name={stat.icon as any}
                size={20}
                color={stat.color}
              />
            </View>

            <Text style={styles.statValue}>{stat.value}</Text>
            <Text style={styles.statLabel}>{stat.label}</Text>
          </View>
        ))}
      </View>
    </View>
  );
};

export default StatsOverview;

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginTop: 16,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  title: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 16,
  },
  statsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  statCard: {
    width: '48%',
    alignItems: 'center',
    paddingVertical: 12,
    marginBottom: 12,
  },
  iconContainer: {
    width: 40,
    height: 40,
    borderRadius: 10,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 8,
  },
  statValue: {
    fontSize: 20,
    fontWeight: '700',
    color: '#1E293B',
    marginBottom: 2,
  },
  statLabel: {
    fontSize: 12,
    color: '#64748B',
  },
});
========================================
FILE: src/components/Toast.tsx
========================================

import React, { createContext, useContext, useState, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Animated,
  TouchableOpacity,
  Dimensions,
} from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

const { width } = Dimensions.get('window');

interface ToastContextType {
  showToast: (
    type: 'success' | 'error' | 'info',
    message: string,
    duration?: number
  ) => void;
  hideToast: () => void;
}

const ToastContext = createContext<ToastContextType | undefined>(undefined);

export const useToast = () => {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within ToastProvider');
  }
  return context;
};

interface ToastProps {
  type: 'success' | 'error' | 'info';
  message: string;
  visible: boolean;
  onHide: () => void;
}

const Toast: React.FC<ToastProps> = ({ type, message, visible, onHide }) => {
  const [animation] = useState(new Animated.Value(0));

  React.useEffect(() => {
    if (visible) {
      Animated.spring(animation, {
        toValue: 1,
        useNativeDriver: true,
        tension: 50,
        friction: 7,
      }).start();

      const timer = setTimeout(() => {
        hide();
      }, 3000);

      return () => clearTimeout(timer);
    } else {
      hide();
    }
  }, [visible]);

  const hide = () => {
    Animated.spring(animation, {
      toValue: 0,
      useNativeDriver: true,
      tension: 50,
      friction: 7,
    }).start(() => {
      onHide();
    });
  };

  const getConfig = () => {
    switch (type) {
      case 'success':
        return {
          icon: 'check-circle',
          color: '#10B981',
          bgColor: '#D1FAE5',
          borderColor: '#A7F3D0',
        };
      case 'error':
        return {
          icon: 'alert-circle',
          color: '#EF4444',
          bgColor: '#FEE2E2',
          borderColor: '#FECACA',
        };
      case 'info':
      default:
        return {
          icon: 'information',
          color: '#C084FC', // Purple
          bgColor: '#FAF5FF',
          borderColor: '#E9D5FF',
        };
    }
  };

  const config = getConfig();

  const translateY = animation.interpolate({
    inputRange: [0, 1],
    outputRange: [-100, 10],
  });

  if (!visible) return null;

  return (
    <Animated.View
      style={[
        styles.container,
        {
          backgroundColor: config.bgColor,
          borderColor: config.borderColor,
          transform: [{ translateY }],
        },
      ]}
    >
      <View style={styles.content}>
        <MaterialCommunityIcons
          name={config.icon as any}
          size={20}
          color={config.color}
        />

        <Text style={[styles.message, { color: config.color }]}>
          {message}
        </Text>

        <TouchableOpacity onPress={hide} style={styles.closeButton}>
          <MaterialCommunityIcons
            name="close"
            size={16}
            color={config.color}
          />
        </TouchableOpacity>
      </View>
    </Animated.View>
  );
};

export const ToastProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [toast, setToast] = useState<{
    type: 'success' | 'error' | 'info';
    message: string;
    visible: boolean;
  }>({
    type: 'success',
    message: '',
    visible: false,
  });

  const showToast = useCallback(
    (type: 'success' | 'error' | 'info', message: string, duration = 3000) => {
      setToast({ type, message, visible: true });
    },
    []
  );

  const hideToast = useCallback(() => {
    setToast(prev => ({ ...prev, visible: false }));
  }, []);

  return (
    <ToastContext.Provider value={{ showToast, hideToast }}>
      {children}
      <Toast
        type={toast.type}
        message={toast.message}
        visible={toast.visible}
        onHide={hideToast}
      />
    </ToastContext.Provider>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    top: 0,
    left: 20,
    right: 20,
    borderRadius: 8,
    borderWidth: 1,
    padding: 16,
    zIndex: 9999,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 8,
  },
  content: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  message: {
    flex: 1,
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 12,
    marginRight: 8,
  },
  closeButton: {
    padding: 4,
  },
});
========================================
FILE: src/contexts/AuthContext.tsx
========================================

import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { AdminInfo, AuthTokens, LoginFlowState, ApiError } from '@/types';
import { api } from '@/services/api';
import { 
  getItem, 
  setItem, 
  removeItem, 
  clearSessionData,
  STORAGE_KEYS,
  hasStoredPhoneNumber,
  getFormattedPhoneNumber
} from '@/services/storage';
import { getStoredDeviceInfo } from '@/services/deviceInfo';
import { useQueryClient } from '@tanstack/react-query';

interface AuthContextType {
  isAuthenticated: boolean;
  isLoading: boolean;
  isInitializing: boolean;
  adminInfo: AdminInfo | null;
  tokens: AuthTokens | null;
  phoneNumber: string | null;
  loginFlow: LoginFlowState | null;
  login: (phone: string, tokens: AuthTokens, adminInfo: AdminInfo) => Promise<void>;
  logout: () => Promise<void>;
  refreshAuth: () => Promise<boolean>;
  updateAdminInfo: (info: Partial<AdminInfo>) => void;
  checkExistingSession: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [isInitializing, setIsInitializing] = useState(true);
  const [adminInfo, setAdminInfo] = useState<AdminInfo | null>(null);
  const [tokens, setTokens] = useState<AuthTokens | null>(null);
  const [phoneNumber, setPhoneNumber] = useState<string | null>(null);
  const [loginFlow, setLoginFlow] = useState<LoginFlowState | null>(null);
  const queryClient = useQueryClient();

  const initializeAuth = useCallback(async () => {
    try {
      setIsInitializing(true);
      
      const hasPhone = await hasStoredPhoneNumber();
      const formattedPhone = await getFormattedPhoneNumber();
      
      if (hasPhone && formattedPhone) {
        setPhoneNumber(formattedPhone);
        
        const accessToken = await getItem(STORAGE_KEYS.ACCESS_TOKEN);
        const refreshToken = await getItem(STORAGE_KEYS.REFRESH_TOKEN);
        const storedAdminInfo = await getItem(STORAGE_KEYS.ADMIN_INFO);
        
        if (accessToken && refreshToken && storedAdminInfo) {
          const adminInfoData = JSON.parse(storedAdminInfo);
          const tokensData: AuthTokens = {
            access_token: accessToken,
            refresh_token: refreshToken,
            expires_in: 900,
            token_type: 'Bearer'
          };
          
          setAdminInfo(adminInfoData);
          setTokens(tokensData);
          setIsAuthenticated(true);
          
          startTokenRefresh();
        }
      }
    } catch (error) {
      console.error('Auth initialization error:', error);
      await clearSessionData();
    } finally {
      setIsLoading(false);
      setIsInitializing(false);
    }
  }, []);

  useEffect(() => {
    initializeAuth();
  }, [initializeAuth]);

  const startTokenRefresh = useCallback(() => {
    const refreshInterval = setInterval(async () => {
      try {
        const refreshToken = await getItem(STORAGE_KEYS.REFRESH_TOKEN);
        if (refreshToken) {
          const response = await api.refreshToken(refreshToken);
          const newTokens = response.data;
          
          await setItem(STORAGE_KEYS.ACCESS_TOKEN, newTokens.access_token);
          await setItem(STORAGE_KEYS.REFRESH_TOKEN, newTokens.refresh_token);
          
          setTokens(newTokens);
        }
      } catch (error) {
        console.error('Token refresh failed:', error);
        await logout();
      }
    }, 4.5 * 60 * 1000);

    return () => clearInterval(refreshInterval);
  }, []);

  const login = useCallback(async (
    phone: string, 
    tokensData: AuthTokens, 
    adminInfoData: AdminInfo
  ) => {
    try {
      const phoneWithoutCountryCode = phone.replace('+91', '');
      await setItem(STORAGE_KEYS.PHONE_NUMBER, phoneWithoutCountryCode);
      await setItem(STORAGE_KEYS.COUNTRY_CODE, '+91');
      await setItem(STORAGE_KEYS.ACCESS_TOKEN, tokensData.access_token);
      await setItem(STORAGE_KEYS.REFRESH_TOKEN, tokensData.refresh_token);
      await setItem(STORAGE_KEYS.ADMIN_INFO, JSON.stringify(adminInfoData));
      await setItem(STORAGE_KEYS.ADMIN_ID, adminInfoData.admin_id);

      setPhoneNumber(phone);
      setTokens(tokensData);
      setAdminInfo(adminInfoData);
      setIsAuthenticated(true);

      startTokenRefresh();
    } catch (error) {
      console.error('Login error:', error);
      throw error;
    }
  }, [startTokenRefresh]);

  const logout = useCallback(async () => {
    try {
      const refreshToken = await getItem(STORAGE_KEYS.REFRESH_TOKEN);
      if (refreshToken) {
        await api.logout(refreshToken);
      }
    } catch (error) {
      console.error('Logout API error:', error);
    } finally {
      await clearSessionData();
      queryClient.clear();
      setIsAuthenticated(false);
      setAdminInfo(null);
      setTokens(null);
      setLoginFlow(null);
    }
  }, [queryClient]);

  const refreshAuth = useCallback(async (): Promise<boolean> => {
    try {
      const refreshToken = await getItem(STORAGE_KEYS.REFRESH_TOKEN);
      if (!refreshToken) return false;

      const response = await api.refreshToken(refreshToken);
      const newTokens = response.data;
      
      await setItem(STORAGE_KEYS.ACCESS_TOKEN, newTokens.access_token);
      await setItem(STORAGE_KEYS.REFRESH_TOKEN, newTokens.refresh_token);
      
      setTokens(newTokens);
      return true;
    } catch (error) {
      console.error('Auth refresh failed:', error);
      await logout();
      return false;
    }
  }, [logout]);

  const updateAdminInfo = useCallback((info: Partial<AdminInfo>) => {
    setAdminInfo((prev: AdminInfo | null) => prev ? { ...prev, ...info } : null);
    
    if (adminInfo) {
      const updatedInfo = { ...adminInfo, ...info };
      setItem(STORAGE_KEYS.ADMIN_INFO, JSON.stringify(updatedInfo));
    }
  }, [adminInfo]);

  const checkExistingSession = useCallback(async () => {
    try {
      const formattedPhone = await getFormattedPhoneNumber();
      if (!formattedPhone) return;

      const response = await api.loginInitiate(formattedPhone);
      
      if (response.data.success) {
        const { user_exists, has_mpin, mpin_locked, device_trusted } = response.data.data;
        
        if (user_exists && !mpin_locked) {
          if (device_trusted && has_mpin) {
            setLoginFlow('existing_user_mpin');
          } else if (!device_trusted) {
            setLoginFlow('device_not_trusted');
          } else if (!has_mpin) {
            setLoginFlow('new_user_no_mpin');
          }
        }
      }
    } catch (error) {
      console.error('Session check error:', error);
    }
  }, []);

  const value: AuthContextType = {
    isAuthenticated,
    isLoading,
    isInitializing,
    adminInfo,
    tokens,
    phoneNumber,
    loginFlow,
    login,
    logout,
    refreshAuth,
    updateAdminInfo,
    checkExistingSession,
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};
========================================
FILE: src/contexts/QueryProvider.tsx
========================================

import React from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager } from '@tanstack/react-query';

// Set up network status for React Query
onlineManager.setEventListener(setOnline => {
  return NetInfo.addEventListener(state => {
    setOnline(!!state.isConnected);
  });
});

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
      staleTime: 5 * 60 * 1000, // 5 minutes
      gcTime: 10 * 60 * 1000, // 10 minutes (cacheTime is now gcTime in v5)
      networkMode: 'offlineFirst',
      refetchOnWindowFocus: false,
      refetchOnReconnect: true,
    },
    mutations: {
      retry: 1,
    },
  },
});

export const QueryProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};
========================================
FILE: src/navigation/AppNavigator.tsx
========================================

import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { useAuth } from '@/contexts/AuthContext';

// Screens
import LoginInitiateScreen from '@/screens/auth/LoginInitiateScreen';
import SendOTPScreen from '@/screens/auth/SendOTPScreen';
import VerifyOTPScreen from '@/screens/auth/VerifyOTPScreen';
import SetupMPINScreen from '@/screens/auth/SetupMPINScreen';
import VerifyMPINScreen from '@/screens/auth/VerifyMPINScreen';
import ForgotMPINScreen from '@/screens/auth/ForgotMPINScreen';
import MainDashboardScreen from '@/screens/dashboard/MainDashboardScreen';
import ProfileScreen from '@/screens/profile/ProfileScreen';
import ChangeMPINScreen from '@/screens/profile/ChangeMPINScreen';
import DepartmentScreen from '@/screens/dashboard/DepartmentScreen';

const Stack = createNativeStackNavigator();

export default function AppNavigator() {
  const { isAuthenticated, isLoading } = useAuth();

  // Show loading screen
  if (isLoading) {
    return null; // Or a simple loading component
  }

  return (
    <Stack.Navigator screenOptions={{ headerShown: false }}>
      {!isAuthenticated ? (
        <>
          <Stack.Screen name="LoginInitiate" component={LoginInitiateScreen} />
          <Stack.Screen name="SendOTP" component={SendOTPScreen} />
          <Stack.Screen name="VerifyOTP" component={VerifyOTPScreen} />
          <Stack.Screen name="SetupMPIN" component={SetupMPINScreen} />
          <Stack.Screen name="VerifyMPIN" component={VerifyMPINScreen} />
          <Stack.Screen name="ForgotMPIN" component={ForgotMPINScreen} />
        </>
      ) : (
        <>
          <Stack.Screen name="MainDashboard" component={MainDashboardScreen} />
          <Stack.Screen name="Profile" component={ProfileScreen} />
          <Stack.Screen name="ChangeMPIN" component={ChangeMPINScreen} />
          <Stack.Screen name="Department" component={DepartmentScreen} />
        </>
      )}
    </Stack.Navigator>
  );
}
========================================
FILE: src/screens/AnimatedPrayantraLogo.tsx
========================================

import React, { useEffect, useRef } from 'react';
import { Animated, Easing, View } from 'react-native';
import Svg, {
  Path,
  Circle,
  Defs,
  LinearGradient,
  RadialGradient,
  Stop,
} from 'react-native-svg';

interface Props {
  size?: number;
}

const AnimatedPrayantraLogo: React.FC<Props> = ({ size = 180 }) => {
  const blinkAnim = useRef(new Animated.Value(1)).current;

  useEffect(() => {
    Animated.sequence([
      Animated.delay(800),
      Animated.timing(blinkAnim, {
        toValue: 0.08,
        duration: 120,
        easing: Easing.linear,
        useNativeDriver: true,
      }),
      Animated.timing(blinkAnim, {
        toValue: 1,
        duration: 140,
        easing: Easing.linear,
        useNativeDriver: true,
      }),
    ]).start();
  }, []);

  return (
    <View style={{ width: size, height: size }}>
      <Svg width="100%" height="100%" viewBox="0 0 200 200">

        <Defs>
          <LinearGradient id="mainGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <Stop offset="0%" stopColor="#4F7CFF" />
            <Stop offset="100%" stopColor="#5FE0C7" />
          </LinearGradient>

          <RadialGradient id="eyeGlow" cx="50%" cy="50%" r="50%">
            <Stop offset="0%" stopColor="#FFFFFF" />
            <Stop offset="100%" stopColor="#EAF0FF" />
          </RadialGradient>
        </Defs>

        {/* Outer Ring */}
        <Circle
          cx="100"
          cy="100"
          r="88"
          stroke="url(#mainGradient)"
          strokeWidth="10"
        />

        {/* Animated Eye Container */}
        <Animated.View
          style={{
            position: 'absolute',
            width: size,
            height: size,
            transform: [{ scaleY: blinkAnim }],
          }}
        >
          <Svg width="100%" height="100%" viewBox="0 0 200 200">
            <Path
              d="M70 100 C82 82, 118 82, 130 100
                 C118 118, 82 118, 70 100Z"
              fill="url(#eyeGlow)"
              stroke="url(#mainGradient)"
              strokeWidth={3}
            />

            {/* Pupil */}
            <Circle cx="100" cy="100" r="10" fill="url(#mainGradient)" />

            {/* Reflection */}
            <Circle cx="96" cy="96" r="3" fill="#FFFFFF" />
          </Svg>
        </Animated.View>

      </Svg>
    </View>
  );
};

export default AnimatedPrayantraLogo;

========================================
FILE: src/screens/SplashScreen.tsx
========================================

import React, { useEffect, useRef } from 'react';
import { 
  View, 
  StyleSheet, 
  Animated, 
  Easing, 
  Dimensions,
  Text 
} from 'react-native';
import Svg, {
  Path,
  Defs,
  LinearGradient,
  RadialGradient,
  Stop,
  Circle,
  G,
} from 'react-native-svg';

const { width, height } = Dimensions.get('window');

// Main color from your Expo config - ONLY FOR BACKGROUND
const SPLASH_BACKGROUND_COLOR = '#C084FC';
// Original logo colors (keeping these from your original design)
const LOGO_GRADIENT_START = '#4A00E0';
const LOGO_GRADIENT_MID = '#8E2DE2';
const LOGO_GRADIENT_END = '#00B4DB';
const LIGHT_BLUE = '#00B4DB';
const WHITE_GLOW = '#FFFFFF';

const SplashScreen: React.FC = () => {
  const rotateAnim = useRef(new Animated.Value(0)).current;
  const scaleAnim = useRef(new Animated.Value(0.8)).current;
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const floatAnim = useRef(new Animated.Value(0)).current;
  const ring1Anim = useRef(new Animated.Value(0)).current;
  const ring2Anim = useRef(new Animated.Value(0)).current;
  const dashAnim = useRef(new Animated.Value(0)).current;
  const particleAnims = useRef([...Array(6)].map(() => new Animated.Value(0))).current;
  const cubeAnim = useRef(new Animated.Value(0)).current;
  const textFadeAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    // Start all animations
    Animated.parallel([
      // Rotating animation
      Animated.loop(
        Animated.timing(rotateAnim, {
          toValue: 1,
          duration: 20000,
          easing: Easing.linear,
          useNativeDriver: true,
        })
      ),
      
      // Pulsing scale animation
      Animated.loop(
        Animated.sequence([
          Animated.timing(scaleAnim, {
            toValue: 1.1,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(scaleAnim, {
            toValue: 0.9,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ])
      ),
      
      // Fade in animation
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 1000,
        useNativeDriver: true,
      }),
      
      // Floating animation
      Animated.loop(
        Animated.sequence([
          Animated.timing(floatAnim, {
            toValue: 1,
            duration: 3000,
            easing: Easing.inOut(Easing.sin),
            useNativeDriver: true,
          }),
          Animated.timing(floatAnim, {
            toValue: 0,
            duration: 3000,
            easing: Easing.inOut(Easing.sin),
            useNativeDriver: true,
          }),
        ])
      ),
      
      // Text fade in animation (delayed)
      Animated.sequence([
        Animated.delay(500),
        Animated.timing(textFadeAnim, {
          toValue: 1,
          duration: 1000,
          useNativeDriver: true,
        }),
      ]),
      
      // Ring animations
      Animated.loop(
        Animated.sequence([
          Animated.timing(ring1Anim, {
            toValue: 1,
            duration: 2000,
            easing: Easing.inOut(Easing.sin),
            useNativeDriver: false,
          }),
          Animated.timing(ring1Anim, {
            toValue: 0,
            duration: 2000,
            easing: Easing.inOut(Easing.sin),
            useNativeDriver: false,
          }),
        ])
      ),
      
      Animated.loop(
        Animated.sequence([
          Animated.timing(ring2Anim, {
            toValue: 1,
            duration: 1500,
            easing: Easing.inOut(Easing.sin),
            useNativeDriver: false,
          }),
          Animated.timing(ring2Anim, {
            toValue: 0,
            duration: 1500,
            easing: Easing.inOut(Easing.sin),
            useNativeDriver: false,
          }),
        ])
      ),
      
      // Dash animation
      Animated.loop(
        Animated.timing(dashAnim, {
          toValue: 1,
          duration: 1500,
          easing: Easing.linear,
          useNativeDriver: false,
        })
      ),
      
      // Cube rotation
      Animated.loop(
        Animated.timing(cubeAnim, {
          toValue: 1,
          duration: 10000,
          easing: Easing.linear,
          useNativeDriver: false,
        })
      ),
      
      // Particle animations (around logo center only)
      ...particleAnims.map((anim, index) => 
        Animated.loop(
          Animated.sequence([
            Animated.timing(anim, {
              toValue: 1,
              duration: 1000 + index * 200,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
            Animated.timing(anim, {
              toValue: 0,
              duration: 1000 + index * 200,
              easing: Easing.inOut(Easing.sin),
              useNativeDriver: false,
            }),
          ])
        )
      ),
    ]).start();
  }, []);

  const rotate = rotateAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });

  const floatY = floatAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -20],
  });

  const opacity = fadeAnim;
  const textOpacity = textFadeAnim;

  const ring1Radius = ring1Anim.interpolate({
    inputRange: [0, 1],
    outputRange: [85, 95],
  });

  const ring2Radius = ring2Anim.interpolate({
    inputRange: [0, 1],
    outputRange: [70, 75],
  });

  const dashOffset = dashAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 20],
  });

  const dashOffset2 = dashAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [20, 0],
  });

  const cubeRotate = cubeAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0 100 100', '45 100 100'],
  });

  return (
    <View style={[styles.container, { backgroundColor: SPLASH_BACKGROUND_COLOR }]}>
      {/* Animated background gradient - using your purple color */}
      <Animated.View style={[styles.background, { opacity }]}>
        <Svg width={width} height={height} style={styles.backgroundSvg}>
          <Defs>
            <LinearGradient id="bgGrad" x1="0%" y1="0%" x2="100%" y2="100%">
              <Stop offset="0%" stopColor="#9D4EDD" />
              <Stop offset="50%" stopColor={SPLASH_BACKGROUND_COLOR} />
              <Stop offset="100%" stopColor="#E0AAFF" />
            </LinearGradient>
          </Defs>
          <Path d={`M0,0 H${width} V${height} H0 Z`} fill="url(#bgGrad)" />
        </Svg>
      </Animated.View>

      {/* Main animated logo - KEEPING ORIGINAL BLUE COLORS */}
      <Animated.View
        style={[
          styles.logoContainer,
          {
            transform: [
              { rotate },
              { scale: scaleAnim },
              { translateY: floatY },
            ],
            opacity,
          },
        ]}
      >
        <Svg width={200} height={200} viewBox="0 0 200 200">
          <Defs>
            {/* ORIGINAL LOGO GRADIENTS */}
            <LinearGradient id="splashGrad1" x1="0%" y1="0%" x2="100%" y2="100%">
              <Stop offset="0%" stopColor={LOGO_GRADIENT_START} stopOpacity="1" />
              <Stop offset="50%" stopColor={LOGO_GRADIENT_MID} stopOpacity="1" />
              <Stop offset="100%" stopColor={LOGO_GRADIENT_END} stopOpacity="1" />
            </LinearGradient>
            
            <LinearGradient id="splashGrad2" x1="0%" y1="0%" x2="0%" y2="100%">
              <Stop offset="0%" stopColor={LOGO_GRADIENT_END} stopOpacity="0.9" />
              <Stop offset="100%" stopColor="#0083B0" stopOpacity="0.9" />
            </LinearGradient>
            
            <RadialGradient id="centerGlow" cx="50%" cy="50%" r="50%">
              <Stop offset="0%" stopColor="#FFFFFF" stopOpacity="0.3" />
              <Stop offset="100%" stopColor="#FFFFFF" stopOpacity="0" />
            </RadialGradient>
          </Defs>
          
          {/* Animated outer rings */}
          <G>
            <AnimatedCircle 
              cx="100"
              cy="100"
              r={ring1Radius}
              fill="none"
              stroke="url(#splashGrad1)"
              strokeWidth="2"
            />
            
            <AnimatedCircle 
              cx="100"
              cy="100"
              r={ring2Radius}
              fill="none"
              stroke="rgba(142, 45, 226, 0.4)"
              strokeWidth="1.5"
            />
          </G>
          
          {/* Central core with animations */}
          <G>
            <Circle cx="100" cy="100" r="30" fill="url(#splashGrad2)" />
            
            {/* Neural network paths */}
            <AnimatedPath
              d="M70,100 Q100,70 130,100 Q100,130 70,100"
              fill="none"
              stroke="rgba(255,255,255,0.5)"
              strokeWidth="1.5"
              strokeDasharray="5,5"
              strokeDashoffset={dashOffset}
            />
            
            <AnimatedPath
              d="M100,70 Q130,100 100,130 Q70,100 100,70"
              fill="none"
              stroke="rgba(255,255,255,0.5)"
              strokeWidth="1.5"
              strokeDasharray="5,5"
              strokeDashoffset={dashOffset2}
            />
            
            {/* Animated particles around center - ORIGINAL BLUE COLOR */}
            {[...Array(6)].map((_, i) => {
              const angle = (i * 60) * Math.PI / 180;
              const radius = 50;
              const x = 100 + radius * Math.cos(angle);
              const y = 100 + radius * Math.sin(angle);
              
              return (
                <AnimatedCircle
                  key={i}
                  cx={x}
                  cy={y}
                  r={particleAnims[i].interpolate({
                    inputRange: [0, 1],
                    outputRange: [4, 6],
                  })}
                  fill={LOGO_GRADIENT_END}
                  opacity={particleAnims[i].interpolate({
                    inputRange: [0, 1],
                    outputRange: [0.7, 1],
                  })}
                />
              );
            })}
            
            {/* Center tech element with rotation */}
            <AnimatedPath
              d="M90,90 L110,90 L110,110 L90,110 Z"
              fill="none"
              stroke="white"
              strokeWidth="2"
              strokeLinecap="round"
              rotation={cubeRotate}
            />
            
            {/* Center glow */}
            <Circle cx="100" cy="100" r="35" fill="url(#centerGlow)" />
          </G>
        </Svg>
      </Animated.View>

      {/* App name with fade-in animation and box styling */}
      <Animated.View style={[styles.textContainer, { opacity: textOpacity }]}>
        <Text style={styles.appName}>PRAYANTRA</Text>
        <Text style={styles.tagline}>Powering Enterprises</Text>
        <Text style={styles.subtitle}>Integrated  Efficient  Future-ready</Text>
      </Animated.View>

      {/* Loading dots - ORIGINAL BLUE COLOR */}
      <Animated.View style={[styles.loadingContainer, { opacity }]}>
        {[...Array(3)].map((_, i) => (
          <Animated.View
            key={i}
            style={[
              styles.loadingDot,
              {
                backgroundColor: LIGHT_BLUE,
                opacity: fadeAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, 1],
                }),
              },
            ]}
          >
            <Animated.View
              style={[
                styles.dotInner,
                {
                  transform: [
                    {
                      scale: fadeAnim.interpolate({
                        inputRange: [0, 0.5, 1],
                        outputRange: [0, 1, 0],
                      }),
                    },
                  ],
                },
              ]}
            />
          </Animated.View>
        ))}
      </Animated.View>
    </View>
  );
};

// Helper components for animated SVG elements
const AnimatedCircle = ({ cx, cy, r, fill, stroke, strokeWidth, opacity, ...props }: any) => {
  return (
    <Circle
      cx={typeof cx === 'string' ? cx : cx?.__getValue?.() ?? cx}
      cy={typeof cy === 'string' ? cy : cy?.__getValue?.() ?? cy}
      r={typeof r === 'string' ? r : r?.__getValue?.() ?? r}
      fill={fill}
      stroke={stroke}
      strokeWidth={strokeWidth}
      opacity={typeof opacity === 'string' ? opacity : opacity?.__getValue?.() ?? opacity}
      {...props}
    />
  );
};

const AnimatedPath = ({ d, fill, stroke, strokeWidth, strokeDasharray, strokeDashoffset, rotation, ...props }: any) => {
  const transform = rotation ? `rotate(${typeof rotation === 'string' ? rotation : rotation?.__getValue?.() ?? rotation})` : undefined;
  
  return (
    <Path
      d={d}
      fill={fill}
      stroke={stroke}
      strokeWidth={strokeWidth}
      strokeDasharray={strokeDasharray}
      strokeDashoffset={typeof strokeDashoffset === 'string' ? strokeDashoffset : strokeDashoffset?.__getValue?.() ?? strokeDashoffset}
      transform={transform}
      {...props}
    />
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: SPLASH_BACKGROUND_COLOR, // Your Expo color
    alignItems: 'center',
    justifyContent: 'center',
  },
  background: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  },
  backgroundSvg: {
    position: 'absolute',
  },
  logoContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 40,
  },
  textContainer: {
    alignItems: 'center',
    marginTop: 30,
    paddingHorizontal: 30,
    paddingVertical: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.15)', // Semi-transparent white
    borderRadius: 20,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.3)',
  },
  appName: {
    fontSize: 42,
    fontWeight: 'bold',
    color: 'white',
    letterSpacing: 3,
    marginBottom: 10,
    textShadowColor: 'rgba(74, 0, 224, 0.5)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 15,
  },
  tagline: {
    fontSize: 22,
    color: LIGHT_BLUE, // Original blue color
    fontWeight: '600',
    marginBottom: 6,
    letterSpacing: 1,
    textShadowColor: 'rgba(0, 180, 219, 0.3)',
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 10,
  },
  subtitle: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.95)',
    fontWeight: '500',
    letterSpacing: 0.5,
    textAlign: 'center',
    lineHeight: 20,
  },
  loadingContainer: {
    flexDirection: 'row',
    marginTop: 50,
    alignItems: 'center',
  },
  loadingDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
    marginHorizontal: 6,
    backgroundColor: LIGHT_BLUE, // Original blue color
    shadowColor: LIGHT_BLUE,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.8,
    shadowRadius: 5,
    elevation: 5,
    overflow: 'hidden',
  },
  dotInner: {
    width: '100%',
    height: '100%',
    backgroundColor: 'white',
    borderRadius: 6,
  },
});

export default SplashScreen;
========================================
FILE: src/screens/auth/ForgotMPINScreen.tsx
========================================

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { useNavigation, NavigationProp, RouteProp, useRoute } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { api } from '@/services/api';
import { useToast } from '@/components/Toast';
import PrayantraLogo from '@/components/PrayantraLogo';
import OTPInput from '@/components/OTPInput';
import MPINInput from '@/components/MPINInput';
import { getFormattedPhoneNumber } from '@/services/storage';

// Define navigation types
type RootStackParamList = {
  LoginInitiate: undefined;
  SendOTP: { phoneNumber: string; adminId?: string };
  VerifyOTP: { phoneNumber: string; adminId?: string };
  SetupMPIN: { phoneNumber: string; adminId: string };
  VerifyMPIN: { phoneNumber?: string; adminId?: string };
  ForgotMPIN: { phoneNumber?: string };
  MainDrawer: undefined;
};

type ForgotMPINScreenRouteProp = RouteProp<RootStackParamList, 'ForgotMPIN'>;

const ForgotMPINScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const route = useRoute<ForgotMPINScreenRouteProp>();
  const params = route.params;
  
  const { showToast } = useToast();

  const [phoneNumber, setPhoneNumber] = useState('');
  const [step, setStep] = useState(1); // 1: Request OTP, 2: Verify OTP, 3: Setup new MPIN
  const [otp, setOtp] = useState('');
  const [mpin, setMpin] = useState('');
  const [confirmMpin, setConfirmMpin] = useState('');
  const [timer, setTimer] = useState(60);
  const [canResend, setCanResend] = useState(false);
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    const loadPhoneNumber = async () => {
      if (params?.phoneNumber) {
        setPhoneNumber(params.phoneNumber);
      } else {
        const storedPhone = await getFormattedPhoneNumber();
        if (storedPhone) {
          setPhoneNumber(storedPhone);
        }
      }
    };
    loadPhoneNumber();
  }, [params?.phoneNumber]);

  useEffect(() => {
    if (step === 1) {
      startTimer();
    }
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, [step]);

  const startTimer = () => {
    setCanResend(false);
    setTimer(60);
    
    if (timerRef.current) {
      clearInterval(timerRef.current);
    }

    timerRef.current = setInterval(() => {
      setTimer((prev) => {
        if (prev <= 1) {
          setCanResend(true);
          if (timerRef.current) {
            clearInterval(timerRef.current);
          }
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
  };

  const forgotMPINMutation = useMutation({
    mutationFn: () => api.forgotMPIN(phoneNumber),
    onSuccess: () => {
      showToast('success', 'OTP sent successfully for MPIN reset');
      setStep(2);
      startTimer();
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.message || 'Failed to send OTP';
      showToast('error', errorMessage);
    },
    onSettled: () => {
      setIsLoading(false);
    },
  });

  const verifyForgotMPINMutation = useMutation({
    mutationFn: (data: { otpCode: string; newMpin: string }) => 
      api.verifyForgotMPIN(phoneNumber, data.otpCode, data.newMpin),
    onSuccess: () => {
      showToast('success', 'MPIN reset successful. Please login with your new MPIN.');
      navigation.navigate('VerifyMPIN', { phoneNumber });
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.message || 'Failed to reset MPIN';
      setError(errorMessage);
      showToast('error', errorMessage);
    },
    onSettled: () => {
      setIsLoading(false);
    },
  });

  const handleRequestOTP = () => {
    if (!phoneNumber) {
      showToast('error', 'Please enter your phone number');
      return;
    }

    setIsLoading(true);
    forgotMPINMutation.mutate();
  };

  const handleVerifyOTP = () => {
    if (otp.length !== 6) {
      showToast('error', 'Please enter 6-digit OTP');
      return;
    }
    setStep(3);
  };

  const handleMPINComplete = (enteredMpin: string) => {
    if (mpin === '') {
      // First MPIN entry
      if (isWeakMpin(enteredMpin)) {
        setError('MPIN is too weak. Please choose a stronger MPIN.');
        return;
      }
      setMpin(enteredMpin);
      setError('');
    } else {
      // Confirm MPIN
      if (enteredMpin === mpin) {
        setIsLoading(true);
        verifyForgotMPINMutation.mutate({
          otpCode: otp,
          newMpin: enteredMpin
        });
      } else {
        setError('MPIN does not match. Please try again.');
        setMpin('');
      }
    }
  };

  const handleResendOTP = () => {
    if (!canResend && timer > 0) {
      showToast('info', `Please wait ${timer} seconds before resending`);
      return;
    }
    setIsLoading(true);
    forgotMPINMutation.mutate();
  };

  const isWeakMpin = (mpin: string) => {
    const weakPatterns = [
      '111111', '222222', '333333', '444444', '555555',
      '666666', '777777', '888888', '999999', '000000',
      '123456', '654321', '121212', '123123', '112233'
    ];
    return weakPatterns.includes(mpin) || 
           mpin.split('').every((digit, i, arr) => digit === arr[0]);
  };

  const renderStep = () => {
    switch (step) {
      case 1:
        return (
          <>
            <Text style={styles.title}>Forgot MPIN</Text>
            <Text style={styles.subtitle}>
              Enter your registered phone number to reset MPIN
            </Text>

            <View style={styles.phoneContainer}>
              <Text style={styles.phoneLabel}>Phone Number</Text>
              <Text style={styles.phoneNumber}>{phoneNumber || 'Not set'}</Text>
            </View>

            <Text style={styles.instruction}>
              We'll send an OTP to verify your identity and reset your MPIN.
            </Text>

            <TouchableOpacity
              style={[styles.button, isLoading && styles.buttonDisabled]}
              onPress={handleRequestOTP}
              disabled={isLoading || !phoneNumber}
            >
              <Text style={styles.buttonText}>
                {isLoading ? 'Sending OTP...' : 'Send OTP'}
              </Text>
            </TouchableOpacity>
          </>
        );

      case 2:
        return (
          <>
            <Text style={styles.title}>Verify OTP</Text>
            <Text style={styles.subtitle}>
              Enter the 6-digit OTP sent to {phoneNumber}
            </Text>

            <View style={styles.timerContainer}>
              <Text style={styles.timerText}>
                OTP expires in: {timer}s
              </Text>
            </View>

            <OTPInput
              length={6}
              onComplete={setOtp}
              error={!!error}
              disabled={isLoading}
              autoFocus={true}
            />

            <TouchableOpacity
              style={[styles.button, (isLoading || otp.length !== 6) && styles.buttonDisabled]}
              onPress={handleVerifyOTP}
              disabled={isLoading || otp.length !== 6}
            >
              <Text style={styles.buttonText}>
                {isLoading ? 'Verifying...' : 'Verify OTP'}
              </Text>
            </TouchableOpacity>

            <View style={styles.resendContainer}>
              <Text style={styles.resendText}>Didn't receive OTP?</Text>
              <TouchableOpacity
                onPress={handleResendOTP}
                disabled={!canResend || isLoading}
              >
                <Text style={[
                  styles.resendButton,
                  (!canResend || isLoading) && styles.resendButtonDisabled
                ]}>
                  {canResend ? 'Resend OTP' : `Resend in ${timer}s`}
                </Text>
              </TouchableOpacity>
            </View>
          </>
        );

      case 3:
        return (
          <>
            <Text style={styles.title}>Set New MPIN</Text>
            <Text style={styles.subtitle}>
              {mpin ? 'Confirm your new MPIN' : 'Create a new 6-digit MPIN'}
            </Text>

            <MPINInput
              onComplete={handleMPINComplete}
              error={!!error}
              disabled={isLoading}
              autoFocus={true}
            />

            {error && (
              <View style={styles.errorContainer}>
                <Text style={styles.errorText}>{error}</Text>
              </View>
            )}

            {isLoading && (
              <View style={styles.loadingContainer}>
                <Text style={styles.loadingText}>Setting up new MPIN...</Text>
              </View>
            )}

            <View style={styles.guidelines}>
              <Text style={styles.guidelinesTitle}>MPIN Guidelines:</Text>
              <Text style={styles.guideline}> Must be 6 digits</Text>
              <Text style={styles.guideline}> Avoid simple patterns</Text>
              <Text style={styles.guideline}> Don't use repeated digits</Text>
              <Text style={styles.guideline}> Choose something memorable</Text>
            </View>
          </>
        );
    }
  };

  const handleBack = () => {
    if (step === 1) {
      navigation.goBack();
    } else if (step === 2) {
      setStep(1);
      setOtp('');
      setError('');
    } else if (step === 3) {
      setStep(2);
      setMpin('');
      setConfirmMpin('');
      setError('');
    }
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.logoContainer}>
          <PrayantraLogo size={100} />
          <Text style={styles.appName}>Prayantra</Text>
        </View>

        <View style={styles.formContainer}>
          <View style={styles.stepIndicator}>
            <View style={[styles.step, step >= 1 && styles.activeStep]}>
              <Text style={[styles.stepText, step >= 1 && styles.activeStepText]}>1</Text>
            </View>
            <View style={styles.stepLine} />
            <View style={[styles.step, step >= 2 && styles.activeStep]}>
              <Text style={[styles.stepText, step >= 2 && styles.activeStepText]}>2</Text>
            </View>
            <View style={styles.stepLine} />
            <View style={[styles.step, step >= 3 && styles.activeStep]}>
              <Text style={[styles.stepText, step >= 3 && styles.activeStepText]}>3</Text>
            </View>
          </View>

          {renderStep()}

          <TouchableOpacity
            style={styles.backButton}
            onPress={handleBack}
            disabled={isLoading}
          >
            <Text style={styles.backButtonText}>
               {step === 1 ? 'Back to Login' : 'Back'}
            </Text>
          </TouchableOpacity>
        </View>

        <View style={styles.securityInfo}>
          <Text style={styles.securityTitle}>Security Information:</Text>
          <Text style={styles.securityText}>
             MPIN reset requires OTP verification
            {'\n'} OTP is valid for 10 minutes only
            {'\n'} Your old MPIN will be permanently deleted
            {'\n'} Contact admin if you face issues
          </Text>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 40,
    paddingBottom: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  appName: {
    fontSize: 24,
    fontWeight: '700',
    color: '#C084FC', // Purple
    marginTop: 12,
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  stepIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 32,
  },
  step: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#E2E8F0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  activeStep: {
    backgroundColor: '#C084FC', // Purple
  },
  stepText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#64748B',
  },
  activeStepText: {
    color: '#FFFFFF',
  },
  stepLine: {
    width: 30,
    height: 2,
    backgroundColor: '#E2E8F0',
    marginHorizontal: 4,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 24,
    textAlign: 'center',
    lineHeight: 20,
  },
  phoneContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 8,
    padding: 16,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#E2E8F0',
    alignItems: 'center',
  },
  phoneLabel: {
    fontSize: 12,
    color: '#64748B',
    marginBottom: 4,
  },
  phoneNumber: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1E293B',
  },
  instruction: {
    fontSize: 13,
    color: '#64748B',
    textAlign: 'center',
    marginBottom: 24,
    lineHeight: 18,
  },
  timerContainer: {
    backgroundColor: '#FEF3C7',
    padding: 12,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#FDE68A',
  },
  timerText: {
    color: '#D97706',
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
  },
  button: {
    backgroundColor: '#C084FC', // Purple
    borderRadius: 8,
    paddingVertical: 16,
    alignItems: 'center',
    marginTop: 24,
    marginBottom: 20,
  },
  buttonDisabled: {
    backgroundColor: '#D8B4FE', // Light purple
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  resendContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 8,
  },
  resendText: {
    fontSize: 14,
    color: '#64748B',
    marginRight: 4,
  },
  resendButton: {
    fontSize: 14,
    color: '#C084FC', // Purple
    fontWeight: '600',
  },
  resendButtonDisabled: {
    color: '#D8B4FE', // Light purple
  },
  errorContainer: {
    backgroundColor: '#FEF2F2',
    padding: 12,
    borderRadius: 8,
    marginTop: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#FECACA',
  },
  errorText: {
    color: '#DC2626',
    fontSize: 13,
    textAlign: 'center',
  },
  loadingContainer: {
    marginTop: 16,
    marginBottom: 16,
  },
  loadingText: {
    color: '#64748B',
    fontSize: 14,
    textAlign: 'center',
  },
  guidelines: {
    backgroundColor: '#FAF5FF', // Light purple
    padding: 16,
    borderRadius: 8,
    marginTop: 24,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  guidelinesTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#C084FC', // Purple
    marginBottom: 8,
  },
  guideline: {
    fontSize: 13,
    color: '#6B21A8',
    marginBottom: 4,
    lineHeight: 18,
  },
  backButton: {
    alignItems: 'center',
    paddingVertical: 12,
    marginTop: 16,
  },
  backButtonText: {
    color: '#C084FC', // Purple
    fontSize: 14,
    fontWeight: '500',
  },
  securityInfo: {
    marginTop: 32,
    backgroundColor: '#FAF5FF', // Light purple
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  securityTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#C084FC', // Purple
    marginBottom: 8,
  },
  securityText: {
    fontSize: 12,
    color: '#6B21A8',
    lineHeight: 18,
  },
});

export default ForgotMPINScreen;
========================================
FILE: src/screens/auth/LoginInitiateScreen.tsx
========================================

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
  Modal,
  FlatList,
  Keyboard,
  TouchableWithoutFeedback,
} from 'react-native';
import { useNavigation, NavigationProp } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';
import { api } from '@/services/api';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';
import PrayantraLogo from '@/components/PrayantraLogo';

// Define navigation types
type RootStackParamList = {
  LoginInitiate: undefined;
  SendOTP: { phoneNumber: string; adminId?: string };
  VerifyOTP: { phoneNumber: string; adminId?: string };
  SetupMPIN: { phoneNumber: string; adminId: string };
  VerifyMPIN: { phoneNumber?: string; adminId?: string };
  ForgotMPIN: { phoneNumber?: string };
  MainDrawer: undefined;
};

// Define country code type
type CountryCode = {
  code: string;
  country: string;
  flag: string;
};

// Country code data
const COUNTRY_CODES: CountryCode[] = [
  { code: '+91', country: 'India', flag: '' },
  { code: '+1', country: 'USA', flag: '' },
  { code: '+44', country: 'UK', flag: '' },
  { code: '+971', country: 'UAE', flag: '' },
  { code: '+65', country: 'Singapore', flag: '' },
  { code: '+60', country: 'Malaysia', flag: '' },
  { code: '+966', country: 'Saudi Arabia', flag: '' },
  { code: '+92', country: 'Pakistan', flag: '' },
  { code: '+880', country: 'Bangladesh', flag: '' },
  { code: '+94', country: 'Sri Lanka', flag: '' },
  { code: '+977', country: 'Nepal', flag: '' },
  { code: '+95', country: 'Myanmar', flag: '' },
  { code: '+84', country: 'Vietnam', flag: '' },
  { code: '+62', country: 'Indonesia', flag: '' },
  { code: '+63', country: 'Philippines', flag: '' },
  { code: '+66', country: 'Thailand', flag: '' },
  { code: '+81', country: 'Japan', flag: '' },
  { code: '+82', country: 'South Korea', flag: '' },
  { code: '+86', country: 'China', flag: '' },
  { code: '+33', country: 'France', flag: '' },
  { code: '+49', country: 'Germany', flag: '' },
  { code: '+39', country: 'Italy', flag: '' },
  { code: '+34', country: 'Spain', flag: '' },
  { code: '+61', country: 'Australia', flag: '' },
  { code: '+64', country: 'New Zealand', flag: '' },
  { code: '+27', country: 'South Africa', flag: '' },
  { code: '+55', country: 'Brazil', flag: '' },
  { code: '+52', country: 'Mexico', flag: '' },
  { code: '+7', country: 'Russia', flag: '' },
];

const LoginInitiateScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const { login } = useAuth();
  const { showToast } = useToast();
  const [isLoading, setIsLoading] = useState(false);
  const [phoneNumber, setPhoneNumber] = useState('');
  const [selectedCountry, setSelectedCountry] = useState<CountryCode>(COUNTRY_CODES[0]); // Default to India
  const [showCountryModal, setShowCountryModal] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [keyboardVisible, setKeyboardVisible] = useState(false);

  // Filter countries based on search query
  const filteredCountries = COUNTRY_CODES.filter(country => 
    country.country.toLowerCase().includes(searchQuery.toLowerCase()) ||
    country.code.toLowerCase().includes(searchQuery.toLowerCase())
  );

  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      'keyboardDidShow',
      () => {
        setKeyboardVisible(true);
      }
    );
    const keyboardDidHideListener = Keyboard.addListener(
      'keyboardDidHide',
      () => {
        setKeyboardVisible(false);
      }
    );

    return () => {
      keyboardDidShowListener.remove();
      keyboardDidHideListener.remove();
    };
  }, []);

  const dismissKeyboard = () => {
    Keyboard.dismiss();
  };

  const formatPhoneNumber = (input: string) => {
    // Remove all non-digit characters
    const cleaned = input.replace(/\D/g, '');
    
    // Format based on country code
    if (selectedCountry.code === '+1') {
      // US format: (XXX) XXX-XXXX
      const match = cleaned.match(/^(\d{0,3})(\d{0,3})(\d{0,4})$/);
      if (match) {
        const part1 = match[1];
        const part2 = match[2];
        const part3 = match[3];
        
        if (part2 && part3) {
          return `(${part1}) ${part2}-${part3}`;
        } else if (part2) {
          return `(${part1}) ${part2}`;
        } else if (part1) {
          return `(${part1}`;
        }
      }
    } else if (selectedCountry.code === '+44') {
      // UK format: XXXX XXX XXX
      const match = cleaned.match(/^(\d{0,4})(\d{0,3})(\d{0,3})$/);
      if (match) {
        const part1 = match[1];
        const part2 = match[2];
        const part3 = match[3];
        
        if (part2 && part3) {
          return `${part1} ${part2} ${part3}`;
        } else if (part2) {
          return `${part1} ${part2}`;
        } else if (part1) {
          return part1;
        }
      }
    } else {
      // Default format: XXX XXX XXXX for 10 digits
      const match = cleaned.match(/^(\d{0,3})(\d{0,3})(\d{0,4})$/);
      if (match) {
        const part1 = match[1];
        const part2 = match[2];
        const part3 = match[3];
        
        if (part2 && part3) {
          return `${part1} ${part2} ${part3}`;
        } else if (part2) {
          return `${part1} ${part2}`;
        } else if (part1) {
          return part1;
        }
      }
    }
    
    return cleaned;
  };

  const handlePhoneNumberChange = (text: string) => {
    const formatted = formatPhoneNumber(text);
    setPhoneNumber(formatted);
  };

  const getPhoneNumberForApi = () => {
    // Remove all non-digit characters and combine with country code
    const cleaned = phoneNumber.replace(/\D/g, '');
    return `${selectedCountry.code}${cleaned}`;
  };

  const handleLoginInitiate = async () => {
    const fullPhoneNumber = getPhoneNumberForApi();
    
    if (!phoneNumber.trim()) {
      showToast('error', 'Please enter your phone number');
      return;
    }

    // Validate phone number length based on country
    const cleaned = phoneNumber.replace(/\D/g, '');
    const minLength = selectedCountry.code === '+91' ? 10 : 7; // Adjust as needed
    
    if (cleaned.length < minLength) {
      showToast('error', `Please enter a valid ${selectedCountry.country} phone number`);
      return;
    }

    setIsLoading(true);
    try {
      const response = await api.loginInitiate(fullPhoneNumber);
      const { 
        user_exists, 
        has_mpin, 
        mpin_locked, 
        device_trusted,
        user_id 
      } = response.data.data;

      if (!user_exists) {
        showToast('error', 'Phone number not registered. Please contact your admin.');
        return;
      }

      if (mpin_locked) {
        Alert.alert(
          'MPIN Locked',
          'Your MPIN is locked. Please contact your administrator.',
          [{ text: 'OK' }]
        );
        return;
      }

      // Navigate based on flow state
      if (device_trusted && has_mpin) {
        // Direct to MPIN verification
        navigation.navigate('VerifyMPIN', { 
          phoneNumber: fullPhoneNumber,
          adminId: user_id 
        });
      } else if (!device_trusted) {
        // Send OTP for device verification
        navigation.navigate('SendOTP', { 
          phoneNumber: fullPhoneNumber,
          adminId: user_id 
        });
      } else if (!has_mpin) {
        // Setup MPIN
        navigation.navigate('SetupMPIN', { 
          phoneNumber: fullPhoneNumber,
          adminId: user_id 
        });
      }
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || 'Login failed. Please try again.';
      showToast('error', errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  const renderCountryItem = ({ item }: { item: CountryCode }) => (
    <TouchableOpacity
      style={[
        styles.countryItem,
        selectedCountry.code === item.code && styles.selectedCountryItem
      ]}
      onPress={() => {
        setSelectedCountry(item);
        setShowCountryModal(false);
        setSearchQuery(''); // Clear search when selecting
      }}
    >
      <Text style={styles.countryFlag}>{item.flag}</Text>
      <View style={styles.countryInfo}>
        <Text style={[
          styles.countryName,
          selectedCountry.code === item.code && styles.selectedCountryText
        ]}>
          {item.country}
        </Text>
        <Text style={[
          styles.countryCode,
          selectedCountry.code === item.code && styles.selectedCountryText
        ]}>
          {item.code}
        </Text>
      </View>
      {selectedCountry.code === item.code && (
        <Icon name="check" size={20} color="#C084FC" />
      )}
    </TouchableOpacity>
  );

  return (
    <TouchableWithoutFeedback onPress={dismissKeyboard}>
      <View style={styles.container}>
        <KeyboardAvoidingView 
          style={styles.keyboardAvoidingView}
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          keyboardVerticalOffset={Platform.OS === 'ios' ? 60 : 0}
        >
          <ScrollView 
            contentContainerStyle={[
              styles.scrollContent,
              keyboardVisible && styles.scrollContentWithKeyboard
            ]}
            keyboardShouldPersistTaps="handled"
            showsVerticalScrollIndicator={false}
          >
            <View style={styles.logoContainer}>
              <PrayantraLogo size={keyboardVisible ? 120 : 200} />
              <Text style={styles.appName}>Prayantra</Text>
              {!keyboardVisible && (
                <Text style={styles.tagline}>Empowering Enterprises</Text>
              )}
            </View>

            <View style={styles.formContainer}>
              <Text style={styles.title}>Admin Login</Text>
              <Text style={styles.subtitle}>Enter your phone number to continue</Text>

              <View style={styles.inputContainer}>
                <Text style={styles.label}>Phone Number</Text>
                <View style={styles.phoneInputContainer}>
                  <TouchableOpacity
                    style={styles.countryCodeButton}
                    onPress={() => {
                      dismissKeyboard();
                      setShowCountryModal(true);
                    }}
                  >
                    <Text style={styles.countryCodeText}>{selectedCountry.flag} {selectedCountry.code}</Text>
                    <Icon name="chevron-down" size={16} color="#64748B" />
                  </TouchableOpacity>
                  
                  <TextInput
                    style={styles.phoneInput}
                    placeholder={
                      selectedCountry.code === '+1' ? '(123) 456-7890' :
                      selectedCountry.code === '+44' ? '1234 567 890' :
                      '98765 43210'
                    }
                    value={phoneNumber}
                    onChangeText={handlePhoneNumberChange}
                    keyboardType="phone-pad"
                    autoCapitalize="none"
                    autoCorrect={false}
                    editable={!isLoading}
                    onFocus={() => setKeyboardVisible(true)}
                    onBlur={() => setKeyboardVisible(false)}
                  />
                </View>
                
                <Text style={styles.phonePreview}>
                  Number will be sent as: {getPhoneNumberForApi() || '...'}
                </Text>
              </View>

              <TouchableOpacity
                style={[styles.button, isLoading && styles.buttonDisabled]}
                onPress={handleLoginInitiate}
                disabled={isLoading}
                activeOpacity={0.8}
              >
                <Text style={styles.buttonText}>
                  {isLoading ? 'Checking...' : 'Continue'}
                </Text>
              </TouchableOpacity>
            </View>

            {!keyboardVisible && (
              <>
                <View style={styles.infoContainer}>
                  <Text style={styles.infoTitle}>Need help?</Text>
                  <Text style={styles.infoText}>
                     Make sure to enter your registered phone number
                    {'\n'} Include your country code if you're logging in from abroad
                    {'\n'} Contact your system administrator for assistance
                  </Text>
                </View>

                <View style={styles.footer}>
                  <Text style={styles.footerText}> 2024 Prayantra. All rights reserved.</Text>
                  <Text style={styles.versionText}>Version 1.0.0</Text>
                </View>
              </>
            )}
          </ScrollView>
        </KeyboardAvoidingView>

        {/* Country Code Selection Modal */}
        <Modal
          visible={showCountryModal}
          animationType="slide"
          transparent={true}
          statusBarTranslucent={true}
          onRequestClose={() => {
            setShowCountryModal(false);
            setSearchQuery(''); // Clear search when closing
          }}
        >
          <TouchableWithoutFeedback onPress={() => setShowCountryModal(false)}>
            <View style={styles.modalOverlay}>
              <TouchableWithoutFeedback>
                <View style={styles.modalContent}>
                  <View style={styles.modalHeader}>
                    <Text style={styles.modalTitle}>Select Country Code</Text>
                    <TouchableOpacity
                      onPress={() => {
                        setShowCountryModal(false);
                        setSearchQuery('');
                      }}
                      style={styles.closeButton}
                    >
                      <Icon name="close" size={24} color="#64748B" />
                    </TouchableOpacity>
                  </View>

                  <View style={styles.searchContainer}>
                    <Icon name="magnify" size={20} color="#64748B" style={styles.searchIcon} />
                    <TextInput
                      style={styles.searchInput}
                      placeholder="Search country..."
                      placeholderTextColor="#94A3B8"
                      value={searchQuery}
                      onChangeText={setSearchQuery}
                      autoCapitalize="none"
                      autoCorrect={false}
                    />
                  </View>

                  <FlatList
                    data={filteredCountries}
                    renderItem={renderCountryItem}
                    keyExtractor={(item: CountryCode) => item.code}
                    showsVerticalScrollIndicator={false}
                    style={styles.countryList}
                    keyboardShouldPersistTaps="handled"
                  />

                  <TouchableOpacity
                    style={styles.doneButton}
                    onPress={() => {
                      setShowCountryModal(false);
                      setSearchQuery('');
                    }}
                  >
                    <Text style={styles.doneButtonText}>Done</Text>
                  </TouchableOpacity>
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
      </View>
    </TouchableWithoutFeedback>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 40,
    paddingBottom: 40,
    justifyContent: 'center',
  },
  scrollContentWithKeyboard: {
    paddingTop: 20,
    justifyContent: 'flex-start',
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  appName: {
    fontSize: 32,
    fontWeight: '700',
    color: '#C084FC',
    marginTop: 16,
  },
  tagline: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
    letterSpacing: 1,
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
    marginBottom: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 24,
    textAlign: 'center',
  },
  inputContainer: {
    marginBottom: 20,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
    marginBottom: 8,
  },
  phoneInputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFFFFF',
    borderWidth: 1,
    borderColor: '#DDD',
    borderRadius: 8,
    overflow: 'hidden',
  },
  countryCodeButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 14,
    backgroundColor: '#F1F5F9',
    borderRightWidth: 1,
    borderRightColor: '#DDD',
    minWidth: 100,
  },
  countryCodeText: {
    fontSize: 16,
    color: '#333',
    marginRight: 8,
    fontWeight: '500',
  },
  phoneInput: {
    flex: 1,
    paddingHorizontal: 16,
    paddingVertical: 14,
    fontSize: 16,
    color: '#333',
  },
  phonePreview: {
    fontSize: 12,
    color: '#64748B',
    marginTop: 8,
    fontStyle: 'italic',
    textAlign: 'center',
  },
  button: {
    backgroundColor: '#C084FC',
    borderRadius: 8,
    paddingVertical: 16,
    alignItems: 'center',
    marginTop: 8,
  },
  buttonDisabled: {
    backgroundColor: '#D8B4FE',
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  infoContainer: {
    marginTop: 24,
    backgroundColor: '#FAF5FF',
    borderRadius: 12,
    padding: 16,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  infoTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#C084FC',
    marginBottom: 8,
  },
  infoText: {
    fontSize: 12,
    color: '#6B21A8',
    lineHeight: 18,
  },
  footer: {
    marginTop: 40,
    alignItems: 'center',
  },
  footerText: {
    fontSize: 12,
    color: '#666',
  },
  versionText: {
    fontSize: 11,
    color: '#999',
    marginTop: 4,
  },
  // Modal Styles
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#FFFFFF',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    maxHeight: '90%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1E293B',
  },
  closeButton: {
    padding: 4,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  searchIcon: {
    marginRight: 12,
  },
  searchInput: {
    flex: 1,
    fontSize: 16,
    color: '#1E293B',
    paddingVertical: 8,
  },
  countryList: {
    maxHeight: 400,
  },
  countryItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#F1F5F9',
  },
  selectedCountryItem: {
    backgroundColor: '#FAF5FF',
  },
  countryFlag: {
    fontSize: 24,
    marginRight: 12,
  },
  countryInfo: {
    flex: 1,
  },
  countryName: {
    fontSize: 16,
    color: '#1E293B',
    marginBottom: 2,
  },
  countryCode: {
    fontSize: 14,
    color: '#64748B',
  },
  selectedCountryText: {
    color: '#C084FC',
    fontWeight: '600',
  },
  doneButton: {
    backgroundColor: '#C084FC',
    margin: 20,
    paddingVertical: 16,
    borderRadius: 8,
    alignItems: 'center',
  },
  doneButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
});

export default LoginInitiateScreen;
========================================
FILE: src/screens/auth/SendOTPScreen.tsx
========================================

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { useNavigation, NavigationProp, RouteProp, useRoute } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { api } from '@/services/api';
import { useToast } from '@/components/Toast';
import PrayantraLogo from '@/components/PrayantraLogo';
import { STORAGE_KEYS } from '@/services/storage';

// Define navigation types
type RootStackParamList = {
  LoginInitiate: undefined;
  SendOTP: { phoneNumber: string; adminId?: string };
  VerifyOTP: { phoneNumber: string; adminId?: string };
  SetupMPIN: { phoneNumber: string; adminId: string };
  VerifyMPIN: { phoneNumber?: string; adminId?: string };
  ForgotMPIN: { phoneNumber?: string };
  MainDrawer: undefined;
};

type SendOTPScreenRouteProp = RouteProp<RootStackParamList, 'SendOTP'>;

const SendOTPScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const route = useRoute<SendOTPScreenRouteProp>();
  const { phoneNumber, adminId } = route.params;
  const { showToast } = useToast();

  const [timer, setTimer] = useState(60);
  const [canResend, setCanResend] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    startTimer();
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, []);

  const startTimer = () => {
    setCanResend(false);
    setTimer(60);
    
    if (timerRef.current) {
      clearInterval(timerRef.current);
    }

    timerRef.current = setInterval(() => {
      setTimer((prev) => {
        if (prev <= 1) {
          setCanResend(true);
          if (timerRef.current) {
            clearInterval(timerRef.current);
          }
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
  };

  const sendOTPMutation = useMutation({
    mutationFn: () => api.sendOTP(phoneNumber, 'admin_login'),
    onSuccess: (response) => {
      showToast('success', 'OTP sent successfully to your phone');
      startTimer(); // Reset timer after successful send
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.message || 'Failed to send OTP';
      
      if (error.response?.status === 429) {
        const retryAfter = error.response.data?.retry_after || 30;
        setTimer(retryAfter);
        setCanResend(false);
        showToast('error', `Too many requests. Please wait ${retryAfter} seconds`);
      } else if (error.response?.status === 500 && error.response.data?.error === 'phone number not registered') {
        Alert.alert(
          'Phone Not Registered',
          'This phone number is not registered. Please contact your administrator.',
          [{ text: 'OK', onPress: () => navigation.goBack() }]
        );
      } else {
        showToast('error', errorMessage);
      }
    },
    onSettled: () => {
      setIsLoading(false);
    },
  });

  const handleSendOTP = () => {
    if (!canResend && timer > 0) {
      showToast('info', `Please wait ${timer} seconds before resending`);
      return;
    }
    setIsLoading(true);
    sendOTPMutation.mutate();
  };

  const handleVerifyOTP = () => {
    navigation.navigate('VerifyOTP', { phoneNumber, adminId });
  };

  const handleGoBack = () => {
    navigation.goBack();
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.logoContainer}>
          <PrayantraLogo size={100} />
          <Text style={styles.appName}>Prayantra</Text>
        </View>

        <View style={styles.formContainer}>
          <Text style={styles.title}>Verify Device</Text>
          <Text style={styles.subtitle}>
            We've sent a 6-digit OTP to your registered phone number
          </Text>

          <View style={styles.phoneContainer}>
            <Text style={styles.phoneLabel}>Phone Number</Text>
            <Text style={styles.phoneNumber}>{phoneNumber}</Text>
          </View>

          <Text style={styles.instruction}>
            For security reasons, we need to verify this device. Enter the OTP sent to your phone.
          </Text>

          <TouchableOpacity
            style={[styles.verifyButton, isLoading && styles.buttonDisabled]}
            onPress={handleVerifyOTP}
            disabled={isLoading}
          >
            <Text style={styles.verifyButtonText}>Enter OTP</Text>
          </TouchableOpacity>

          <View style={styles.resendContainer}>
            <Text style={styles.resendText}>
              Didn't receive OTP? 
            </Text>
            <TouchableOpacity
              onPress={handleSendOTP}
              disabled={!canResend || isLoading}
            >
              <Text style={[
                styles.resendButton,
                (!canResend || isLoading) && styles.resendButtonDisabled
              ]}>
                {canResend ? 'Resend OTP' : `Resend in ${timer}s`}
              </Text>
            </TouchableOpacity>
          </View>

          {sendOTPMutation.isError && (
            <View style={styles.errorContainer}>
              <Text style={styles.errorText}>
                {sendOTPMutation.error?.response?.data?.error || 'Failed to send OTP'}
              </Text>
            </View>
          )}
        </View>

        <View style={styles.footer}>
          <TouchableOpacity onPress={handleGoBack}>
            <Text style={styles.backButton}> Back to Login</Text>
          </TouchableOpacity>
          
          <View style={styles.securityInfo}>
            <Text style={styles.securityTitle}>Security Notice:</Text>
            <Text style={styles.securityText}>
               OTP is valid for 10 minutes
              {'\n'} Never share OTP with anyone
              {'\n'} This OTP is for device verification only
            </Text>
          </View>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 40,
    paddingBottom: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  appName: {
    fontSize: 24,
    fontWeight: '700',
    color: '#C084FC', // Purple
    marginTop: 12,
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 24,
    textAlign: 'center',
    lineHeight: 20,
  },
  phoneContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 8,
    padding: 16,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#E2E8F0',
    alignItems: 'center',
  },
  phoneLabel: {
    fontSize: 12,
    color: '#64748B',
    marginBottom: 4,
  },
  phoneNumber: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1E293B',
  },
  instruction: {
    fontSize: 13,
    color: '#64748B',
    textAlign: 'center',
    marginBottom: 24,
    lineHeight: 18,
  },
  verifyButton: {
    backgroundColor: '#C084FC', // Purple
    borderRadius: 8,
    paddingVertical: 16,
    alignItems: 'center',
    marginBottom: 20,
  },
  buttonDisabled: {
    backgroundColor: '#D8B4FE', // Light purple
  },
  verifyButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  resendContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 8,
  },
  resendText: {
    fontSize: 14,
    color: '#64748B',
    marginRight: 4,
  },
  resendButton: {
    fontSize: 14,
    color: '#C084FC', // Purple
    fontWeight: '600',
  },
  resendButtonDisabled: {
    color: '#D8B4FE', // Light purple
  },
  errorContainer: {
    backgroundColor: '#FEF2F2',
    padding: 12,
    borderRadius: 8,
    marginTop: 16,
    borderWidth: 1,
    borderColor: '#FECACA',
  },
  errorText: {
    color: '#DC2626',
    fontSize: 13,
    textAlign: 'center',
  },
  footer: {
    marginTop: 32,
  },
  backButton: {
    color: '#C084FC', // Purple
    fontSize: 14,
    fontWeight: '500',
    textAlign: 'center',
    marginBottom: 24,
  },
  securityInfo: {
    backgroundColor: '#FAF5FF', // Light purple
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  securityTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#C084FC', // Purple
    marginBottom: 8,
  },
  securityText: {
    fontSize: 12,
    color: '#6B21A8',
    lineHeight: 18,
  },
});

export default SendOTPScreen;
========================================
FILE: src/screens/auth/SetupMPINScreen.tsx
========================================

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { useNavigation, NavigationProp, RouteProp, useRoute } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { api } from '@/services/api';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';
import PrayantraLogo from '@/components/PrayantraLogo';
import MPINInput from '@/components/MPINInput';

// Define navigation types
type RootStackParamList = {
  LoginInitiate: undefined;
  SendOTP: { phoneNumber: string; adminId?: string };
  VerifyOTP: { phoneNumber: string; adminId?: string };
  SetupMPIN: { phoneNumber: string; adminId: string };
  VerifyMPIN: { phoneNumber?: string; adminId?: string };
  ForgotMPIN: { phoneNumber?: string };
  MainDrawer: undefined;
};

type SetupMPINScreenRouteProp = RouteProp<RootStackParamList, 'SetupMPIN'>;

const SetupMPINScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const route = useRoute<SetupMPINScreenRouteProp>();
  const { phoneNumber, adminId } = route.params;
  
  const { login } = useAuth();
  const { showToast } = useToast();

  const [mpin, setMpin] = useState('');
  const [confirmMpin, setConfirmMpin] = useState('');
  const [step, setStep] = useState(1); // 1: Enter MPIN, 2: Confirm MPIN
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const setupMPINMutation = useMutation({
    mutationFn: (mpin: string) => api.setupMPIN(adminId, mpin),
    onSuccess: (response: any) => {
      // After MPIN setup, verify it to get tokens
      api.verifyMPIN(phoneNumber, mpin)
        .then(verifyResponse => {
          const { admin, tokens, message } = verifyResponse.data.data;
          login(phoneNumber, tokens, admin);
          showToast('success', message || 'MPIN setup successful');
        })
        .catch(error => {
          showToast('error', 'MPIN setup successful. Please login with your MPIN.');
          navigation.navigate('VerifyMPIN', { phoneNumber });
        });
    },
    onError: (error: any) => {
      const errorType = error.response?.data?.error;
      const errorMessage = error.response?.data?.message || 'Failed to setup MPIN';

      if (errorType === 'admin MPIN already exists') {
        Alert.alert(
          'MPIN Already Exists',
          'MPIN is already setup for this account. Please login with your MPIN.',
          [{ text: 'OK', onPress: () => navigation.navigate('VerifyMPIN', { phoneNumber }) }]
        );
      } else if (errorType === 'admin MPIN is too weak') {
        setError('MPIN is too weak. Please use a stronger MPIN.');
        setStep(1);
        setMpin('');
        setConfirmMpin('');
      } else {
        showToast('error', errorMessage);
        setStep(1);
        setMpin('');
        setConfirmMpin('');
      }
    },
    onSettled: () => {
      setIsLoading(false);
    },
  });

  const handleMPINComplete = (enteredMpin: string) => {
    if (step === 1) {
      // Validate MPIN strength
      if (enteredMpin === '111111' || enteredMpin === '123456' || enteredMpin === '000000') {
        setError('MPIN is too common. Please choose a stronger MPIN.');
        return;
      }

      if (enteredMpin.split('').every((digit, i, arr) => digit === arr[0])) {
        setError('MPIN cannot have all same digits');
        return;
      }

      setMpin(enteredMpin);
      setError('');
      setStep(2);
    } else {
      setConfirmMpin(enteredMpin);
      
      if (enteredMpin === mpin) {
        setIsLoading(true);
        setupMPINMutation.mutate(enteredMpin);
      } else {
        setError('MPIN does not match. Please try again.');
        setConfirmMpin('');
        // Optional: Auto go back to step 1
        setTimeout(() => {
          setStep(1);
          setMpin('');
          setConfirmMpin('');
          setError('');
        }, 1000);
      }
    }
  };

  const handleBack = () => {
    if (step === 2) {
      setStep(1);
      setConfirmMpin('');
      setError('');
    } else {
      navigation.goBack();
    }
  };

  const isWeakMpin = (mpin: string) => {
    const weakPatterns = [
      '111111', '222222', '333333', '444444', '555555',
      '666666', '777777', '888888', '999999', '000000',
      '123456', '654321', '121212', '123123', '112233'
    ];
    return weakPatterns.includes(mpin) || 
           mpin.split('').every((digit, i, arr) => digit === arr[0]);
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.logoContainer}>
          <PrayantraLogo size={100} />
          <Text style={styles.appName}>Prayantra</Text>
        </View>

        <View style={styles.formContainer}>
          <Text style={styles.title}>
            {step === 1 ? 'Setup MPIN' : 'Confirm MPIN'}
          </Text>
          
          <Text style={styles.subtitle}>
            {step === 1 
              ? 'Create a 6-digit MPIN for secure login' 
              : 'Re-enter your MPIN to confirm'}
          </Text>

          <View style={styles.stepIndicator}>
            <View style={[styles.step, step === 1 && styles.activeStep]}>
              <Text style={[styles.stepText, step === 1 && styles.activeStepText]}>1</Text>
            </View>
            <View style={styles.stepLine} />
            <View style={[styles.step, step === 2 && styles.activeStep]}>
              <Text style={[styles.stepText, step === 2 && styles.activeStepText]}>2</Text>
            </View>
          </View>

          <View style={styles.mpinContainer}>
            <MPINInput
              onComplete={handleMPINComplete}
              error={!!error}
              disabled={isLoading}
              autoFocus={true}
            />
          </View>

          {error ? (
            <View style={styles.errorContainer}>
              <Text style={styles.errorText}>{error}</Text>
            </View>
          ) : (
            <View style={styles.guidelinesContainer}>
              <Text style={styles.guidelinesTitle}>
                {step === 1 ? 'MPIN Guidelines:' : 'Almost there!'}
              </Text>
              {step === 1 ? (
                <>
                  <Text style={styles.guideline}> Must be 6 digits</Text>
                  <Text style={styles.guideline}> Avoid simple patterns (111111, 123456)</Text>
                  <Text style={styles.guideline}> Don't use repeated digits</Text>
                  <Text style={styles.guideline}> Choose something memorable but secure</Text>
                </>
              ) : (
                <>
                  <Text style={styles.guideline}> Re-enter the same 6-digit MPIN</Text>
                  <Text style={styles.guideline}> Make sure it matches exactly</Text>
                  <Text style={styles.guideline}> This will be your login password</Text>
                </>
              )}
            </View>
          )}

          {isLoading && (
            <View style={styles.loadingContainer}>
              <Text style={styles.loadingText}>
                {step === 2 ? 'Setting up MPIN...' : 'Processing...'}
              </Text>
            </View>
          )}

          <TouchableOpacity
            style={styles.backButton}
            onPress={handleBack}
            disabled={isLoading}
          >
            <Text style={styles.backButtonText}>
               {step === 2 ? 'Back to enter MPIN' : 'Back'}
            </Text>
          </TouchableOpacity>
        </View>

        <View style={styles.securityInfo}>
          <Text style={styles.securityTitle}>Security First:</Text>
          <Text style={styles.securityText}>
             Your MPIN is encrypted and stored securely
            {'\n'} Never share your MPIN with anyone
            {'\n'} You can change MPIN anytime from settings
            {'\n'} Contact admin if you forget your MPIN
          </Text>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 40,
    paddingBottom: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  appName: {
    fontSize: 24,
    fontWeight: '700',
    color: '#C084FC', // Purple
    marginTop: 12,
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 24,
    textAlign: 'center',
  },
  stepIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 32,
  },
  step: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#E2E8F0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  activeStep: {
    backgroundColor: '#C084FC', // Purple
  },
  stepText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#64748B',
  },
  activeStepText: {
    color: '#FFFFFF',
  },
  stepLine: {
    width: 40,
    height: 2,
    backgroundColor: '#E2E8F0',
    marginHorizontal: 8,
  },
  mpinContainer: {
    marginBottom: 24,
  },
  errorContainer: {
    backgroundColor: '#FEF2F2',
    padding: 16,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#FECACA',
  },
  errorText: {
    color: '#DC2626',
    fontSize: 14,
    textAlign: 'center',
  },
  guidelinesContainer: {
    backgroundColor: '#FAF5FF', // Light purple
    padding: 16,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  guidelinesTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#C084FC', // Purple
    marginBottom: 8,
  },
  guideline: {
    fontSize: 13,
    color: '#6B21A8',
    marginBottom: 4,
    lineHeight: 18,
  },
  loadingContainer: {
    marginBottom: 24,
  },
  loadingText: {
    color: '#64748B',
    fontSize: 14,
    textAlign: 'center',
  },
  backButton: {
    alignItems: 'center',
    paddingVertical: 12,
  },
  backButtonText: {
    color: '#C084FC', // Purple
    fontSize: 14,
    fontWeight: '500',
  },
  securityInfo: {
    marginTop: 32,
    backgroundColor: '#FAF5FF', // Light purple
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  securityTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#C084FC', // Purple
    marginBottom: 8,
  },
  securityText: {
    fontSize: 12,
    color: '#6B21A8',
    lineHeight: 18,
  },
});

export default SetupMPINScreen;
========================================
FILE: src/screens/auth/VerifyMPINScreen.tsx
========================================

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { useNavigation, NavigationProp, useRoute, RouteProp } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { api } from '@/services/api';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';
import PrayantraLogo from '@/components/PrayantraLogo';
import MPINInput from '@/components/MPINInput';
import { getFormattedPhoneNumber } from '@/services/storage';

// Define navigation types
type RootStackParamList = {
  LoginInitiate: undefined;
  SendOTP: { phoneNumber: string; adminId?: string };
  VerifyOTP: { phoneNumber: string; adminId?: string };
  SetupMPIN: { phoneNumber: string; adminId: string };
  VerifyMPIN: { phoneNumber?: string; adminId?: string };
  ForgotMPIN: { phoneNumber?: string };
  MainDrawer: undefined;
};

type VerifyMPINScreenRouteProp = RouteProp<RootStackParamList, 'VerifyMPIN'>;

const VerifyMPINScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const route = useRoute<VerifyMPINScreenRouteProp>();
  const params = route.params;
  
  const { login } = useAuth();
  const { showToast } = useToast();
  
  const [mpin, setMpin] = useState('');
  const [error, setError] = useState(false);
  const [attemptCount, setAttemptCount] = useState(0);
  const [isLocked, setIsLocked] = useState(false);
  const [lockTime, setLockTime] = useState(0);
  const [phoneNumber, setPhoneNumber] = useState('');

  useEffect(() => {
    const loadPhoneNumber = async () => {
      if (params?.phoneNumber) {
        setPhoneNumber(params.phoneNumber);
      } else {
        const storedPhone = await getFormattedPhoneNumber();
        if (storedPhone) {
          setPhoneNumber(storedPhone);
        }
      }
    };
    loadPhoneNumber();
  }, [params?.phoneNumber]);

  useEffect(() => {
    if (isLocked && lockTime > 0) {
      const timer = setInterval(() => {
        setLockTime(prev => {
          if (prev <= 1) {
            setIsLocked(false);
            clearInterval(timer);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [isLocked, lockTime]);

  const mutation = useMutation({
    mutationFn: (mpin: string) => api.verifyMPIN(phoneNumber, mpin),
    onSuccess: (response: any) => {
      const { admin, tokens, message } = response.data.data;
      
      // Login success
      login(phoneNumber, tokens, admin);
      
      showToast('success', message || 'Login successful');
    },
    onError: (error: any) => {
      const errorType = error.response?.data?.error;
      const errorMessage = error.response?.data?.message || 'MPIN verification failed';
      
      if (errorType === 'MPIN rate limit exceeded') {
        setIsLocked(true);
        setLockTime(60);
        Alert.alert(
          'MPIN Locked',
          'Too many failed attempts. Please try again after 60 seconds.',
          [{ text: 'OK' }]
        );
        return;
      }
      
      setError(true);
      const newAttemptCount = attemptCount + 1;
      setAttemptCount(newAttemptCount);
      
      if (newAttemptCount >= 3) {
        Alert.alert(
          'Warning',
          `You have ${5 - newAttemptCount} attempts left before temporary lock.`,
          [{ text: 'OK' }]
        );
      }
      
      showToast('error', errorMessage);
      
      // Clear MPIN after error
      setMpin('');
    },
  });

  const handleMPINComplete = (enteredMpin: string) => {
    if (isLocked) {
      showToast('error', `Please wait ${lockTime} seconds before trying again`);
      return;
    }
    
    setMpin(enteredMpin);
    setError(false);
    mutation.mutate(enteredMpin);
  };

  const handleForgotMPIN = () => {
    navigation.navigate('ForgotMPIN', { phoneNumber });
  };

  const handleUseDifferentAccount = () => {
    navigation.navigate('LoginInitiate');
  };

  const isPending = mutation.isPending;

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.logoContainer}>
          <PrayantraLogo size={100} />
          <Text style={styles.appName}>Prayantra</Text>
        </View>

        <View style={styles.formContainer}>
          <Text style={styles.title}>Enter MPIN</Text>
          <Text style={styles.subtitle}>
            {phoneNumber ? `Logged in as ${phoneNumber}` : 'Enter your 6-digit MPIN'}
          </Text>

          <MPINInput
            onComplete={handleMPINComplete}
            error={error}
            disabled={isPending || isLocked}
          />

          {isLocked && (
            <View style={styles.lockContainer}>
              <Text style={styles.lockText}>
                MPIN locked. Try again in {lockTime} seconds
              </Text>
            </View>
          )}

          {isPending && (
            <View style={styles.loadingContainer}>
              <Text style={styles.loadingText}>Verifying MPIN...</Text>
            </View>
          )}

          <TouchableOpacity
            style={styles.forgotButton}
            onPress={handleForgotMPIN}
            disabled={isPending}
          >
            <Text style={styles.forgotText}>Forgot MPIN?</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.differentAccountButton}
            onPress={handleUseDifferentAccount}
            disabled={isPending}
          >
            <Text style={styles.differentAccountText}>Use different account</Text>
          </TouchableOpacity>
        </View>

        <View style={styles.securityInfo}>
          <Text style={styles.securityTitle}>Security Tips:</Text>
          <Text style={styles.securityTip}> Never share your MPIN with anyone</Text>
          <Text style={styles.securityTip}> Change your MPIN regularly</Text>
          <Text style={styles.securityTip}> Use a unique MPIN not used elsewhere</Text>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 40,
    paddingBottom: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  appName: {
    fontSize: 24,
    fontWeight: '700',
    color: '#C084FC', // Purple
    marginTop: 12,
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 32,
    textAlign: 'center',
  },
  lockContainer: {
    backgroundColor: '#FEF2F2',
    padding: 12,
    borderRadius: 8,
    marginTop: 16,
    borderWidth: 1,
    borderColor: '#FECACA',
  },
  lockText: {
    color: '#DC2626',
    fontSize: 14,
    textAlign: 'center',
    fontWeight: '500',
  },
  loadingContainer: {
    marginTop: 16,
  },
  loadingText: {
    color: '#64748B',
    fontSize: 14,
    textAlign: 'center',
  },
  forgotButton: {
    marginTop: 24,
    alignItems: 'center',
  },
  forgotText: {
    color: '#C084FC', // Purple
    fontSize: 14,
    fontWeight: '500',
  },
  differentAccountButton: {
    marginTop: 16,
    alignItems: 'center',
  },
  differentAccountText: {
    color: '#64748B',
    fontSize: 14,
  },
  securityInfo: {
    marginTop: 32,
    backgroundColor: '#FAF5FF', // Light purple
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  securityTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#C084FC', // Purple
    marginBottom: 8,
  },
  securityTip: {
    fontSize: 12,
    color: '#6B21A8',
    marginBottom: 4,
  },
});

export default VerifyMPINScreen;
========================================
FILE: src/screens/auth/VerifyOTPScreen.tsx
========================================

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { useNavigation, NavigationProp, RouteProp, useRoute } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { api } from '@/services/api';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';
import PrayantraLogo from '@/components/PrayantraLogo';
import OTPInput from '@/components/OTPInput';

// Define navigation types
type RootStackParamList = {
  LoginInitiate: undefined;
  SendOTP: { phoneNumber: string; adminId?: string };
  VerifyOTP: { phoneNumber: string; adminId?: string };
  SetupMPIN: { phoneNumber: string; adminId: string };
  VerifyMPIN: { phoneNumber?: string; adminId?: string };
  ForgotMPIN: { phoneNumber?: string };
  MainDrawer: undefined;
};

type VerifyOTPScreenRouteProp = RouteProp<RootStackParamList, 'VerifyOTP'>;

const VerifyOTPScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const route = useRoute<VerifyOTPScreenRouteProp>();
  const { phoneNumber, adminId } = route.params;
  
  const { login } = useAuth();
  const { showToast } = useToast();

  const [otp, setOtp] = useState('');
  const [timer, setTimer] = useState(600); // 10 minutes in seconds
  const [error, setError] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    startTimer();
    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
      }
    };
  }, []);

  useEffect(() => {
    if (otp.length === 6) {
      handleVerifyOTP();
    }
  }, [otp]);

  const startTimer = () => {
    if (timerRef.current) {
      clearInterval(timerRef.current);
    }

    timerRef.current = setInterval(() => {
      setTimer((prev) => {
        if (prev <= 1) {
          if (timerRef.current) {
            clearInterval(timerRef.current);
          }
          Alert.alert(
            'OTP Expired',
            'The OTP has expired. Please request a new one.',
            [{ text: 'OK', onPress: () => navigation.navigate('SendOTP', { phoneNumber, adminId }) }]
          );
          return 0;
        }
        return prev - 1;
      });
    }, 1000);
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  const verifyOTPMutation = useMutation({
    mutationFn: (otpCode: string) => api.verifyOTP(phoneNumber, otpCode),
    onSuccess: (response: any) => {
      const { has_mpin, device_trusted, admin_id, message } = response.data.data;
      
      if (has_mpin) {
        // Navigate to MPIN verification
        showToast('success', message || 'Device verified successfully');
        navigation.navigate('VerifyMPIN', { 
          phoneNumber,
          adminId: admin_id || adminId 
        });
      } else {
        // Navigate to MPIN setup
        showToast('success', 'Device verified. Please setup your MPIN');
        navigation.navigate('SetupMPIN', { 
          phoneNumber,
          adminId: admin_id || adminId 
        });
      }
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.message || 'OTP verification failed';
      setError(true);
      setOtp('');
      showToast('error', errorMessage);
    },
    onSettled: () => {
      setIsLoading(false);
    },
  });

  const resendOTPMutation = useMutation({
    mutationFn: () => api.sendOTP(phoneNumber, 'admin_login'),
    onSuccess: () => {
      showToast('success', 'OTP resent successfully');
      setTimer(600); // Reset to 10 minutes
      startTimer();
    },
    onError: (error: any) => {
      const errorMessage = error.response?.data?.message || 'Failed to resend OTP';
      showToast('error', errorMessage);
    },
  });

  const handleVerifyOTP = () => {
    if (otp.length !== 6) {
      showToast('error', 'Please enter 6-digit OTP');
      return;
    }

    setIsLoading(true);
    setError(false);
    verifyOTPMutation.mutate(otp);
  };

  const handleResendOTP = () => {
    if (timer > 540) { // Can't resend before 1 minute
      showToast('info', 'Please wait before requesting a new OTP');
      return;
    }
    resendOTPMutation.mutate();
  };

  const handleGoBack = () => {
    navigation.navigate('SendOTP', { phoneNumber, adminId });
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.logoContainer}>
          <PrayantraLogo size={100} />
          <Text style={styles.appName}>Prayantra</Text>
        </View>

        <View style={styles.formContainer}>
          <Text style={styles.title}>Enter OTP</Text>
          <Text style={styles.subtitle}>
            Enter the 6-digit OTP sent to your phone
          </Text>

          <View style={styles.phoneContainer}>
            <Text style={styles.phoneLabel}>Phone Number</Text>
            <Text style={styles.phoneNumber}>{phoneNumber}</Text>
          </View>

          <View style={styles.timerContainer}>
            <Text style={styles.timerText}>Time remaining: {formatTime(timer)}</Text>
          </View>

          <OTPInput
            length={6}
            onComplete={setOtp}
            error={error}
            disabled={isLoading}
            autoFocus={true}
          />

          {error && (
            <Text style={styles.errorText}>
              Invalid OTP. Please try again.
            </Text>
          )}

          {isLoading && (
            <View style={styles.loadingContainer}>
              <Text style={styles.loadingText}>Verifying OTP...</Text>
            </View>
          )}

          <TouchableOpacity
            style={[styles.verifyButton, isLoading && styles.buttonDisabled]}
            onPress={handleVerifyOTP}
            disabled={isLoading || otp.length !== 6}
          >
            <Text style={styles.verifyButtonText}>
              {isLoading ? 'Verifying...' : 'Verify OTP'}
            </Text>
          </TouchableOpacity>

          <View style={styles.resendContainer}>
            <Text style={styles.resendText}>
              Didn't receive OTP? 
            </Text>
            <TouchableOpacity
              onPress={handleResendOTP}
              disabled={resendOTPMutation.isPending || timer > 540}
            >
              <Text style={[
                styles.resendButton,
                (resendOTPMutation.isPending || timer > 540) && styles.resendButtonDisabled
              ]}>
                {resendOTPMutation.isPending ? 'Sending...' : 'Resend OTP'}
              </Text>
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.footer}>
          <TouchableOpacity onPress={handleGoBack}>
            <Text style={styles.backButton}> Change phone number</Text>
          </TouchableOpacity>
          
          <View style={styles.securityInfo}>
            <Text style={styles.securityTitle}>Important:</Text>
            <Text style={styles.securityText}>
               OTP expires in 10 minutes
              {'\n'} Enter OTP within {formatTime(timer)}
              {'\n'} This verifies your device for secure access
            </Text>
          </View>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 40,
    paddingBottom: 20,
  },
  logoContainer: {
    alignItems: 'center',
    marginBottom: 30,
  },
  appName: {
    fontSize: 24,
    fontWeight: '700',
    color: '#C084FC', // Purple
    marginTop: 12,
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 24,
    textAlign: 'center',
  },
  phoneContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 8,
    padding: 12,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#E2E8F0',
    alignItems: 'center',
  },
  phoneLabel: {
    fontSize: 12,
    color: '#64748B',
    marginBottom: 4,
  },
  phoneNumber: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
  },
  timerContainer: {
    backgroundColor: '#FEF3C7',
    padding: 12,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#FDE68A',
  },
  timerText: {
    color: '#D97706',
    fontSize: 14,
    fontWeight: '600',
    textAlign: 'center',
  },
  errorText: {
    color: '#DC2626',
    fontSize: 14,
    textAlign: 'center',
    marginTop: 12,
    marginBottom: 16,
  },
  loadingContainer: {
    marginTop: 16,
    marginBottom: 16,
  },
  loadingText: {
    color: '#64748B',
    fontSize: 14,
    textAlign: 'center',
  },
  verifyButton: {
    backgroundColor: '#C084FC', // Purple
    borderRadius: 8,
    paddingVertical: 16,
    alignItems: 'center',
    marginTop: 8,
    marginBottom: 20,
  },
  buttonDisabled: {
    backgroundColor: '#D8B4FE', // Light purple
  },
  verifyButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '600',
  },
  resendContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 8,
  },
  resendText: {
    fontSize: 14,
    color: '#64748B',
    marginRight: 4,
  },
  resendButton: {
    fontSize: 14,
    color: '#C084FC', // Purple
    fontWeight: '600',
  },
  resendButtonDisabled: {
    color: '#D8B4FE', // Light purple
  },
  footer: {
    marginTop: 32,
  },
  backButton: {
    color: '#C084FC', // Purple
    fontSize: 14,
    fontWeight: '500',
    textAlign: 'center',
    marginBottom: 24,
  },
  securityInfo: {
    backgroundColor: '#FAF5FF', // Light purple
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  securityTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#C084FC', // Purple
    marginBottom: 8,
  },
  securityText: {
    fontSize: 12,
    color: '#6B21A8',
    lineHeight: 18,
  },
});

export default VerifyOTPScreen;
========================================
FILE: src/screens/dashboard/DepartmentScreen.tsx
========================================

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  RefreshControl,
  Dimensions,
  Alert,
  FlatList,
} from 'react-native';
import { useNavigation, RouteProp, useRoute } from '@react-navigation/native';
import { useQuery } from '@tanstack/react-query';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';

const { width } = Dimensions.get('window');

// Define route params type
type DepartmentScreenRouteProp = RouteProp<any, 'DepartmentScreen'>;

// Define permission categories based on department
const permissionCategories: Record<string, { title: string; permissions: string[] }[]> = {
  'HR': [
    {
      title: 'Employee Management',
      permissions: [
        'Create Employee',
        'Update Employee',
        'Delete Employee',
        'View Employee',
        'Search Employee',
        'Terminate Employee',
        'Transfer Employee',
      ]
    },
    {
      title: 'Document Management',
      permissions: [
        'Upload Document',
        'View Document',
        'Delete Document',
      ]
    },
    {
      title: 'Position Management',
      permissions: [
        'Create Position',
        'Update Position',
        'Delete Position',
        'View Position',
      ]
    },
    {
      title: 'Leave Management',
      permissions: [
        'Request Leave',
        'Approve Leave',
        'Reject Leave',
        'View Leave',
      ]
    },
    {
      title: 'Attendance',
      permissions: [
        'View Attendance',
        'Update Attendance',
      ]
    }
  ],
  'Finance': [
    {
      title: 'Invoice Management',
      permissions: [
        'Create Invoice',
        'Update Invoice',
        'Delete Invoice',
        'View Invoice',
        'Send Invoice',
        'Approve Invoice',
      ]
    },
    {
      title: 'Payment Processing',
      permissions: [
        'Process Payment',
        'Refund Payment',
        'View Payment',
      ]
    },
    {
      title: 'Financial Statements',
      permissions: [
        'View Statement',
        'Download Statement',
      ]
    },
    {
      title: 'Tax Management',
      permissions: [
        'Create Tax',
        'Update Tax',
        'View Tax',
        'Delete Tax',
      ]
    },
    {
      title: 'Budget Management',
      permissions: [
        'Create Budget',
        'Update Budget',
        'Delete Budget',
        'View Budget',
      ]
    }
  ],
  'IT': [
    {
      title: 'Asset Management',
      permissions: [
        'Create Asset',
        'Update Asset',
        'Delete Asset',
        'View Asset',
      ]
    },
    {
      title: 'Incident Management',
      permissions: [
        'Create Incident',
        'Update Incident',
        'Resolve Incident',
        'Close Incident',
        'View Incident',
      ]
    },
    {
      title: 'Access Management',
      permissions: [
        'Request Access',
        'Grant Access',
        'Revoke Access',
      ]
    },
    {
      title: 'System Configuration',
      permissions: [
        'Update Config',
        'View Config',
      ]
    }
  ],
  'Sales': [
    {
      title: 'Lead Management',
      permissions: [
        'Create Lead',
        'Update Lead',
        'Delete Lead',
        'View Lead',
      ]
    },
    {
      title: 'Deal Management',
      permissions: [
        'Create Deal',
        'Update Deal',
        'Delete Deal',
        'View Deal',
        'Close Deal',
      ]
    },
    {
      title: 'Quotation',
      permissions: [
        'Create Quote',
        'Update Quote',
        'Delete Quote',
        'View Quote',
      ]
    },
    {
      title: 'Sales Targets',
      permissions: [
        'Create Target',
        'Update Target',
        'View Target',
      ]
    }
  ],
  'Inventory': [
    {
      title: 'Item Management',
      permissions: [
        'Create Item',
        'Update Item',
        'Delete Item',
        'View Item',
      ]
    },
    {
      title: 'Stock Operations',
      permissions: [
        'Stock In',
        'Stock Out',
        'Stock Transfer',
        'Stock Adjust',
        'Stock Audit',
        'View Stock',
      ]
    },
    {
      title: 'Batch Management',
      permissions: [
        'Create Batch',
        'Update Batch',
        'View Batch',
        'Delete Batch',
      ]
    },
    {
      title: 'Warehouse Management',
      permissions: [
        'Create Warehouse',
        'Update Warehouse',
        'Delete Warehouse',
        'View Warehouse',
      ]
    }
  ],
  'default': [
    {
      title: 'Department Operations',
      permissions: [
        'View Dashboard',
        'Generate Reports',
        'Manage Settings',
        'View Analytics',
        'Create Entries',
        'Update Entries',
        'Delete Entries',
      ]
    }
  ]
};

const DepartmentScreen = () => {
  const navigation = useNavigation();
  const route = useRoute<DepartmentScreenRouteProp>();
  const { department } = route.params || {};
  
  const { adminInfo } = useAuth();
  const { showToast } = useToast();

  const [refreshing, setRefreshing] = useState(false);
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);

  const departmentPermissions = permissionCategories[department] || permissionCategories['default'];
  const userPermissions = adminInfo?.permissions || [];

  useEffect(() => {
    if (departmentPermissions.length > 0) {
      setSelectedCategory(departmentPermissions[0].title);
    }
  }, [department]);

  const handleRefresh = async () => {
    setRefreshing(true);
    // Simulate API call
    setTimeout(() => {
      setRefreshing(false);
      showToast('success', 'Department data refreshed');
    }, 1000);
  };

  const hasPermission = (permission: string): boolean => {
    const permissionKey = permission.toLowerCase().replace(/\s+/g, '.');
    return userPermissions.some(p => p.includes(permissionKey));
  };

  const getDepartmentIcon = (dept: string) => {
    const icons: Record<string, string> = {
      'HR': 'account-group',
      'Finance': 'cash',
      'Accounting': 'calculator',
      'Procurement': 'cart',
      'Inventory': 'warehouse',
      'Logistics': 'truck',
      'Sales': 'chart-line',
      'Marketing': 'bullhorn',
      'Customer Support': 'headset',
      'Operations': 'cog',
      'IT': 'desktop-classic',
      'Production': 'factory',
      'Quality Control': 'check-circle',
      'Quality Assurance': 'shield-check',
      'R&D': 'flask',
      'Administration': 'office-building',
      'Employee Management': 'account-multiple',
      'Manager Management': 'account-tie',
      'Company Management': 'domain',
      'Super Admin Management': 'security',
    };
    return icons[dept] || 'folder';
  };

  const getDepartmentColor = (dept: string) => {
    const colors: Record<string, string> = {
      'HR': '#C084FC',
      'Finance': '#A855F7',
      'Accounting': '#9333EA',
      'Procurement': '#7C3AED',
      'Inventory': '#6D28D9',
      'Logistics': '#5B21B6',
      'Sales': '#4C1D95',
      'Marketing': '#3B0764',
      'Customer Support': '#7E22CE',
      'Operations': '#6B21A8',
      'IT': '#C084FC',
      'Production': '#A855F7',
      'Quality Control': '#9333EA',
      'Quality Assurance': '#7C3AED',
      'R&D': '#6D28D9',
      'Administration': '#5B21B6',
      'Employee Management': '#C084FC',
      'Manager Management': '#A855F7',
      'Company Management': '#9333EA',
      'Super Admin Management': '#7C3AED',
    };
    return colors[dept] || '#C084FC'; // Default purple
  };

  const renderPermissionItem = ({ item }: { item: string }) => (
    <View style={styles.permissionItem}>
      <View style={styles.permissionIconContainer}>
        {hasPermission(item) ? (
          <Icon name="check-circle" size={20} color="#10B981" />
        ) : (
          <Icon name="close-circle" size={20} color="#EF4444" />
        )}
      </View>
      <Text style={[
        styles.permissionText,
        !hasPermission(item) && styles.permissionDisabled
      ]}>
        {item}
      </Text>
      {hasPermission(item) ? (
        <View style={styles.permissionBadge}>
          <Text style={styles.permissionBadgeText}>Granted</Text>
        </View>
      ) : (
        <View style={[styles.permissionBadge, styles.permissionBadgeDisabled]}>
          <Text style={styles.permissionBadgeText}>Restricted</Text>
        </View>
      )}
    </View>
  );

  const renderCategory = () => {
    const category = departmentPermissions.find(cat => cat.title === selectedCategory);
    if (!category) return null;

    return (
      <View style={styles.categoryContainer}>
        <Text style={styles.categoryTitle}>{category.title}</Text>
        <FlatList
          data={category.permissions}
          renderItem={renderPermissionItem}
          keyExtractor={(item, index) => index.toString()}
          scrollEnabled={false}
          showsVerticalScrollIndicator={false}
        />
      </View>
    );
  };

  const departmentColor = getDepartmentColor(department);
  const departmentIcon = getDepartmentIcon(department);

  return (
    <View style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity 
          onPress={() => navigation.goBack()}
          style={styles.backButton}
        >
          <Icon name="arrow-left" size={24} color="#333" />
        </TouchableOpacity>
        
        <View style={styles.headerTitleContainer}>
          <View style={[styles.departmentIcon, { backgroundColor: `${departmentColor}15` }]}>
            <Icon name={departmentIcon as any} size={24} color={departmentColor} />
          </View>
          <View>
            <Text style={styles.headerTitle}>{department}</Text>
            <Text style={styles.headerSubtitle}>
              {departmentPermissions.length} permission categories
            </Text>
          </View>
        </View>
        
        <TouchableOpacity style={styles.menuButton}>
          <Icon name="dots-vertical" size={24} color="#64748B" />
        </TouchableOpacity>
      </View>

      <ScrollView
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[departmentColor]}
            tintColor={departmentColor}
          />
        }
        showsVerticalScrollIndicator={false}
      >
        {/* Department Overview */}
        <View style={styles.overviewContainer}>
          <Text style={styles.overviewTitle}>Department Overview</Text>
          <Text style={styles.overviewText}>
            Manage all {department} related operations and permissions. 
            Below are the available permission categories for this department.
          </Text>
          
          <View style={styles.statsContainer}>
            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: departmentColor }]}>
                {departmentPermissions.length}
              </Text>
              <Text style={styles.statLabel}>Categories</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: departmentColor }]}>
                {departmentPermissions.reduce((total, cat) => total + cat.permissions.length, 0)}
              </Text>
              <Text style={styles.statLabel}>Permissions</Text>
            </View>
            <View style={styles.statDivider} />
            <View style={styles.statItem}>
              <Text style={[styles.statValue, { color: departmentColor }]}>
                {departmentPermissions.reduce((total, cat) => 
                  total + cat.permissions.filter(p => hasPermission(p)).length, 0
                )}
              </Text>
              <Text style={styles.statLabel}>Granted</Text>
            </View>
          </View>
        </View>

        {/* Permission Categories */}
        <View style={styles.categoriesContainer}>
          <Text style={styles.sectionTitle}>Permission Categories</Text>
          
          <ScrollView 
            horizontal 
            showsHorizontalScrollIndicator={false}
            style={styles.categoriesScroll}
          >
            {departmentPermissions.map((category, index) => (
              <TouchableOpacity
                key={index}
                style={[
                  styles.categoryTab,
                  selectedCategory === category.title && [
                    styles.categoryTabActive,
                    { borderColor: departmentColor }
                  ]
                ]}
                onPress={() => setSelectedCategory(category.title)}
              >
                <Text style={[
                  styles.categoryTabText,
                  selectedCategory === category.title && [
                    styles.categoryTabTextActive,
                    { color: departmentColor }
                  ]
                ]}>
                  {category.title}
                </Text>
                <View style={styles.permissionCount}>
                  <Text style={styles.permissionCountText}>
                    {category.permissions.filter(p => hasPermission(p)).length}/{category.permissions.length}
                  </Text>
                </View>
              </TouchableOpacity>
            ))}
          </ScrollView>

          {/* Selected Category Permissions */}
          {renderCategory()}
        </View>

        {/* Quick Actions */}
        <View style={styles.actionsContainer}>
          <Text style={styles.sectionTitle}>Quick Actions</Text>
          <View style={styles.actionsGrid}>
            <TouchableOpacity style={styles.actionButton}>
              <View style={[styles.actionIcon, { backgroundColor: `${departmentColor}15` }]}>
                <Icon name="plus-circle" size={24} color={departmentColor} />
              </View>
              <Text style={styles.actionText}>Add New</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.actionButton}>
              <View style={[styles.actionIcon, { backgroundColor: `${departmentColor}15` }]}>
                <Icon name="chart-bar" size={24} color={departmentColor} />
              </View>
              <Text style={styles.actionText}>View Reports</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.actionButton}>
              <View style={[styles.actionIcon, { backgroundColor: `${departmentColor}15` }]}>
                <Icon name="cog" size={24} color={departmentColor} />
              </View>
              <Text style={styles.actionText}>Settings</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.actionButton}>
              <View style={[styles.actionIcon, { backgroundColor: `${departmentColor}15` }]}>
                <Icon name="download" size={24} color={departmentColor} />
              </View>
              <Text style={styles.actionText}>Export Data</Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* Department Info */}
        <View style={styles.infoContainer}>
          <Text style={styles.infoTitle}>About {department} Department</Text>
          <Text style={styles.infoText}>
            This department manages all {department.toLowerCase()} related operations. 
            You have access to specific permissions based on your role and responsibilities. 
            Contact your administrator for additional access requirements.
          </Text>
          
          <View style={styles.infoFooter}>
            <View style={styles.infoItem}>
              <Icon name="clock-outline" size={16} color="#64748B" />
              <Text style={styles.infoItemText}>Last updated: Today</Text>
            </View>
            <View style={styles.infoItem}>
              <Icon name="account-supervisor" size={16} color="#64748B" />
              <Text style={styles.infoItemText}>Managed by: Admin</Text>
            </View>
          </View>
        </View>
      </ScrollView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F8FAFC',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 20,
    backgroundColor: '#FFFFFF',
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },
  backButton: {
    padding: 8,
    marginRight: 12,
  },
  headerTitleContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
  },
  departmentIcon: {
    width: 40,
    height: 40,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: '#1E293B',
  },
  headerSubtitle: {
    fontSize: 12,
    color: '#64748B',
    marginTop: 2,
  },
  menuButton: {
    padding: 8,
  },
  scrollContent: {
    paddingHorizontal: 20,
    paddingBottom: 40,
  },
  overviewContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 20,
    marginTop: 20,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  overviewTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 8,
  },
  overviewText: {
    fontSize: 14,
    color: '#64748B',
    lineHeight: 20,
    marginBottom: 20,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
  },
  statItem: {
    alignItems: 'center',
    flex: 1,
  },
  statValue: {
    fontSize: 24,
    fontWeight: '700',
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 12,
    color: '#64748B',
  },
  statDivider: {
    width: 1,
    height: 40,
    backgroundColor: '#E2E8F0',
  },
  categoriesContainer: {
    marginTop: 24,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 16,
  },
  categoriesScroll: {
    marginBottom: 20,
  },
  categoryTab: {
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
    backgroundColor: '#F1F5F9',
    marginRight: 12,
    borderWidth: 2,
    borderColor: 'transparent',
    alignItems: 'center',
  },
  categoryTabActive: {
    backgroundColor: '#FFFFFF',
    borderWidth: 2,
  },
  categoryTabText: {
    fontSize: 14,
    fontWeight: '500',
    color: '#64748B',
  },
  categoryTabTextActive: {
    fontWeight: '600',
  },
  permissionCount: {
    marginTop: 4,
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 4,
    backgroundColor: '#F1F5F9',
  },
  permissionCountText: {
    fontSize: 11,
    color: '#64748B',
    fontWeight: '500',
  },
  categoryContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 20,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  categoryTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
    marginBottom: 16,
  },
  permissionItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#F1F5F9',
  },
  permissionIconContainer: {
    width: 32,
    marginRight: 12,
  },
  permissionText: {
    flex: 1,
    fontSize: 14,
    color: '#1E293B',
  },
  permissionDisabled: {
    color: '#94A3B8',
  },
  permissionBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 4,
    backgroundColor: '#D1FAE5',
  },
  permissionBadgeDisabled: {
    backgroundColor: '#FEE2E2',
  },
  permissionBadgeText: {
    fontSize: 11,
    fontWeight: '500',
    color: '#065F46',
  },
  actionsContainer: {
    marginTop: 24,
  },
  actionsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  actionButton: {
    width: '48%',
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  actionIcon: {
    width: 48,
    height: 48,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 12,
  },
  actionText: {
    fontSize: 13,
    color: '#475569',
    fontWeight: '500',
  },
  infoContainer: {
    marginTop: 24,
    backgroundColor: '#FAF5FF', // Light purple
    borderRadius: 12,
    padding: 20,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },
  infoTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#C084FC', // Purple
    marginBottom: 12,
  },
  infoText: {
    fontSize: 14,
    color: '#6B21A8',
    lineHeight: 20,
    marginBottom: 16,
  },
  infoFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  infoItem: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  infoItemText: {
    fontSize: 12,
    color: '#7E22CE',
    marginLeft: 6,
  },
});

export default DepartmentScreen;
========================================
FILE: src/screens/dashboard/MainDashboardScreen.tsx
========================================

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  RefreshControl,
  Dimensions,
  Alert,
} from 'react-native';
import { useNavigation, NavigationProp } from '@react-navigation/native';
import { useQuery } from '@tanstack/react-query';
import { MaterialCommunityIcons as Icon } from '@expo/vector-icons';

import { useAuth } from '@/contexts/AuthContext';
import { api } from '@/services/api';
import { useToast } from '@/components/Toast';
import DepartmentCard from '@/components/DepartmentCard';
import StatsOverview from '@/components/StatsOverview';

const { width } = Dimensions.get('window');

/* ============================================================
   Navigation Types
   ============================================================ */

type RootStackParamList = {
  MainDashboard: undefined;
  Profile: undefined;
  ChangeMPIN: undefined;
  Department: { department: string };
};

type MainDashboardScreenNavigationProp =
  NavigationProp<RootStackParamList, 'MainDashboard'>;

/* ============================================================
   Screen
   ============================================================ */

const MainDashboardScreen: React.FC = () => {
  const navigation = useNavigation<MainDashboardScreenNavigationProp>();
  const { adminInfo, logout } = useAuth();
  const { showToast } = useToast();

  const [refreshing, setRefreshing] = useState(false);
  const [dailyQuota, setDailyQuota] = useState({
    limit: 0,
    remaining: 0,
    used: 0,
  });

  const { data: profileData, refetch, isLoading } = useQuery({
    queryKey: ['adminProfile'],
    queryFn: () => api.getAdminProfile(),
    enabled: !!adminInfo,
  });

  useEffect(() => {
    if (profileData?.data?.daily_quota) {
      setDailyQuota(profileData.data.daily_quota);
    }
  }, [profileData]);

  const handleRefresh = async () => {
    setRefreshing(true);
    await refetch();
    setRefreshing(false);
  };

  const handleDepartmentPress = (department: string) => {
    navigation.navigate('Department', { department });
  };

  const handleLogout = () => {
    Alert.alert(
      'Logout',
      'Are you sure you want to logout?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Logout',
          style: 'destructive',
          onPress: async () => {
            await logout();
            showToast('success', 'Logged out successfully');
          },
        },
      ],
    );
  };

  const departments: string[] = adminInfo?.departments || [];

  const categorizedDepartments: Record<string, string[]> = {
    'Core Operations': departments.filter(dept =>
      ['HR', 'Finance', 'Accounting', 'Procurement', 'Inventory'].includes(dept),
    ),
    'Business Units': departments.filter(dept =>
      ['Sales', 'Marketing', 'Customer Support', 'Operations'].includes(dept),
    ),
    'Technical & Quality': departments.filter(dept =>
      ['IT', 'Production', 'Quality Control', 'Quality Assurance', 'R&D'].includes(dept),
    ),
    Administration: departments.filter(dept =>
      [
        'Administration',
        'Employee Management',
        'Manager Management',
        'Company Management',
        'Super Admin Management',
      ].includes(dept),
    ),
  };

  return (
    <View style={styles.container}>
      {/* ================= Header ================= */}
      <View style={styles.header}>
        <View style={styles.headerTitleContainer}>
          <Text style={styles.headerTitle}>Dashboard</Text>
          <Text style={styles.headerSubtitle}>
            Welcome back, {adminInfo?.full_name || 'Admin'}
          </Text>
        </View>

        <TouchableOpacity
          onPress={() => navigation.navigate('Profile')}
          style={styles.profileButton}
        >
          <Icon name="account-circle" size={32} color="#C084FC" /> {/* Purple */}
        </TouchableOpacity>
      </View>

      {/* ================= Content ================= */}
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={['#C084FC']} // Purple
            tintColor="#C084FC" // Purple
          />
        }
        showsVerticalScrollIndicator={false}
      >
        <StatsOverview
          dailyQuota={dailyQuota}
          permissions={adminInfo?.permissions?.length || 0}
          departments={departments.length}
          isLoading={isLoading}
        />

        {/* ================= Quick Actions ================= */}
        <View style={styles.actionsContainer}>
          <Text style={styles.sectionTitle}>Quick Actions</Text>
          <View style={styles.actionsGrid}>
            <TouchableOpacity 
              style={styles.actionButton}
              onPress={() => navigation.navigate('ChangeMPIN')}
            >
              <View style={styles.iconContainer}>
                <Icon name="key-change" size={24} color="#C084FC" />
              </View>
              <Text style={styles.actionLabel}>Change MPIN</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.actionButton}>
              <View style={styles.iconContainer}>
                <Icon name="file-document" size={24} color="#C084FC" />
              </View>
              <Text style={styles.actionLabel}>Reports</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.actionButton}>
              <View style={styles.iconContainer}>
                <Icon name="calendar-clock" size={24} color="#C084FC" />
              </View>
              <Text style={styles.actionLabel}>Attendance</Text>
            </TouchableOpacity>
            
            <TouchableOpacity style={styles.actionButton}>
              <View style={styles.iconContainer}>
                <Icon name="chart-bar" size={24} color="#C084FC" />
              </View>
              <Text style={styles.actionLabel}>Analytics</Text>
            </TouchableOpacity>
          </View>
        </View>

        {/* ================= Departments ================= */}
        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Departments</Text>
            <Text style={styles.sectionSubtitle}>
              {departments.length} departments available
            </Text>
          </View>

          {Object.entries(categorizedDepartments).map(([category, depts]) => {
            if (depts.length === 0) return null;

            return (
              <View key={category} style={styles.categorySection}>
                <Text style={styles.categoryTitle}>{category}</Text>
                <View style={styles.departmentsGrid}>
                  {depts.map((department, index) => (
                    <DepartmentCard
                      key={department}
                      department={department}
                      index={index}
                      onPress={() => handleDepartmentPress(department)}
                    />
                  ))}
                </View>
              </View>
            );
          })}
        </View>

        {/* ================= Daily Quota ================= */}
        {dailyQuota.limit > 0 && (
          <View style={styles.quotaContainer}>
            <View style={styles.quotaHeader}>
              <Icon name="chart-bar" size={20} color="#C084FC" /> {/* Purple */}
              <Text style={styles.quotaTitle}>Daily API Quota</Text>
            </View>

            <View style={styles.quotaBar}>
              <View
                style={[
                  styles.quotaFill,
                  { width: `${(dailyQuota.used / dailyQuota.limit) * 100}%` },
                ]}
              />
            </View>

            <View style={styles.quotaInfo}>
              <Text style={styles.quotaText}>
                {dailyQuota.used} / {dailyQuota.limit} requests used
              </Text>
              <Text style={styles.quotaText}>
                {dailyQuota.remaining} remaining
              </Text>
            </View>
          </View>
        )}

        {/* ================= Footer ================= */}
        <View style={styles.footer}>
          <TouchableOpacity onPress={handleLogout} style={styles.logoutButton}>
            <Icon name="logout" size={20} color="#DC2626" />
            <Text style={styles.logoutText}>Logout</Text>
          </TouchableOpacity>

          <Text style={styles.versionText}>Prayantra v1.0.0</Text>
        </View>
      </ScrollView>
    </View>
  );
};

export default MainDashboardScreen;

/* ============================================================
   Styles
   ============================================================ */

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#F8FAFC' },

  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 20,
    backgroundColor: '#FFFFFF',
    borderBottomWidth: 1,
    borderBottomColor: '#E2E8F0',
  },

  headerTitleContainer: { flex: 1 },

  headerTitle: {
    fontSize: 22,
    fontWeight: '700',
    color: '#1E293B',
  },

  headerSubtitle: {
    fontSize: 13,
    color: '#64748B',
    marginTop: 2,
  },

  profileButton: { padding: 8 },

  scrollContent: {
    paddingHorizontal: 20,
    paddingBottom: 40,
  },

  actionsContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginTop: 16,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },

  actionsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },

  actionButton: {
    width: '48%',
    alignItems: 'center',
    marginBottom: 16,
  },

  iconContainer: {
    width: 56,
    height: 56,
    borderRadius: 12,
    backgroundColor: '#FAF5FF', // Light purple background
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 8,
    borderWidth: 1,
    borderColor: '#E9D5FF',
  },

  actionLabel: {
    fontSize: 13,
    color: '#475569',
    textAlign: 'center',
  },

  section: { marginTop: 24 },

  sectionHeader: { marginBottom: 16 },

  sectionTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#1E293B',
  },

  sectionSubtitle: {
    fontSize: 14,
    color: '#64748B',
    marginTop: 4,
  },

  categorySection: { marginBottom: 24 },

  categoryTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#475569',
    marginBottom: 12,
  },

  departmentsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginHorizontal: -6,
  },

  quotaContainer: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginTop: 24,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },

  quotaHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },

  quotaTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1E293B',
    marginLeft: 8,
  },

  quotaBar: {
    height: 8,
    backgroundColor: '#E2E8F0',
    borderRadius: 4,
    overflow: 'hidden',
    marginBottom: 8,
  },

  quotaFill: {
    height: '100%',
    backgroundColor: '#C084FC', // Purple
    borderRadius: 4,
  },

  quotaInfo: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },

  quotaText: {
    fontSize: 13,
    color: '#64748B',
  },

  footer: {
    marginTop: 32,
    alignItems: 'center',
  },

  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    backgroundColor: '#FEF2F2',
    marginBottom: 16,
  },

  logoutText: {
    color: '#DC2626',
    fontSize: 14,
    fontWeight: '500',
    marginLeft: 8,
  },

  versionText: {
    fontSize: 12,
    color: '#94A3B8',
  },
});
========================================
FILE: src/screens/profile/ChangeMPINScreen.tsx
========================================

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Alert,
} from 'react-native';
import { useNavigation, NavigationProp } from '@react-navigation/native';
import { useMutation } from '@tanstack/react-query';
import { api } from '@/services/api';
import { useAuth } from '@/contexts/AuthContext';
import { useToast } from '@/components/Toast';
import MPINInput from '@/components/MPINInput';
import { getItem } from '@/services/storage';

// Define navigation types
type RootStackParamList = {
  MainDrawer: undefined;
  ChangeMPIN: undefined;
};

const ChangeMPINScreen = () => {
  const navigation = useNavigation<NavigationProp<RootStackParamList>>();
  const { adminInfo, logout } = useAuth();
  const { showToast } = useToast();

  const [currentMpin, setCurrentMpin] = useState('');
  const [newMpin, setNewMpin] = useState('');
  const [confirmMpin, setConfirmMpin] = useState('');
  const [step, setStep] = useState(1); // 1: Current MPIN, 2: New MPIN, 3: Confirm MPIN
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const changeMPINMutation = useMutation({
    mutationFn: (data: { currentMpin: string; newMpin: string }) => 
      api.changeMPIN(adminInfo?.admin_id || '', data.currentMpin, data.newMpin),
    onSuccess: () => {
      showToast('success', 'MPIN changed successfully');
      
      // Logout user for security
      Alert.alert(
        'MPIN Changed',
        'For security reasons, please login with your new MPIN.',
        [
          {
            text: 'OK',
            onPress: async () => {
              await logout();
            }
          }
        ]
      );
    },
    onError: (error: any) => {
      const errorType = error.response?.data?.error;
      const errorMessage = error.response?.data?.message || 'Failed to change MPIN';

      if (errorType === 'invalid admin MPIN') {
        setError('Current MPIN is incorrect');
        setStep(1);
        setCurrentMpin('');
        setNewMpin('');
        setConfirmMpin('');
      } else if (errorType === 'admin MPIN is too weak') {
        setError('New MPIN is too weak. Please choose a stronger MPIN.');
        setStep(2);
        setNewMpin('');
        setConfirmMpin('');
      } else {
        showToast('error', errorMessage);
        setStep(1);
        setCurrentMpin('');
        setNewMpin('');
        setConfirmMpin('');
      }
    },
    onSettled: () => {
      setIsLoading(false);
    },
  });

  const handleMPINComplete = (enteredMpin: string) => {
    if (step === 1) {
      // Verify current MPIN
      setCurrentMpin(enteredMpin);
      setError('');
      setStep(2);
    } else if (step === 2) {
      // Validate new MPIN
      if (isWeakMpin(enteredMpin)) {
        setError('MPIN is too weak. Please choose a stronger MPIN.');
        return;
      }

      if (enteredMpin === currentMpin) {
        setError('New MPIN cannot be same as current MPIN');
        return;
      }

      setNewMpin(enteredMpin);
      setError('');
      setStep(3);
    } else {
      // Confirm new MPIN
      if (enteredMpin === newMpin) {
        setIsLoading(true);
        changeMPINMutation.mutate({
          currentMpin,
          newMpin: enteredMpin
        });
      } else {
        setError('MPIN does not match. Please try again.');
        setStep(2);
        setNewMpin('');
        setConfirmMpin('');
      }
    }
  };

  const isWeakMpin = (mpin: string) => {
    const weakPatterns = [
      '111111', '222222', '333333', '444444', '555555',
      '666666', '777777', '888888', '999999', '000000',
      '123456', '654321', '121212', '123123', '112233'
    ];
    return weakPatterns.includes(mpin) || 
           mpin.split('').every((digit, i, arr) => digit === arr[0]);
  };

  const handleBack = () => {
    if (step === 1) {
      navigation.goBack();
    } else if (step === 2) {
      setStep(1);
      setCurrentMpin('');
      setError('');
    } else if (step === 3) {
      setStep(2);
      setNewMpin('');
      setConfirmMpin('');
      setError('');
    }
  };

  const getStepTitle = () => {
    switch (step) {
      case 1: return 'Enter Current MPIN';
      case 2: return 'Enter New MPIN';
      case 3: return 'Confirm New MPIN';
      default: return 'Change MPIN';
    }
  };

  const getStepInstruction = () => {
    switch (step) {
      case 1: return 'Enter your current 6-digit MPIN';
      case 2: return 'Create a new 6-digit MPIN';
      case 3: return 'Re-enter the new MPIN to confirm';
      default: return '';
    }
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Change MPIN</Text>
          <Text style={styles.headerSubtitle}>Update your secure login PIN</Text>
        </View>

        <View style={styles.formContainer}>
          <View style={styles.stepIndicator}>
            <View style={[styles.step, step >= 1 && styles.activeStep]}>
              <Text style={[styles.stepText, step >= 1 && styles.activeStepText]}>1</Text>
            </View>
            <View style={styles.stepLine} />
            <View style={[styles.step, step >= 2 && styles.activeStep]}>
              <Text style={[styles.stepText, step >= 2 && styles.activeStepText]}>2</Text>
            </View>
            <View style={styles.stepLine} />
            <View style={[styles.step, step >= 3 && styles.activeStep]}>
              <Text style={[styles.stepText, step >= 3 && styles.activeStepText]}>3</Text>
            </View>
          </View>

          <Text style={styles.title}>{getStepTitle()}</Text>
          <Text style={styles.subtitle}>{getStepInstruction()}</Text>

          <View style={styles.mpinContainer}>
            <MPINInput
              onComplete={handleMPINComplete}
              error={!!error}
              disabled={isLoading}
              autoFocus={true}
            />
          </View>

          {error ? (
            <View style={styles.errorContainer}>
              <Text style={styles.errorText}>{error}</Text>
            </View>
          ) : (
            <View style={styles.guidelinesContainer}>
              <Text style={styles.guidelinesTitle}>
                {step === 1 ? 'Verification:' : 'MPIN Guidelines:'}
              </Text>
              {step === 1 ? (
                <>
                  <Text style={styles.guideline}> Enter your current MPIN</Text>
                  <Text style={styles.guideline}> This verifies your identity</Text>
                  <Text style={styles.guideline}> Make sure no one is watching</Text>
                </>
              ) : step === 2 ? (
                <>
                  <Text style={styles.guideline}> Must be 6 digits</Text>
                  <Text style={styles.guideline}> Avoid simple patterns</Text>
                  <Text style={styles.guideline}> Don't use repeated digits</Text>
                  <Text style={styles.guideline}> Different from current MPIN</Text>
                </>
              ) : (
                <>
                  <Text style={styles.guideline}> Re-enter the new MPIN</Text>
                  <Text style={styles.guideline}> Make sure it matches exactly</Text>
                  <Text style={styles.guideline}> You'll be logged out after change</Text>
                  <Text style={styles.guideline}> Login with new MPIN</Text>
                </>
              )}
            </View>
          )}

          {isLoading && (
            <View style={styles.loadingContainer}>
              <Text style={styles.loadingText}>
                {step === 3 ? 'Changing MPIN...' : 'Verifying...'}
              </Text>
            </View>
          )}

          <TouchableOpacity
            style={styles.backButton}
            onPress={handleBack}
            disabled={isLoading}
          >
            <Text style={styles.backButtonText}>
               {step === 1 ? 'Cancel' : 'Back'}
            </Text>
          </TouchableOpacity>
        </View>

        <View style={styles.securityInfo}>
          <Text style={styles.securityTitle}>Important Security Notes:</Text>
          <Text style={styles.securityText}>
             You will be automatically logged out after MPIN change
            {'\n'} Login immediately with your new MPIN
            {'\n'} Never share your MPIN with anyone
            {'\n'} Choose a MPIN you can remember but others can't guess
            {'\n'} You can reset MPIN anytime from login screen
          </Text>
        </View>

        <View style={styles.userInfo}>
          <Text style={styles.userInfoText}>
            Changing MPIN for: {adminInfo?.full_name || 'Admin'}
          </Text>
          <Text style={styles.userInfoText}>
            Username: {adminInfo?.username || 'N/A'}
          </Text>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 40,
  },
  header: {
    marginBottom: 24,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: '700',
    color: '#1E293B',
    marginBottom: 4,
  },
  headerSubtitle: {
    fontSize: 14,
    color: '#64748B',
  },
  formContainer: {
    backgroundColor: '#F8F9FA',
    borderRadius: 16,
    padding: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
    marginBottom: 24,
  },
  stepIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 32,
  },
  step: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#E2E8F0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  activeStep: {
    backgroundColor: '#1565C0',
  },
  stepText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#64748B',
  },
  activeStepText: {
    color: '#FFFFFF',
  },
  stepLine: {
    width: 30,
    height: 2,
    backgroundColor: '#E2E8F0',
    marginHorizontal: 4,
  },
  title: {
    fontSize: 20,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 32,
    textAlign: 'center',
    lineHeight: 20,
  },
  mpinContainer: {
    marginBottom: 24,
  },
  errorContainer: {
    backgroundColor: '#FEF2F2',
    padding: 16,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#FECACA',
  },
  errorText: {
    color: '#DC2626',
    fontSize: 14,
    textAlign: 'center',
  },
  guidelinesContainer: {
    backgroundColor: '#F0F9FF',
    padding: 16,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#BAE6FD',
  },
  guidelinesTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#0369A1',
    marginBottom: 8,
  },
  guideline: {
    fontSize: 13,
    color: '#475569',
    marginBottom: 4,
    lineHeight: 18,
  },
  loadingContainer: {
    marginBottom: 24,
  },
  loadingText: {
    color: '#64748B',
    fontSize: 14,
    textAlign: 'center',
  },
  backButton: {
    alignItems: 'center',
    paddingVertical: 12,
  },
  backButtonText: {
    color: '#1565C0',
    fontSize: 14,
    fontWeight: '500',
  },
  securityInfo: {
    backgroundColor: '#FEF3C7',
    padding: 16,
    borderRadius: 8,
    marginBottom: 24,
    borderWidth: 1,
    borderColor: '#FDE68A',
  },
  securityTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#D97706',
    marginBottom: 8,
  },
  securityText: {
    fontSize: 12,
    color: '#92400E',
    lineHeight: 18,
  },
  userInfo: {
    backgroundColor: '#F1F5F9',
    padding: 16,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#E2E8F0',
  },
  userInfoText: {
    fontSize: 13,
    color: '#475569',
    marginBottom: 4,
  },
});

export default ChangeMPINScreen;
========================================
FILE: src/screens/profile/ProfileScreen.tsx
========================================

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const ProfileScreen = () => {
  return (
    <View style={styles.container}>
      <Text>Profile Screen</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default ProfileScreen;
========================================
FILE: src/services/api.ts
========================================

import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';
import { getItem, setItem, removeItem, STORAGE_KEYS } from './storage';
import { Platform } from 'react-native';
import { getStoredDeviceInfo } from './deviceInfo';
import { AuthTokens, ApiError } from '@/types';

const API_BASE_URL = 'http://192.168.31.102:8080/api/v1';
const API_TIMEOUT = 30000;

class ApiService {
  private static instance: ApiService;
  private isRefreshing = false;
  private failedQueue: Array<{
    resolve: (value?: unknown) => void;
    reject: (reason?: unknown) => void;
  }> = [];

  private constructor() {
    this.setupInterceptors();
  }

  static getInstance(): ApiService {
    if (!ApiService.instance) {
      ApiService.instance = new ApiService();
    }
    return ApiService.instance;
  }

  private getApi() {
    return axios.create({
      baseURL: API_BASE_URL,
      timeout: API_TIMEOUT,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-Platform': Platform.OS,
        'X-App-Version': '1.0.0',
      },
    });
  }

  private setupInterceptors() {
    const api = this.getApi();

    // Request interceptor
    api.interceptors.request.use(
      async (config) => {
        try {
          const accessToken = await getItem(STORAGE_KEYS.ACCESS_TOKEN);
          
          if (accessToken) {
            config.headers.Authorization = `Bearer ${accessToken}`;
          }

          // Add device info for auth endpoints
          if (config.url?.includes('/auth') || config.url?.includes('/otp')) {
            const deviceInfo = await getStoredDeviceInfo();
            if (config.data && deviceInfo) {
              config.data.device_id = deviceInfo.deviceId;
              config.data.device_fingerprint = deviceInfo.deviceFingerprint;
              config.data.user_agent = deviceInfo.userAgent;
            }
          }

          return config;
        } catch (error) {
          return Promise.reject(error);
        }
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor
    api.interceptors.response.use(
      (response) => response,
      async (error: AxiosError<ApiError>) => {
        const originalRequest = error.config as AxiosRequestConfig & { _retry?: boolean };

        // Handle 429 Rate Limit
        if (error.response?.status === 429) {
          const retryAfter = error.response.data?.retry_after || 5;
          await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
          return this.getApi()(originalRequest);
        }

        // Handle 401 Unauthorized
        if (error.response?.status === 401 && !originalRequest._retry) {
          if (error.response.data?.error === 'MPIN rate limit exceeded') {
            throw error;
          }

          if (this.isRefreshing) {
            return new Promise((resolve, reject) => {
              this.failedQueue.push({ resolve, reject });
            }).then(() => this.getApi()(originalRequest))
              .catch(err => Promise.reject(err));
          }

          originalRequest._retry = true;
          this.isRefreshing = true;

          try {
            const refreshToken = await getItem(STORAGE_KEYS.REFRESH_TOKEN);
            
            if (!refreshToken) {
              throw new Error('No refresh token available');
            }

            const response = await this.refreshToken(refreshToken);
            const newAccessToken = response.data.access_token;
            
            await setItem(STORAGE_KEYS.ACCESS_TOKEN, newAccessToken);
            await setItem(STORAGE_KEYS.REFRESH_TOKEN, response.data.refresh_token);

            // Retry failed requests
            this.processQueue(null, newAccessToken);

            // Retry original request
            originalRequest.headers = {
              ...originalRequest.headers,
              Authorization: `Bearer ${newAccessToken}`,
            };
            
            return this.getApi()(originalRequest);
          } catch (refreshError) {
            this.processQueue(refreshError, null);
            
            // Clear all auth data
            await removeItem(STORAGE_KEYS.ACCESS_TOKEN);
            await removeItem(STORAGE_KEYS.REFRESH_TOKEN);
            await removeItem(STORAGE_KEYS.ADMIN_INFO);
            
            throw refreshError;
          } finally {
            this.isRefreshing = false;
          }
        }

        return Promise.reject(error);
      }
    );

    return api;
  }

  private processQueue(error: unknown, token: string | null) {
    this.failedQueue.forEach(promise => {
      if (error) {
        promise.reject(error);
      } else {
        promise.resolve(token);
      }
    });
    this.failedQueue = [];
  }

  // Auth APIs
  async loginInitiate(phoneNumber: string) {
    const deviceInfo = await getStoredDeviceInfo();
    return this.getApi().post('/admin-auth/login/initiate', {
      phone_number: phoneNumber,
      device_id: deviceInfo.deviceId,
      device_fingerprint: deviceInfo.deviceFingerprint,
    });
  }

  async sendOTP(phoneNumber: string, purpose: 'admin_login') {
    const deviceInfo = await getStoredDeviceInfo();
    return this.getApi().post('/otp/send', {
      phone_number: phoneNumber,
      purpose,
      device_id: deviceInfo.deviceId,
      device_fingerprint: deviceInfo.deviceFingerprint,
      user_agent: deviceInfo.userAgent,
    });
  }

  async verifyOTP(phoneNumber: string, otp: string) {
    const deviceInfo = await getStoredDeviceInfo();
    return this.getApi().post('/admin-auth/login/verify-otp', {
      phone_number: phoneNumber,
      otp,
      device_id: deviceInfo.deviceId,
      device_fingerprint: deviceInfo.deviceFingerprint,
      user_agent: deviceInfo.userAgent,
    });
  }

  async setupMPIN(adminId: string, mpin: string) {
    const deviceInfo = await getStoredDeviceInfo();
    return this.getApi().post('/admin-auth/mpin/setup', {
      admin_id: adminId,
      mpin,
      device_id: deviceInfo.deviceId,
      device_fingerprint: deviceInfo.deviceFingerprint,
      user_agent: deviceInfo.userAgent,
    });
  }

  async verifyMPIN(phoneNumber: string, mpin: string) {
    const deviceInfo = await getStoredDeviceInfo();
    return this.getApi().post('/admin-auth/login/verify-mpin', {
      phone_number: phoneNumber,
      mpin,
      device_id: deviceInfo.deviceId,
      device_fingerprint: deviceInfo.deviceFingerprint,
      user_agent: deviceInfo.userAgent,
    });
  }

  async changeMPIN(adminId: string, currentMpin: string, newMpin: string) {
    const deviceInfo = await getStoredDeviceInfo();
    return this.getApi().post('/admin-auth/mpin/change', {
      admin_id: adminId,
      current_mpin: currentMpin,
      new_mpin: newMpin,
      device_id: deviceInfo.deviceId,
      device_fingerprint: deviceInfo.deviceFingerprint,
      user_agent: deviceInfo.userAgent,
    });
  }

  async forgotMPIN(phoneNumber: string) {
    const deviceInfo = await getStoredDeviceInfo();
    return this.getApi().post('/admin-auth/mpin/forgot', {
      phone_number: phoneNumber,
      device_id: deviceInfo.deviceId,
      device_fingerprint: deviceInfo.deviceFingerprint,
      user_agent: deviceInfo.userAgent,
    });
  }

  async verifyForgotMPIN(phoneNumber: string, otpCode: string, newMpin: string) {
    const deviceInfo = await getStoredDeviceInfo();
    return this.getApi().post('/admin-auth/mpin/forgot/verify', {
      phone_number: phoneNumber,
      device_id: deviceInfo.deviceId,
      new_mpin: newMpin,
      otp_code: otpCode,
      device_fingerprint: deviceInfo.deviceFingerprint,
      user_agent: deviceInfo.userAgent,
    });
  }

  async refreshToken(refreshToken: string) {
    return this.getApi().post('/admin-auth/refresh', {
      refresh_token: refreshToken,
    });
  }

  async logout(refreshToken: string) {
    return this.getApi().post('/admin-auth/logout', {
      refresh_token: refreshToken,
    });
  }

  // Admin Profile API
  async getAdminProfile() {
    return this.getApi().get('/admin/profile');
  }
}

export const api = ApiService.getInstance();
========================================
FILE: src/services/deviceInfo.ts
========================================

import * as Crypto from 'expo-crypto';
import * as Device from 'expo-device';
import * as LocalAuthentication from 'expo-local-authentication';
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';
import { getItem, setItem } from './storage';

// Keychain/Keystore keys
const SECURE_DEVICE_ID_KEY = 'prayantra_persistent_device_id';

export interface DeviceInfo {
  deviceId: string;
  deviceFingerprint: string;
  userAgent: string;
  biometricType: string;
  isBiometricSupported: boolean;
  secureStorageAvailable: boolean;
}

const generateSecureUserAgent = (): string => {
  const appName = 'Prayantra';
  const appVersion = '1.0';
  const platform = Platform.OS;
  
  if (platform === 'ios') {
    return `${appName}/${appVersion} (iOS)`;
  } else if (platform === 'android') {
    return `${appName}/${appVersion} (Android)`;
  } else {
    return `${appName}/${appVersion} (${platform})`;
  }
};

export const getDeviceInfo = async (): Promise<DeviceInfo> => {
  try {
    // Generate or retrieve device ID
    let deviceId = await SecureStore.getItemAsync(SECURE_DEVICE_ID_KEY);
    
    if (!deviceId) {
      const randomBytes = Crypto.getRandomBytes(32);
      const timestamp = Date.now().toString(36);
      const uniqueString = `${Device.modelName}-${Device.brand}-${Platform.OS}-${timestamp}-${Array.from(randomBytes).join('')}`;
      const deviceHash = await Crypto.digestStringAsync(
        Crypto.CryptoDigestAlgorithm.SHA256,
        uniqueString
      );
      
      deviceId = `prayantra-${Platform.OS}-${deviceHash.substring(0, 16)}`;
      await SecureStore.setItemAsync(SECURE_DEVICE_ID_KEY, deviceId);
    }

    // Generate device fingerprint
    const fingerprintData = {
      device_id: deviceId,
      device_model: Device.modelName || 'Unknown',
      device_brand: Device.brand || 'Unknown',
      platform: Platform.OS,
      os_version: Device.osVersion || 'Unknown',
      is_emulator: !Device.isDevice,
      timestamp: new Date().toISOString()
    };

    const deviceFingerprint = JSON.stringify(fingerprintData);
    const userAgent = generateSecureUserAgent();

    // Check biometric capabilities
    const hasHardware = await LocalAuthentication.hasHardwareAsync();
    const isEnrolled = await LocalAuthentication.isEnrolledAsync();
    const isBiometricSupported = hasHardware && isEnrolled;
    
    let biometricType = 'none';
    if (isBiometricSupported) {
      const supportedBiometrics = await LocalAuthentication.supportedAuthenticationTypesAsync();
      if (supportedBiometrics.includes(LocalAuthentication.AuthenticationType.FINGERPRINT)) {
        biometricType = 'fingerprint';
      } else if (supportedBiometrics.includes(LocalAuthentication.AuthenticationType.FACIAL_RECOGNITION)) {
        biometricType = 'face_id';
      }
    }

    // Store in AsyncStorage for quick access
    await setItem('device_id', deviceId);
    await setItem('device_fingerprint', deviceFingerprint);
    await setItem('user_agent', userAgent);

    return {
      deviceId,
      deviceFingerprint,
      userAgent,
      biometricType,
      isBiometricSupported,
      secureStorageAvailable: true,
    };
  } catch (error) {
    console.error('Device info generation failed:', error);
    // Fallback
    const fallbackId = `prayantra-${Platform.OS}-${Date.now()}`;
    return {
      deviceId: fallbackId,
      deviceFingerprint: JSON.stringify({ device_id: fallbackId }),
      userAgent: generateSecureUserAgent(),
      biometricType: 'none',
      isBiometricSupported: false,
      secureStorageAvailable: false,
    };
  }
};

export const getStoredDeviceInfo = async (): Promise<DeviceInfo> => {
  try {
    const deviceId = await getItem('device_id') || '';
    const deviceFingerprint = await getItem('device_fingerprint') || '';
    const userAgent = await getItem('user_agent') || generateSecureUserAgent();

    if (!deviceId || !deviceFingerprint) {
      return getDeviceInfo();
    }

    return {
      deviceId,
      deviceFingerprint,
      userAgent,
      biometricType: 'none',
      isBiometricSupported: false,
      secureStorageAvailable: true,
    };
  } catch (error) {
    console.error('Error getting stored device info:', error);
    return getDeviceInfo();
  }
};

export const initializeDeviceInfo = async (): Promise<void> => {
  console.log(" INITIALIZING DEVICE INFORMATION...");
  try {
    await getDeviceInfo();
    console.log(" DEVICE INFORMATION INITIALIZED");
  } catch (error) {
    console.error(" DEVICE INITIALIZATION FAILED:", error);
  }
};
========================================
FILE: src/services/storage.ts
========================================

import AsyncStorage from '@react-native-async-storage/async-storage';
import * as SecureStore from 'expo-secure-store';

// Regular storage for non-sensitive data
export const setItem = async (key: string, value: string): Promise<void> => {
  try {
    await AsyncStorage.setItem(key, value);
  } catch (error) {
    console.error('Error storing data:', error);
  }
};

export const getItem = async (key: string): Promise<string | null> => {
  try {
    return await AsyncStorage.getItem(key);
  } catch (error) {
    console.error('Error retrieving data:', error);
    return null;
  }
};

export const removeItem = async (key: string): Promise<void> => {
  try {
    await AsyncStorage.removeItem(key);
  } catch (error) {
    console.error('Error removing data:', error);
  }
};

// Clear only session data, keep phone number and device info
export const clearSessionData = async (): Promise<void> => {
  try {
    const keys = [
      'access_token',
      'refresh_token',
      'admin_info',
    ];

    await AsyncStorage.multiRemove(keys);
    console.log(" SESSION DATA CLEARED, PHONE NUMBER & ADMIN ID PRESERVED");
  } catch (error) {
    console.error('Error clearing session data:', error);
  }
};

// Clear everything including phone number and admin ID
export const clearAllUserData = async (): Promise<void> => {
  try {
    const keys = [
      'access_token',
      'refresh_token',
      'admin_id',
      'admin_info',
      'phone_number',
      'country_code',
    ];

    await AsyncStorage.multiRemove(keys);
    console.log(" ALL USER DATA CLEARED");
  } catch (error) {
    console.error('Error clearing all user data:', error);
  }
};

// Clear everything including device info (only for app uninstall scenarios)
export const clearAllStorage = async (): Promise<void> => {
  try {
    // Clear all AsyncStorage
    await AsyncStorage.clear();
    
    // Clear all SecureStore
    await SecureStore.deleteItemAsync('persistent_device_id');
    await SecureStore.deleteItemAsync('installation_id');
    
    console.log(" COMPLETE STORAGE CLEARED INCLUDING DEVICE INFO");
  } catch (error) {
    console.error('Error clearing all storage:', error);
  }
};

// Helper to check if user has stored phone number
export const hasStoredPhoneNumber = async (): Promise<boolean> => {
  try {
    const phoneNumber = await getItem('phone_number');
    const adminId = await getItem('admin_id');
    return !!(phoneNumber && adminId);
  } catch (error) {
    return false;
  }
};

// Get formatted phone number with country code
export const getFormattedPhoneNumber = async (): Promise<string | null> => {
  try {
    const phoneNumber = await getItem('phone_number');
    const countryCode = await getItem('country_code') || '+91';
    
    if (phoneNumber) {
      return `${countryCode}${phoneNumber}`;
    }
    return null;
  } catch (error) {
    return null;
  }
};

// Add these constants at the top
export const STORAGE_KEYS = {
  ACCESS_TOKEN: 'access_token',
  REFRESH_TOKEN: 'refresh_token',
  ADMIN_ID: 'admin_id',
  ADMIN_INFO: 'admin_info',
  PHONE_NUMBER: 'phone_number',
  COUNTRY_CODE: 'country_code',
  DEVICE_ID: 'device_id',
  USER_AGENT: 'user_agent',
  IS_FIRST_LAUNCH: 'is_first_launch',
  ROLE_MASK: 'role_mask',
  PERMISSION_MASK: 'permission_mask',
};

// Add this helper function
export const getAdminRole = async (): Promise<number> => {
  try {
    const adminInfoStr = await getItem('admin_info');
    if (adminInfoStr) {
      const adminInfo = JSON.parse(adminInfoStr);
      return adminInfo.role_mask || 0;
    }
    return 0;
  } catch (error) {
    console.error('Error getting admin role:', error);
    return 0;
  }
};
========================================
FILE: src/types/index.ts
========================================

export interface AdminAuthResponse {
    success: boolean;
    data: {
      user_exists: boolean;
      has_mpin: boolean;
      mpin_locked: boolean;
      device_trusted: boolean;
      flow_state: string;
      message: string;
      user_id: string;
    };
    message: string;
    timestamp: string;
  }
  
  export interface OTPVerifyResponse {
    success: boolean;
    data: {
      admin_id: string;
      daily_quota: {
        limit: number;
        remaining: number;
        used: number;
      };
      device_trusted: boolean;
      has_mpin: boolean;
      message: string;
      mpin_locked: boolean;
    };
    message: string;
    timestamp: string;
  }
  
  export interface MPINVerifyResponse {
    success: boolean;
    data: {
      admin: AdminInfo;
      message: string;
      tokens: AuthTokens;
    };
    message: string;
    timestamp: string;
  }
  
  export interface AdminInfo {
    admin_id: string;
    departments: string[];
    full_name: string;
    is_active: boolean;
    permissions: string[];
    role_string: string;
    role_type: number;
    username: string;
  }
  
  export interface AuthTokens {
    access_token: string;
    refresh_token: string;
    expires_in: number;
    token_type: string;
  }
  
  export interface DeviceInfo {
    deviceId: string;
    deviceFingerprint: string;
    userAgent: string;
    biometricType: string;
    isBiometricSupported: boolean;
    secureStorageAvailable: boolean;
  }
  
  export interface ApiError {
    success: boolean;
    error?: string;
    message: string;
    timestamp: string;
    retry_after?: number;
    expires_at?: string;
  }
  
  export type LoginFlowState = 
    | 'existing_user_mpin'
    | 'new_user_no_mpin'
    | 'device_not_trusted'
    | 'mpin_locked';
  
  export interface DailyQuota {
    limit: number;
    remaining: number;
    used: number;
  }
  
  export interface AxiosErrorResponse {
    response?: {
      status: number;
      data: ApiError;
      config?: {
        data?: string;
      };
    };
  }